[{"title":"2019, 改变自己","url":"/2019/02/11/2019-starting/","content":"\n新年上班第一天，拿到开年红包。预祝自己新年新气象，创造新自己。\n\n<!-- more -->\n\n### 回首2018\n\n此处省略2000字(原因你懂得)......\n\n### 2019 Flag\n\n#### 论思维\n\n不善交际、不善表达、不善整理、不善总结的我，越来越意识到问题的严重性，必须找出问题，改变自己。\n\n深思了下，导致上面问题的根本原因是思维混乱。举个简单例子：看完一篇文章，学到了新的知识，但这些知识在脑海中处于碎片状态，又没有及时整理复盘并消化。这样碎片化的内容就成了表达的障碍，表达的障碍就成了交际的绊脚石。\n\n类似的问题在生活、工作的各方面都有存在。遇到了问题，解决了问题，却没有及时的整理复盘，依旧等于没解决。\n\n新年需要加强这方面的能力，多做整理复盘、多做总结、多表达、多交际。\n\n#### 论读书\n\n书是人类进步的阶梯，这句名言从小铭记于心，但并没发挥它的作用，还是基本不看书。\n\n今年励志多读书、多做笔记、多进步，以下列举了今年要看的书籍，覆盖了读书、整理、科技、营销、理财等多方面的内容。\n\n* 1 《如何阅读一本书》\n* 2 《思维导图》\n* 3 《市场营销(MBA轻松读)》\n* 4 《参与感：小米口碑营销内部手册》\n* 5 《运营之光》\n* 6 《AI * 未来》\n* 7 《腾讯传》\n* 8 《一本书读懂投资理财》\n* 9 《百岁人生》\n* 10 《读书是一辈子的事儿》\n* 11 《思考、快与慢》\n* 12 《定位》\n* 13 《疯传》\n* 14 《增长黑客》\n* 15 《怪诞行为学》\n\n#### 论工作\n\n还没想好咋写......\n\n#### 论旅游\n\n今年要陪她来一次长途旅行。在一起4年多，却只有过一次旅行，实在说不过去。\n\n#### 论健康\n\n不运动、身体虚、还肥胖，😂 ......\n\n身体是革命的本钱，身体不好，啥都别谈。今年得运动起来。\n\n励志每周至少两次运动，跑步、打球、健身、爬山都行\n\n### 总结\n\n2019不能再像去年一样荒废，需要改变自己，换一种活法。从思维、读书、工作、健康这三方面入手，希望自己能通过这一年的努力，真的实现改变自己。\n\n\n\n","tags":["年终总结","新年Flag"],"categories":["生活"]},{"title":"Git项目仓库迁移","url":"/2019/01/10/git-project-relocate/","content":"\n前几天，github开放了免费的私有库，这是无非是github被微软收购之后，给开发者的一个最大的新年贺礼。\n\n在没开放私有库之前，开发者只能使用国内的Coding、chinaos、CSDN、京东，或者国外的Bitbucket。\n\n那么现在可能会面临一个问题，就是如何将其他托管平台的私有库迁移到github上去呢？可以有如下几种方法。\n\n我使用chinaos往github上迁移为例，迁移项目名为RelocateTest。\n\n<!-- more -->\n\n### 方案一\n\n**1. 使用命令从chinaos导出一份裸体仓库代码**\n\n```\ngit clone --bare git@gitee.com:devjackcat/RelocateTest.git\n```\n\n使用--bare参数clone的代码是不是任何版本信息的，导出文件结构也和普通 git clone 不一样，其中包含了，branch信息、commit记录、tag等信息。\n\n![](http://static.devjackcat.com/15471753582310.jpg)\n\n**2. 在github新建一个RelocateTest项目**\n\n以镜像的形式进行push\n\n```\ngit push --mirror git@github.com:devjackcat/RelocateTest.git\n```\n从push结果中可以看到push了哪些内容\n![](http://static.devjackcat.com/15471771278565.jpg)\n可以看到推送了两个branch，两个tag\n\n**3. 登录github查看push结果，看到如下结果，则说明已迁移成功。**\n\n![](http://static.devjackcat.com/15471755629317.jpg)\n\n\n### 方案二\n\n直接在原仓库下更改仓库地址,但**这种方式只会同步当前分支的信息，其他branch，tag都不会同步不**\n\n**1. 更改仓库地址**\n\n```\ngit remote set-url origin git@github.com:devjackcat/RelocateTest.git\n```\n\n**2. push至新仓库**\n\n```\ngit push\n```\n\n### 方案三\n\n直接在github新建项目时，点击 \"import code\" 按钮，填入原项目地址(只能使用http方式进行import)，“Begin Import”即可。\n\n该方案无法导入私有库\n\n","tags":["Git项目迁移"],"categories":["Git"]},{"title":"iOS获取时间的方法","url":"/2018/03/06/get-ios-time/","content":"\n# 记录时间的方法\n\n为了记录耗时，这样就需要在 pushCallRecord 和 popCallRecord 里记录下时间。下面列出一些计算一段代码开始到结束的时间的方法\n\n<!-- more -->\n\n第一种： NSDate 微秒\n\n```\nNSDate* tmpStartData = [NSDate date];\n//some code need caculate\ndouble deltaTime = [[NSDate date] timeIntervalSinceDate:tmpStartData];\nNSLog(@\"cost time: %f s\", deltaTime);\n```\n\n第二种：clock_t 微秒clock_t计时所表示的是占用CPU的时钟单元\n\n```\nclock_t start = clock();\n//some code need caculate\nclock_t end = clock();\nNSLog(@\"cost time: %f s\", (double)(end - start)/CLOCKS_PER_SEC);\n```\n\n第三种：CFAbsoluteTime 微秒\n\n```\nCFAbsoluteTime start = CFAbsoluteTimeGetCurrent();\n//some code need caculate\nCFAbsoluteTime end = CFAbsoluteTimeGetCurrent();\nNSLog(@\"cost time = %f s\", end - start); //s\n```\n\n第四种：CFTimeInterval 纳秒\n\n```\nCFTimeInterval start = CACurrentMediaTime();\n//some code need caculate\nCFTimeInterval end = CACurrentMediaTime();\nNSLog(@\"cost time: %f s\", end - start);\n```\n\n第五种：mach_absolute_time 纳秒\n\n```\nuint64_t start = mach_absolute_time ();\n//some code need caculate\nuint64_t end = mach_absolute_time ();\nuint64_t elapsed = 1e-9 *(end - start);\n```\n\n最后两种可用，本质区别\nNSDate 或 CFAbsoluteTimeGetCurrent() 返回的时钟时间将会会网络时间同步，从时钟 偏移量的角度。mach_absolute_time() 和 CACurrentMediaTime() 是基于内建时钟的。选择一种，加到 pushCallRecord 和 popCallRecord 里，相减就能够获得耗时。\n\n# 参考\n\n* [深入剖析 iOS 性能优化](https://xiaozhuanlan.com/topic/2847503196)\n\n\n","tags":["性能优化"],"categories":["性能优化"]},{"title":"字符串解析","url":"/2017/04/17/string-parsing/","content":"\n在几乎每一种计算机程序语言中，解析字符串都是我们不得不面对的问题。有时这些字符串以一种简单的格式出现，有时它们又变得很复杂。我们将利用多种方法把字符串转换成我们需要的东西。下面，我们将讨论正则表达式、扫描器、解析器以及在什么时候使用它们。\n\n<!-- more -->\n\n# 正则法 vs. 上下文无关文法（Context-Free Grammars）\n\n首先，介绍一点点背景知识：解析一个字符串，其实就是用特定的语言来描述它。例如：把 @\"42\" 解析成数字，我们会采用自然数来描述这个字符串。语言都是用语法来描述的，语法其实就是一些规则的集合，这些规则可以用字符串来描述。比如自然数，仅仅有一条规则：字符串的描述就是一个数字序列。这种语言也可以用标准 C 函数或者正则表达式来描述。如果我们用正则表达式来描述一种语言，我们就可以说它有正则语法。\n\n假设我们有一个表达式：\"1 + 2 * 3\"，解析它就不容易。像这种表达式，我们可以用归纳语法来描述。换句话说，就是有一种语法，它的规则就是指的是它们自己，有时候甚至是递归的方式。为了识别这种语法，我们有三个规则：\n\n1. 任何数字都是语言的成员。\n2. 如果 x 是语言的成员，同时 y 也是语言的成员，那么 x+y 也是语言的成员。\n3. 如果 x 是语言的成员，同时 y 也是语言的成员，那么 x*y 也是语言的成员。\n\n使用这种语法描述的语言称之为**上下文无关文法 (context-free grammars)**，或者简称 CFG 1。需要注意的是这种语法不能使用正则表达式来解析（虽然一些正则表达式能实现，如 PCRE，但这远远超越了一般的正则语法）。一个经典的例子就是括号匹配，它可以用 CFG 来解析，却不能用正则表达式 2。\n\n像数字，字符串和时间这些，就可以用正则语言来解析。意思是说你可以使用正则表达式（或者相似的技术）去解析它们。\n\n像邮箱地址，JSON，XML 以及其它大多数的编程语言，都不能够使用正则表达式来解析 3。我们需要一个真正的解析器来解析它们。大多数时候，我们需要的解析器就有现成的。苹果就已经为我们提供了 XML 和 JSON 解析器，如果想要解析 XML 和 JSON，用苹果的就可以了。\n\n# 正则表达式\n\n当你想要去识别一些简单的语言时，正则表达式是一个好工具。但是，它们经常被滥用在一些不适合它们的地方，比如 HTML 的解析。现在假定我们有一个文件, 其中包含一个简单的定义颜色的变量,设计者们可以利用该变量来改变你 iPhone app 中的颜色。格式如下:\n\n```\nbackgroundColor = #ff0000\n```\n\n想要解析这种格式，我们就可以用正则表达式。正则表达式中最重要的是**模式（pattern）**。如果你不知道什么是正则表达式，我们将很快的重新温习一下，但是完全的解释什么是正则表达式已经超出了这篇文章的范围。首先，我们来看一下 \\\\w+, 它的意思是匹配任何一个数字、字母或者是下划线至少一次（\\\\w 代表匹配任意一个数字、字母或者是下划线，+ 代表至少匹配一次）。然后，为了确保我们以后可以使用匹配的结果，需要用括号将它括起来，创建一个**捕获组（capture group）**。接下来是一个空格符，一个等号，又一个空格符和一个 # 号。然后，我们需要匹配 6 个十六进制数字。\\\\p{Hex_Digit} 意思是匹配一个十六进制数字（Hex_Digit 是一个 unicode 属性名）。修饰符 {6} 意味着我们需要匹配 6 个，然后和之前一样，把这些一起用括号括起来，这样就创建了第二个捕获组:\n\n```\nNSError *error = nil;\nNSString *pattern = @\"(\\\\w+) = #(\\\\p{Hex_Digit}{6})\";\nNSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:pattern\n                                                                            options:0\n                                                                              error:&error];\nNSTextCheckingResult *result = [expression firstMatchInString:string \n                                                      options:0\n                                                        range:NSMakeRange(0, string.length)];\nNSString *key = [string substringWithRange:[result rangeAtIndex:1]];\nNSString *value = [string substringWithRange:[result rangeAtIndex:2]];\n```\n\n上面我们创建了一个正则表达式对象，让它匹配一个字符串对象 string，通过 rangeAtIndex 方法可以获取用括号捕获的两组数据。在匹配的结果对象中，索引 0 是正则表达式对象自己，索引 1 是第一个捕获组，索引 2 是第二个捕获组，依此类推。最后，我们获取到的 key 的值是 backgroundColor，value 的值是 ff0000。上面的正则表达式只解析了一行，下一步我们将要解析多行，并添加一些错误检查。比如，输入如下：\n\n```\nbackgroundColor = #ff0000\ntextColor = #0000ff\n```\n\n首先，利用换行符将输入字符串分隔开，然后遍历返回的数组，并将解析的结果添加到我们的字典中，最后我们将生成这样一个字典：@{@\"backgroundColor\": @\"ff0000\", @\"textColor\": @\"0000ff\"}。下面是具体的代码：\n\n```\nNSString *pattern = @\"(\\\\w+) = #([\\\\da-f]{6})\";\nNSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:pattern\n                                                                            options:0 \n                                                                              error:NULL];\nNSArray *lines = [input componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];\nNSMutableDictionary *result = [NSMutableDictionary dictionary];\nfor (NSString *line in lines) {\n    NSTextCheckingResult *textCheckingResult = [expression firstMatchInString:line \n                                                                      options:0 \n                                                                        range:NSMakeRange(0, line.length)];\n    NSString* key = [line substringWithRange:[textCheckingResult rangeAtIndex:1]];\n    NSString* value = [line substringWithRange:[textCheckingResult rangeAtIndex:2]];\n    result[key] = value;\n}\nreturn result;\n```\n\n说句题外话，将字符串分解成数组，你还可以用 componentsSeparatedByString: 这个方法，或者用 enumerateSubstringsInRange:options:usingBlock: 这个方法来枚举子串，其中 option 这个参数应该传 NSStringEnumerationByLines。\n\n假如某一行数据没有匹配上（比如，我们不小心忘记一个十六进制字符），我们可以检查 textCheckingResult 对象是否为 nil，如果为 nil，就抛出一个错误，代码如下：\n\n```\n if (!textCheckingResult) {\n     NSString* message = [NSString stringWithFormat:@\"Couldn't parse line: %@\", line]\n     NSDictionary *errorDetail = @{NSLocalizedDescriptionKey: message};\n     *error = [NSError errorWithDomain:MyErrorDomain code:FormatError userInfo:errorDetail];\n     return nil;\n }\n```\n\n# 扫描器（Scanner）\n\n把一个字符串转化为一个字典，还有一种方式就是使用扫描器。幸运的是，Foundation 框架为我们提供了 NSScanner，一个易于使用的面向对象的API。首先，我们需要创建一个扫描器：\n\n```\nNSScanner *scanner = [NSScanner scannerWithString:string];\n```\n\n默认情况下，扫描器会跳过所有空格符和换行符。但这里我们只希望跳过空格符：\n\n```\nscanner.charactersToBeSkipped = [NSCharacterSet whitespaceCharacterSet];\n```\n\n然后,我们定义一个十六进制字符集。系统定义了很多字符集，但却没有十六进制字符集：\n\n```\nNSCharacterSet *hexadecimalCharacterSet = \n  [NSCharacterSet characterSetWithCharactersInString:@\"0123456789abcdefABCDEF\"];\n```\n\n我们先写一个没有错误检查的版本。扫描器的工作原理是这样的：它接收一个字符串，并将光标设置在字符串的开始处。然后调用扫描方法，像这样：[sanner scanString:@\"=\" intoString:NULL]。如果扫描成功，该方法会返回 YES，光标会自动后移。scanCharactersFromSet:intoString: 方法的工作原理和之前的相似，只不过它扫描的是字符集，并将扫描的结果放入第二个参数的字符串指针所指向的地址中。我们使用 && 对不同的扫描方法进行 “与” 操作。这种方式的好处是只有与 && 操作符左边的扫描成功时，&& 右边的扫描方法才会被调用。\n\n```\nNSMutableDictionary *result = [NSMutableDictionary dictionary];\nwhile (!scanner.isAtEnd) {\n    NSString *key = nil;\n    NSString *value = nil;\n    NSCharacterSet *letters = [NSCharacterSet letterCharacterSet];\n    BOOL didScan = [scanner scanCharactersFromSet:letters intoString:&key] &&\n                   [scanner scanString:@\"=\" intoString:NULL] &&\n                   [scanner scanString:@\"#\" intoString:NULL] &&\n                   [scanner scanCharactersFromSet:hexadecimalCharacterSet intoString:&value] &&\n                   value.length == 6;\n    result[key] = value;\n    [scanner scanCharactersFromSet:[NSCharacterSet newlineCharacterSet] \n                        intoString:NULL]; // 继续扫描下一行\n}\nreturn result;\n```\n\n接下来添加一个有错误处理的版本，我们可以在 didScan 该行后面开始写。如果扫描不成功，我们就返回 nil，并设置相应的 error 参数。在解析文本时，当输入字符串格式不正确时，这个时候应该怎么办呢？是让解析器崩溃，将错误值呈现给用户，还是尝试从错误中恢复，这值得我们仔细地思考清楚：\n\n```\n if (!didScan) {\n        NSString *message = [NSString stringWithFormat:@\"Couldn't parse: %u\", scanner.scanLocation];\n        NSDictionary *errorDetail = @{NSLocalizedDescriptionKey: message};\n        *error = [NSError errorWithDomain:MyErrorDomain code:FormatError userInfo:errorDetail];\n        return nil;\n    }\n```\n\nC 语言也提供了具有扫描器功能的函数,例如 sscanf（可以用 man sscanf 查看怎么使用）。它遵循和 printf 类似的语法，只不过操作是逆序的（它是解析一个字符串, 而不是生成一个）。\n\n# 解析器\n\n如果设计者希望像 (100,0,255) 这样来定义 RGB 颜色，该怎么办呢？我们必须让解析颜色的方法更智能一些。事实上，在完成后面的代码后，我们就已经会写一个基本的解析器了。\n\n首先，我们将添加一些方法到我们类中，并声明一个属性，类型为 NSScanner。第一个方法是 scanColor:，其作用是扫描十六进制的颜色值（例如 ff0000）或者 RGB 元组，例如(255,0,0)：\n\n```\n- (NSDictionary *)parse:(NSString *)string error:(NSError **)error\n{\n    self.scanner = [NSScanner scannerWithString:string];\n    self.scanner.charactersToBeSkipped = [NSCharacterSet whitespaceCharacterSet];\n\n    NSMutableDictionary *result = [NSMutableDictionary dictionary];\n    NSCharacterSet *letters = [NSCharacterSet letterCharacterSet]\n    while (!self.scanner.isAtEnd) {\n        NSString *key = nil;\n        UIColor *value = nil;\n        BOOL didScan = [self.scanner scanCharactersFromSet:letters intoString:&key] &&\n                       [self.scanner scanString:@\"=\" intoString:NULL] &&\n                       [self scanColor:&value];\n        result[key] = value;\n        [self.scanner scanCharactersFromSet:[NSCharacterSet newlineCharacterSet]\n                                 intoString:NULL]; // 继续扫描下一行\n    }\n}\n```\n\nscanColor: 这个方法非常简单。首先，它试图扫描一个十六进制的颜色值，如果失败，它会尝试扫描 RGB 元组：\n\n```\n- (BOOL)scanColor:(UIColor **)out\n{\n    return [self scanHexColorIntoColor:out] || [self scanTupleColorIntoColor:out];\n}\n```\n\n扫描一个十六进制颜色和之前是一样的。唯一的区别是我们将其封装在一个方法中, 并且使用的都是 NSScanner 的方法。它会返回一个 BOOL 值表示扫描成功，并将结果存储到一个指向 UIColor 对象的指针：\n\n```\n- (BOOL)scanHexColorIntoColor:(UIColor **)out\n{\n    NSCharacterSet *hexadecimalCharacterSet = \n       [NSCharacterSet characterSetWithCharactersInString:@\"0123456789abcdefABCDEF\"];\n    NSString *colorString = NULL;\n    if ([self.scanner scanString:@\"#\" intoString:NULL] &&\n        [self.scanner scanCharactersFromSet:hexadecimalCharacterSet \n                                 intoString:&colorString] &&\n        colorString.length == 6) {\n        *out = [UIColor colorWithHexString:colorString];\n        return YES;\n    }\n    return NO;\n}\n```\n\n扫描基于 RGB 元组的颜色值也非常相似。在扫描 @\"(\" 时，我们进行了与操作。在生产环境代码中，我们可能需要更多的错误检查，例如确保整数的范围 0-255：\n\n```\n- (BOOL)scanTupleColorIntoColor:(UIColor **)out\n{\n    NSInteger red, green, blue = 0;\n    BOOL didScan = [self.scanner scanString:@\"(\" intoString:NULL] &&\n                   [self.scanner scanInteger:&red] &&\n                   [self.scanner scanString:@\",\" intoString:NULL] &&\n                   [self.scanner scanInteger:&green] &&\n                   [self.scanner scanString:@\",\" intoString:NULL] &&\n                   [self.scanner scanInteger:&blue] &&\n                   [self.scanner scanString:@\")\" intoString:NULL];\n    if (didScan) {\n        *out = [UIColor colorWithRed:(CGFloat)red/255.\n                               green:(CGFloat)green/255.\n                                blue:(CGFloat)blue/255. \n                               alpha:1];\n        return YES;\n    } else {\n        return NO;\n    }\n}\n```\n\n写一个扫描器，就是在逻辑上将多个可变的扫描值混合起来，并调用其它的一些方法。解析器不仅是一个非常吸引人的主题，还是一个强大的工具。一旦你知道如何编写一个解析器，你就可以发明一些小语言，如定义样式表、解析约束、查询数据模型、描述业务逻辑，等等。关于这个话题 Fowler 写了一本非常有趣的书，名为[《领域特定语言》](https://martinfowler.com/books/dsl.html)。\n\n# 标记化（Tokenization）\n\n我们已经有一个非常简单的解析器，它可以从一个文件中的字符串中提取键值对，我们也可以使用这些字符串生成 UIColor 对象。但是还没有完。要是设计者想要定义更多的事情，怎么办？比如，假设我们有不同的文件，其中包含一些布局的约束，格式如下：\n\n```\nmyView.left = otherView.right * 2 + 10\nviewController.view.centerX + myConstant <= self.view.centerX\n```\n\n我们该如何解析这个呢？实践证明正则表达式并不是最好的方法。\n\n在我们进行解析之前，先把这个字符串进行标记化是一个不错的主意。标记化就是将一个字符串转换成一连串标记 (token)的过程。 例如，myConstant = 100 被标记化的结果可能会是 @[@\"myConstant\", @\"=\", @100]。在大多数程序语言中, 标记化就是删除空白符并将相关的字符解析成标记。在我们的语言中，标记可以是标识符（如 myConstant 或 centerX），操作符（如 .，+ 或 =）或数字（如 100）。在标记化之后，标记会继续被解析。\n\n为了实现标记化（有时也称为词法分析 lexing 或扫描 scanning），我们可以重用 NSScanner 类。首先，我们可以专注于解析只包含操作符的字符串：\n\n\n```\nNSScanner *scanner = [NSScanner scannerWithString:contents];\nNSMutableArray *tokens = [NSMutableArray array];\nwhile (![scanner isAtEnd]) {\n  for (NSString *operator in @[@\"=\", @\"+\", @\"*\", @\">=\", @\"<=\", @\".\"]) {\n      if ([scanner scanString:operator intoString:NULL]) {\n          [tokens addObject:operator];\n      }\n  }\n}\n```\n\n下一步是识别像 myConstant 和 viewController 这样的标识符。为了简单起见，标识符只包含字母（没有数字）。如下：\n\n```\nNSString *result = nil;\nif ([scanner scanCharactersFromSet:[NSCharacterSet letterCharacterSet] \n                        intoString:&result]) {\n    [tokens addObject:result];\n}\n```\n\n如果这些字符被找到，scanCharactersFromSet:intoString: 这个方法会返回 YES，然后我们将这些找到的字符添加到我们的标记数组。我们快要完成了，唯一剩下的事情就是是解析数字了。幸运的是，NSScanner 也提供了一些方法。我们可以使用 scanDouble: 方法来扫描 double 类型数据，并将其封装成 NSNumber 对象然后添加到标记数组：\n\n```\ndouble doubleResult = 0;\nif ([scanner scanDouble:&doubleResult]) {\n    [tokens addObject:@(doubleResult)];\n}\n```\n\n现在我们的解析器完成了，下面我们来进行测试：\n\n```\nNSString* example = @\"myConstant = 100\\n\"\n                    @\"\\nmyView.left = otherView.right * 2 + 10\\n\"\n                    @\"viewController.view.centerX + myConstant <= self.view.centerX\";\nNSArray *result = [self.scanner tokenize:example];\nNSArray *expected = @[@\"myConstant\", @\"=\", @100, @\"myView\", @\".\", @\"left\", \n                      @\"=\", @\"otherView\", @\".\", @\"right\", @\"*\", @2, @\"+\", \n                      @10, @\"viewController\", @\".\", @\"view\", @\".\", \n                      @\"centerX\", @\"+\", @\"myConstant\", @\"<=\", @\"self\", \n                      @\".\", @\"view\", @\".\", @\"centerX\"];\nXCTAssertEqualObjects(result, expected);\n```\n\n我们的扫描器可以对操作符，姓名，以及被封装成 NSNumber 对象的数字创建独立的标记。完成这些之后,我们准备进行第二步：把这个标记数组解析成更有意义的一些东西。\n\n## 语法解析（Parsing）\n\n我们之所以不能用正则表达式或扫描器来解决上述问题，是因为解析有可能失败。假定我们现在有一个标记：@“myConstant”。在我们的解析函数中，我们并不知道这是约束表达式的开始还是一个常数定义。我们需要两个都试一下，看看哪一个成功。我们可以手工来写这个解析代码，难倒是不难，但是写出来的代码就像一坨屎；或者我们可以使用更合适的工具：**语法解析库（parsing library）**。\n\n首先，我们需要语法分析库能理解的方式来描述我们的语言。下面的代码就是专为我们那个布局约束语言写的解析语法，使用的是**扩展的巴科斯范式**（EBNF）写法：\n\n```\nconstraint = expression comparator expression\ncomparator = \"=\" | \">=\" | \"<=\"\nexpression = keyPath \".\" attribute addMultiplier addConstant\nkeyPath = identifier | identifier \".\" keyPath\nattribute = \"left\" | \"right\" | \"top\" | \"bottom\" | \"leading\" | \"trailing\" | \"width\" | \"height\" | \"centerX\" | \"centerY\" | \"baseline\"\naddMultiplier = \"*\" atom\naddConstant = \"+\" atom\natom = number | identifier\n```\n\n有许多的 Objective-C 库用于语法解析（参见 CocoaPods）。像 CoreParse 就提供了很多 Objective-C 的 API。然而，我们并不能直接将我们的语法应用在它上面。CoreParse 一次仅仅只有一个解析器工作。这意味着每当解析器需要在两个规则之间做决定（比如 keyPath 规则）的时候，它会根据下一个标记来做决定。如果事后我们发现它选错了，那麻烦就大了。当然有的解析器允许更模糊的语法，但性能损失很大。\n\n为了确保能够兼容语法分析库，可以对我们的语法做一些重构。 我们也可以将它转换成标准的巴科斯范式（BNF），下面的代码就是 CoreParse 支持的格式：\n\n```\nNSString* grammarString = [@[\n    @\"Atom ::= num@'Number' | ident@'Identifier';\",\n    @\"Constant ::= name@'Identifier' '=' value@<Atom>;\",\n    @\"Relation ::= '=' | '>=' | '<=';\",\n    @\"Attribute ::= 'left' | 'right' | 'top' | 'bottom' | 'leading' | 'trailing' | 'width' | 'height' | 'centerX' | 'centerY' | 'baseline';\",\n    @\"Multiplier ::= '*' num@'Number';\",\n    @\"AddConstant ::= '+' num@'Number';\",\n    @\"KeypathAndAttribute ::= 'Identifier' '.' <AttributeOrRest>;\",\n    @\"AttributeOrRest ::= att@<Attribute> | 'Identifier' '.' <AttributeOrRest>;\",\n    @\"Expression ::= <KeypathAndAttribute> <Multiplier>? <AddConstant>?;\",\n    @\"LayoutConstraint ::= lhs@<Expression> rel@<Relation> rhs@<Expression>;\",\n    @\"Rule ::= <Atom> | <LayoutConstraint>;\",\n] componentsJoinedByString:@\"\\n\"];\n```\n\n如果一个规则被匹配了，那么这个解析器就试图找到具有同样名称的类（如 Expression）。如果这个类实现了 initWithSyntaxTree: 方法，那么该方法就会被调用。另外，解析器还有一个委托，当有一个规则被匹配上或者发生错误时，委托都会被调用。举例来说，我们先来看一下 CPSyntaxTree 类，它的第一个子节点是一个关键字标记（调用 keyword 方法获取），它可能包含 @\"=\"，@\">=\" 或者 @\"<=\" 中的任意一个。属性 layoutAttributes 是一个字典，它的 key 是一个字符串，value 是一个关于布局的 NSNumber 对象：\n\n```\n- (id)parser:(CPParser *)parser didProduceSyntaxTree:(CPSyntaxTree *)syntaxTree\n    NSString *ruleName = syntaxTree.rule.name;\n    if ([ruleName isEqualToString:@\"Attribute\"]) {\n        return self.layoutAttributes[[[syntaxTree childAtIndex:0] keyword]];\n    }\n    ...\n```\n\n解析器的完整代码在 GitHub，其中有一个类，大约 100 行代码，我们可以用它解析复杂的布局约束，如:\n\n```\nviewController.view.centerX + 20 <= self.view.centerX * 0.5\n```\n\n我们会得到下面这样的结果，它可以很容易地转换成一个 NSLayoutConstraint 对象：\n\n```\n(<Expression: self.keyPath=(viewController, view), \n              self.attribute=9,\n              self.multiplier=1, \n              self.constant=20> \n -1 \n <Expression: self.keyPath=(self, view), \n              self.attribute=9,\n              self.multiplier=0.5,\n              self.constant=0>)\n```\n\n# 其他的工具\n\n除了 Objective-C 的库，其他的一些工具比如 Bison，Yacc，Ragel，以及 Lemon，都是用 C 语言实现的。\n\n另一件你可以做的事就是在 Build 时使用这些解析器生成一部分自己的代码。例如，一旦你有了一种语言的解析器，你就可以创建一个简单的命令行转换工具。添加一个 Xcode 的 Build 规则，每一次 Build 时，你自己的语言就会被一起编译。\n\n# 关于语法分析的思考\n\n语法分析看起来有一点奇怪，而且创建基于字符串的语言似乎并不是 Objective-C 的风格。但事实恰恰相反，苹果一直广泛使用着基于字符串的语言。如 NSLog 格式化字符串，NSPredicate 字符串，可视化的布局约束格式语言，甚至是 KVC。所有这些都用了一些小的内部解析器来解析字符串，并将其变成对象和方法。通常你不必自己编写一个解析器，这大大节省了工作时间：常见的语言如 JSON 和 XML 都有通用的解析器。但是如果你想要编写一个计算器，一种图形语言，甚至是一个嵌入式的 Smalltalk，解析器大有帮助。\n\n# 关于原文\n\n原英文地址：https://www.objc.io/issues/9-strings/string-parsing/\n原中文地址：https://objccn.io/issue-9-4/\n\n\n","categories":["iOS"]},{"title":"核心动画-隐式动画","url":"/2017/04/13/ios-core-animation/ios-core-animation-chapter-8/","content":"\n# 前言\n\n>如果想让事情变得顺利，只有靠自己 -- 夏尔·纪尧姆\n\n上一章介绍了隐式动画的概念。隐式动画是在iOS平台创建动态用户界面的一种直接方式，也是UIKit动画机制的基础，不过它并不能涵盖所有的动画类型。在这一章中，我们将要研究一下显式动画，它能够对一些属性做指定的自定义动画，或者创建非线性动画，比如沿着任意一条曲线移动。\n\n<!-- more -->\n\n# 属性动画\n\n# 动画组\n\n# 过度\n\n# 在动画过程中取消动画\n\n# 总结\n\n![图7.1 添加一个按钮来控制图层颜色](/images/ios-core-animation/7.1.jpeg)\n\n","tags":["核心动画"],"categories":["iOS"]},{"title":"核心动画-隐式动画","url":"/2017/04/13/ios-core-animation/ios-core-animation-chapter-7/","content":"\n\n# 前言\n\n>按照我的意思去做，而不是我说的。 -- 埃德娜，辛普森\n\n我们在第一部分讨论了Core Animation除了动画之外可以做到的任何事情。但是动画是Core Animation库一个非常显著的特性。这一章我们来看看它是怎么做到的。具体来说，我们先来讨论框架自动完成的隐式动画（除非你明确禁用了这个功能）。\n\n<!-- more -->\n\n# 事物\n\nCore Animation基于一个假设，说屏幕上的任何东西都可以（或者可能）做动画。动画并不需要你在Core Animation中手动打开，相反需要明确地关闭，否则他会一直存在。\n\n当你改变CALayer的一个可做动画的属性，它并不能立刻在屏幕上体现出来。相反，它是从先前的值平滑过渡到新的值。这一切都是默认的行为，你不需要做额外的操作。\n\n这看起来这太棒了，似乎不太真实，我们来用一个demo解释一下：首先和第一章“图层树”一样创建一个蓝色的方块，然后添加一个按钮，随机改变它的颜色。代码见清单7.1。点击按钮，你会发现图层的颜色平滑过渡到一个新值，而不是跳变（图7.1）。\n\n清单7.1 随机改变图层颜色\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *layerView;\n@property (nonatomic, weak) IBOutlet CALayer *colorLayer;/*热心人发现这里应该改为@property (nonatomic, strong)  CALayer *colorLayer;否则运行结果不正确。\n*/\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //create sublayer\n    self.colorLayer = [CALayer layer];\n    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);\n    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;\n    //add it to our view\n    [self.layerView.layer addSublayer:self.colorLayer];\n}\n\n- (IBAction)changeColor\n{\n    //randomize the layer background color\n    CGFloat red = arc4random() / (CGFloat)INT_MAX;\n    CGFloat green = arc4random() / (CGFloat)INT_MAX;\n    CGFloat blue = arc4random() / (CGFloat)INT_MAX;\n    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;                                                                                       \n}\n\n@end\n```\n\n![图7.1 添加一个按钮来控制图层颜色](/images/ios-core-animation/7.1.jpeg)\n\n其实就是所谓的隐式动画。之所以叫隐式是因为我们并没有指定任何动画的类型。我们仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画。Core Animaiton同样支持显式动画，下章详细说明。\n\n但当你改变一个属性，Core Animation是如何判断动画类型和持续时间的呢？实际上动画执行的时间取决于当前事务的设置，动画类型取决于图层行为。\n\n事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。\n\n事务是通过CATransaction类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。\n\nCore Animation在每个run loop周期中自动开始一次新的事务（run loop是iOS负责收集用户输入，处理定时器或者网络事件并且重新绘制屏幕的东西），即使你不显式的用[CATransaction begin]开始一次事务，任何在一次run loop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。\n\n明白这些之后，我们就可以轻松修改变色动画的时间了。我们当然可以用当前事务的+setAnimationDuration:方法来修改动画时间，但在这里我们首先起一个新的事务，于是修改时间就不会有别的副作用。因为修改当前事务的时间可能会导致同一时刻别的动画（如屏幕旋转），所以最好还是在调整动画之前压入一个新的事务。\n\n修改后的代码见清单7.2。运行程序，你会发现色块颜色比之前变得更慢了。\n\n清单7.2 使用CATransaction控制动画时间\n\n```\n- (IBAction)changeColor\n{\n    //begin a new transaction\n    [CATransaction begin];\n    //set the animation duration to 1 second\n    [CATransaction setAnimationDuration:1.0];\n    //randomize the layer background color\n    CGFloat red = arc4random() / (CGFloat)INT_MAX;\n    CGFloat green = arc4random() / (CGFloat)INT_MAX;\n    CGFloat blue = arc4random() / (CGFloat)INT_MAX;\n    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;\n    //commit the transaction\n    [CATransaction commit];\n}\n```\n\n如果你用过UIView的动画方法做过一些动画效果，那么应该对这个模式不陌生。UIView有两个方法，+beginAnimations:context:和+commitAnimations，和CATransaction的+begin和+commit方法类似。实际上在+beginAnimations:context:和+commitAnimations之间所有视图或者图层属性的改变而做的动画都是由于设置了CATransaction的原因。\n\n在iOS4中，苹果对UIView添加了一种基于block的动画方法：+animateWithDuration:animations:。这样写对做一堆的属性动画在语法上会更加简单，但实质上它们都是在做同样的事情。\n\nCATransaction的+begin和+commit方法在+animateWithDuration:animations:内部自动调用，这样block中所有属性的改变都会被事务所包含。这样也可以避免开发者由于对+begin和+commit匹配的失误造成的风险。\n\n# 完成块\n\n基于UIView的block的动画允许你在动画结束的时候提供一个完成的动作。CATranscation接口提供的+setCompletionBlock:方法也有同样的功能。我们来调整上个例子，在颜色变化结束之后执行一些操作。我们来添加一个完成之后的block，用来在每次颜色变化结束之后切换到另一个旋转90的动画。代码见清单7.3，运行结果见图7.2。\n\n清单7.3 在颜色动画完成之后添加一个回调\n\n```\n- (IBAction)changeColor\n{\n    //begin a new transaction\n    [CATransaction begin];\n    //set the animation duration to 1 second\n    [CATransaction setAnimationDuration:1.0];\n    //add the spin animation on completion\n    [CATransaction setCompletionBlock:^{\n        //rotate the layer 90 degrees\n        CGAffineTransform transform = self.colorLayer.affineTransform;\n        transform = CGAffineTransformRotate(transform, M_PI_2);\n        self.colorLayer.affineTransform = transform;\n    }];\n    //randomize the layer background color\n    CGFloat red = arc4random() / (CGFloat)INT_MAX;\n    CGFloat green = arc4random() / (CGFloat)INT_MAX;\n    CGFloat blue = arc4random() / (CGFloat)INT_MAX;\n    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;\n    //commit the transaction\n    [CATransaction commit];\n}\n```\n\n![图7.2 颜色渐变之完成之后再做一次旋转](/images/ios-core-animation/7.2.jpeg)\n\n注意旋转动画要比颜色渐变快得多，这是因为完成块是在颜色渐变的事务提交并出栈之后才被执行，于是，用默认的事务做变换，默认的时间也就变成了0.25秒。\n\n# 图层行为\n\n现在来做个实验，试着直接对UIView关联的图层做动画而不是一个单独的图层。清单7.4是对清单7.2代码的一点修改，移除了colorLayer，并且直接设置layerView关联图层的背景色。\n\n清单7.4 直接设置图层的属性\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *layerView;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //set the color of our layerView backing layer directly\n    self.layerView.layer.backgroundColor = [UIColor blueColor].CGColor;\n}\n\n- (IBAction)changeColor\n{\n    //begin a new transaction\n    [CATransaction begin];\n    //set the animation duration to 1 second\n    [CATransaction setAnimationDuration:1.0];\n    //randomize the layer background color\n    CGFloat red = arc4random() / (CGFloat)INT_MAX;\n    CGFloat green = arc4random() / (CGFloat)INT_MAX;\n    CGFloat blue = arc4random() / (CGFloat)INT_MAX;\n    self.layerView.layer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;\n    //commit the transaction\n    [CATransaction commit];\n}\n```\n\n运行程序，你会发现当按下按钮，图层颜色瞬间切换到新的值，而不是之前平滑过渡的动画。发生了什么呢？隐式动画好像被UIView关联图层给禁用了。\n\n试想一下，如果UIView的属性都有动画特性的话，那么无论在什么时候修改它，我们都应该能注意到的。所以，如果说UIKit建立在Core Animation（默认对所有东西都做动画）之上，那么隐式动画是如何被UIKit禁用掉呢？\n\n我们知道Core Animation通常对CALayer的所有属性（可动画的属性）做动画，但是UIView把它关联的图层的这个特性关闭了。为了更好说明这一点，我们需要知道隐式动画是如何实现的。\n\n我们把改变属性时CALayer自动应用的动画称作行为，当CALayer的属性被修改时候，它会调用-actionForKey:方法，传递属性的名称。剩下的操作都在CALayer的头文件中有详细的说明，实质上是如下几步：\n\n* 图层首先检测它是否有委托，并且是否实现CALayerDelegate协议指定的-actionForLayer:forKey方法。如果有，直接调用并返回结果。\n* 如果没有委托，或者委托没有实现-actionForLayer:forKey方法，图层接着检查包含属性名称对应行为映射的actions字典。\n* 如果actions字典没有包含对应的属性，那么图层接着在它的style字典接着搜索属性名。\n* 最后，如果在style里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的-defaultActionForKey:方法。\n\n所以一轮完整的搜索结束之后，-actionForKey:要么返回空（这种情况下将不会有动画发生），要么是CAAction协议对应的对象，最后CALayer拿这个结果去对先前和当前的值做动画。\n\n于是这就解释了UIKit是如何禁用隐式动画的：每个UIView对它关联的图层都扮演了一个委托，并且提供了-actionForLayer:forKey的实现方法。当不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动画block范围之内，它就返回了一个非空值。我们可以用一个demo做个简单的实验（清单7.5）\n\n清单7.5 测试UIView的actionForLayer:forKey:实现\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *layerView;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //test layer action when outside of animation block\n    NSLog(@\"Outside: %@\", [self.layerView actionForLayer:self.layerView.layer forKey:@\"backgroundColor\"]);\n    //begin animation block\n    [UIView beginAnimations:nil context:nil];\n    //test layer action when inside of animation block\n    NSLog(@\"Inside: %@\", [self.layerView actionForLayer:self.layerView.layer forKey:@\"backgroundColor\"]);\n    //end animation block\n    [UIView commitAnimations];\n}\n\n@end\n```\n\n运行程序，控制台显示结果如下：\n\n```\n$ LayerTest[21215:c07] Outside: <null>\n$ LayerTest[21215:c07] Inside: <CABasicAnimation: 0x757f090>\n```\n\n于是我们可以预言，当属性在动画块之外发生改变，UIView直接通过返回nil来禁用隐式动画。但如果在动画块范围之内，根据动画具体类型返回相应的属性，在这个例子就是CABasicAnimation（第八章“显式动画”将会提到）。\n\n当然返回nil并不是禁用隐式动画唯一的办法，CATransacition有个方法叫做+setDisableActions:，可以用来对所有属性打开或者关闭隐式动画。如果在清单7.2的[CATransaction begin]之后添加下面的代码，同样也会阻止动画的发生：\n\n```\n[CATransaction setDisableActions:YES];\n```\n\n总结一下，我们知道了如下几点\n\n* UIView关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用UIView的动画函数（而不是依赖CATransaction），或者继承UIView，并覆盖-actionForLayer:forKey:方法，或者直接创建一个显式动画（具体细节见第八章）。\n* 对于单独存在的图层，我们可以通过实现图层的-actionForLayer:forKey:委托方法，或者提供一个actions字典来控制隐式动画。\n\n我们来对颜色渐变的例子使用一个不同的行为，通过给colorLayer设置一个自定义的actions字典。我们也可以使用委托来实现，但是actions字典可以写更少的代码。那么到底改如何创建一个合适的行为对象呢？\n\n行为通常是一个被Core Animation隐式调用的显式动画对象。这里我们使用的是一个实现了CATransaction的实例，叫做推进过渡。\n\n第八章中将会详细解释过渡，不过对于现在，知道CATransition响应CAAction协议，并且可以当做一个图层行为就足够了。结果很赞，不论在什么时候改变背景颜色，新的色块都是从左侧滑入，而不是默认的渐变效果。\n\n清单7.6 实现自定义行为\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *layerView;\n@property (nonatomic, weak) IBOutlet CALayer *colorLayer;/*热心人发现这里应该改为@property (nonatomic, strong)  CALayer *colorLayer;否则运行结果不正确。\n*/\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n\n    //create sublayer\n    self.colorLayer = [CALayer layer];\n    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);\n    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;\n    //add a custom action\n    CATransition *transition = [CATransition animation];\n    transition.type = kCATransitionPush;\n    transition.subtype = kCATransitionFromLeft;\n    self.colorLayer.actions = @{@\"backgroundColor\": transition};\n    //add it to our view\n    [self.layerView.layer addSublayer:self.colorLayer];\n}\n\n- (IBAction)changeColor\n{\n    //randomize the layer background color\n    CGFloat red = arc4random() / (CGFloat)INT_MAX;\n    CGFloat green = arc4random() / (CGFloat)INT_MAX;\n    CGFloat blue = arc4random() / (CGFloat)INT_MAX;\n    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;\n}\n\n@end\n```\n\n![图7.3 使用推进过渡的色值动画](/images/ios-core-animation/7.3.jpeg)\n\n# 呈现与模型\n\nCALayer的属性行为其实很不正常，因为改变一个图层的属性并没有立刻生效，而是通过一段时间渐变更新。这是怎么做到的呢？\n\n当你改变一个图层的属性，属性值的确是立刻更新的（如果你读取它的数据，你会发现它的值在你设置它的那一刻就已经生效了），但是屏幕上并没有马上发生改变。这是因为你设置的属性并没有直接调整图层的外观，相反，他只是定义了图层动画结束之后将要变化的外观。\n\n当设置CALayer的属性，实际上是在定义当前事务结束之后图层如何显示的模型。Core Animation扮演了一个控制器的角色，并且负责根据图层行为和事务设置去不断更新视图的这些属性在屏幕上的状态。\n\n我们讨论的就是一个典型的微型MVC模式。CALayer是一个连接用户界面（就是MVC中的view）虚构的类，但是在界面本身这个场景下，CALayer的行为更像是存储了视图如何显示和动画的数据模型。实际上，在苹果自己的文档中，图层树通常都是值的图层树模型。\n\n在iOS中，屏幕每秒钟重绘60次。如果动画时长比60分之一秒要长，Core Animation就需要在设置一次新值和新值生效之间，对屏幕上的图层进行重新组织。这意味着CALayer除了“真实”值（就是你设置的值）之外，必须要知道当前显示在屏幕上的属性值的记录。\n\n每个图层属性的显示值都被存储在一个叫做呈现图层的独立图层当中，他可以通过-presentationLayer方法来访问。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以通过呈现图层的值来获取当前屏幕上真正显示出来的值（图7.4）。\n\n我们在第一章中提到除了图层树，另外还有呈现树。呈现树通过图层树中所有图层的呈现图层所形成。注意呈现图层仅仅当图层首次被提交（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用-presentationLayer将会返回nil。\n\n你可能注意到有一个叫做–modelLayer的方法。在呈现图层上调用–modelLayer将会返回它正在呈现所依赖的CALayer。通常在一个图层上调用-modelLayer会返回–self（实际上我们已经创建的原始图层就是一种数据模型）。\n\n![图7.4 一个移动的图层是如何通过数据模型呈现的](/images/ios-core-animation/7.4.jpeg)\n\n大多数情况下，你不需要直接访问呈现图层，你可以通过和模型图层的交互，来让Core Animation更新显示。两种情况下呈现图层会变得很有用，一个是同步动画，一个是处理用户交互。\n\n* 如果你在实现一个基于定时器的动画（见第11章“基于定时器的动画”），而不仅仅是基于事务的动画，这个时候准确地知道在某一时刻图层显示在什么位置就会对正确摆放图层很有用了。\n* 如果你想让你做动画的图层响应用户输入，你可以使用-hitTest:方法（见第三章“图层几何学”）来判断指定图层是否被触摸，这时候对呈现图层而不是模型图层调用-hitTest:会显得更有意义，因为呈现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置。\n\n我们可以用一个简单的案例来证明后者（见清单7.7）。在这个例子中，点击屏幕上的任意位置将会让图层平移到那里。点击图层本身可以随机改变它的颜色。我们通过对呈现图层调用-hitTest:来判断是否被点击。\n\n如果修改代码让-hitTest:直接作用于colorLayer而不是呈现图层，你会发现当图层移动的时候它并不能正确显示。这时候你就需要点击图层将要移动到的位置而不是图层本身来响应点击（这就是为什么用呈现图层来响应交互的原因）。\n\n清单7.7 使用presentationLayer图层来判断当前图层位置\n\n```\n@interface ViewController ()\n\n@property (nonatomic, strong) CALayer *colorLayer;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //create a red layer\n    self.colorLayer = [CALayer layer];\n    self.colorLayer.frame = CGRectMake(0, 0, 100, 100);\n    self.colorLayer.position = CGPointMake(self.view.bounds.size.width / 2, self.view.bounds.size.height / 2);\n    self.colorLayer.backgroundColor = [UIColor redColor].CGColor;\n    [self.view.layer addSublayer:self.colorLayer];\n}\n\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //get the touch point\n    CGPoint point = [[touches anyObject] locationInView:self.view];\n    //check if we've tapped the moving layer\n    if ([self.colorLayer.presentationLayer hitTest:point]) {\n        //randomize the layer background color\n        CGFloat red = arc4random() / (CGFloat)INT_MAX;\n        CGFloat green = arc4random() / (CGFloat)INT_MAX;\n        CGFloat blue = arc4random() / (CGFloat)INT_MAX;\n        self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;\n    } else {\n        //otherwise (slowly) move the layer to new position\n        [CATransaction begin];\n        [CATransaction setAnimationDuration:4.0];\n        self.colorLayer.position = point;\n        [CATransaction commit];\n    }\n}\n```\n\n# 总结\n\n这一章讨论了隐式动画，还有Core Animation对指定属性选择合适的动画行为的机制。同时你知道了UIKit是如何充分利用Core Animation的隐式动画机制来强化它的显式系统，以及动画是如何被默认禁用并且当需要的时候启用的。最后，你了解了呈现和模型图层，以及Core Animation是如何通过它们来判断出图层当前位置以及将要到达的位置。\n\n在下一章中，我们将研究Core Animation提供的显式动画类型，既可以直接对图层属性做动画，也可以覆盖默认的图层行为。\n\n\n","tags":["核心动画"],"categories":["iOS"]},{"title":"Mac终端设置","url":"/2017/04/13/computer-setting/command-line-prefix-setting/","content":"\n# 命令行前缀\n\n喜欢用命令行的人估计都遇到过这样的问题，每一个行命令前面都会有很长一个前缀：包含了计算机名和目录名，就像下图的样子。\n\n<!-- more -->\n\n![](/images/computer-setting/command-prefix-1.png)\n\n这一长串前缀看着实在碍眼，能否去掉呢？当然可以，下面就来去掉它。\n\n可以使用命令，编辑/etc/bashrc文件\n\n```\nsudo vim /etc/bashrc\n```\n\n![](/images/computer-setting/command-prefix-2.png)\n\n打开文件后，会看到`PS1='\\h:\\W \\u\\$ '`这一行，我们就在这行上面下手。\n\n1. 注释掉`PS1=’\\h:\\W \\u\\$ ‘`, 做备份\n2. 替换为`PS1=’\\W \\$’`\n\n执行强制退出的命令`wq!`,即可保存退出。\n\n至此已经修改好了，重新打开Terminal，可以看到效果\n\n![](/images/computer-setting/command-prefix-3.png)\n\n","tags":["终端"],"categories":["基础设置"]},{"title":"设计模式-工厂方法模式","url":"/2017/04/10/design-pattern/design-pattern-factory-method/","content":"\n简单工厂模式虽然简单，但存在一个很严重的问题。当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？工厂方法模式应运而生，本文将介绍第二种工厂模式——工厂方法模式。\n\n<!-- more -->\n\n# 日志记录器的设计\n\nSunny 软件公司欲开发一个系统运行日志记录器（Logger），该记录器可以通过多种途径保存系统的运行日志，如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，Sunny 公司的开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。如何封装记录器的初始化过程并保证多种记录器切换的灵活性是 Sunny 公司开发人员面临的一个难题。 \n\nSunny 公司的开发人员通过对该需求进行分析，发现该日志记录器有两个设计要点： \n\n1. 需要封装日志记录器的初始化过程，这些初始化工作较为复杂，例如需要初始化其他相关的类，还有可能需要读取配置文件（例如连接数据库或创建文件），导致代码较长，如果将它们都写在构造函数中，会导致构造函数庞大，不利于代码的修改和维护；\n\n2. 用户可能需要更换日志记录方式，在客户端代码中需要提供一种灵活的方式来选择日志记录器，尽量在不修改源代码的基础上更换或者增加日志记录方式。 \n\nSunny 公司开发人员最初使用简单工厂模式对日志记录器进行了设计，初始结构如图所示： \n\n![](/images/design-pattern/factory-method-1.jpeg)\n\n在图中，LoggerFactory 充当创建日志记录器的工厂，提供了工厂方法 createLogger() 用于创建日志记录器，Logger 是抽象日志记录器接口，其子类为具体日志记录器。其中，工厂类 LoggerFactory 代码片段如下所示：\n\n```\n//日志记录器工厂\nclass LoggerFactory {\n    //静态工厂方法\n    public static Logger createLogger(String args) {\n        if(args.equalsIgnoreCase(\"db\")) {\n            //连接数据库，代码省略\n            //创建数据库日志记录器对象\n            Logger logger = new DatabaseLogger(); \n            //初始化数据库日志记录器，代码省略\n            return logger;\n        }\n        else if(args.equalsIgnoreCase(\"file\")) {\n            //创建日志文件\n            //创建文件日志记录器对象\n            Logger logger = new FileLogger(); \n            //初始化文件日志记录器，代码省略\n            return logger;          \n        }\n        else {\n            return null;\n        }\n    }\n}\n```\n\n为了突出设计重点，我们对上述代码进行了简化，省略了具体日志记录器类的初始化代码。在 LoggerFactory 类中提供了静态工厂方法 createLogger()，用于根据所传入的参数创建各种不同类型的日志记录器。通过使用简单工厂模式，我们将日志记录器对象的创建和使用分离，客户端只需使用由工厂类创建的日志记录器对象即可，无须关心对象的创建过程，但是我们发现，虽然简单工厂模式实现了对象的创建和使用分离，但是仍然存在如下两个问题： \n\n1. 工厂类过于庞大，包含了大量的 if…else… 代码，导致维护和测试难度增大；\n\n2. 系统扩展不灵活，如果增加新类型的日志记录器，必须修改静态工厂方法的业务逻辑，违反了“开闭原则”。\n\n如何解决这两个问题，提供一种简单工厂模式的改进方案？这就是本文所介绍的工厂方法模式的动机之一。\n\n# 工厂方法模式概述\n\n在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则”。此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。 \n\n在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。工厂方法模式定义如下： \n\n工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。 \n\n工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。工厂方法模式结构如图所示： \n\n![](/images/design-pattern/factory-method-2.jpeg)\n\n在工厂方法模式结构图中包含如下几个角色： \n\n* Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。\n* ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。 \n* Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。 \n* ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 \n\n与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：\n\n```\ninterface Factory {  \n    public Product factoryMethod();  \n}  \n```\n\n在抽象工厂中声明了工厂方法但并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时再指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品，其典型代码如下所示： \n\n```\nclass ConcreteFactory implements Factory {  \n    public Product factoryMethod() {  \n        return new ConcreteProduct();  \n    }  \n}  \n```\n\n在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。\n\n在客户端代码中，只需关心工厂类即可，不同的具体工厂可以创建不同的产品，典型的客户端类代码片段如下所示： \n\n```\nFactory factory;  \nfactory = new ConcreteFactory(); //可通过配置文件实现  \nProduct product;  \nproduct = factory.factoryMethod();  \n```\n\n可以通过配置文件来存储具体工厂类 ConcreteFactory 的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。 \n\n>思考：工厂方法模式中的工厂方法能否为静态方法？为什么？\n\n# 完整解决方案\n\nSunny 公司开发人员决定使用工厂方法模式来设计日志记录器，其基本结构如图所示：\n\n![](/images/design-pattern/factory-method-3.jpeg)\n\n在图中，Logger 接口充当抽象产品，其子类 FileLogger 和 DatabaseLogger 充当具体产品，LoggerFactory 接口充当抽象工厂，其子类 FileLoggerFactory 和 DatabaseLoggerFactory 充当具体工厂。完整代码如下所示：\n\n```\n//日志记录器接口：抽象产品\ninterface Logger {\n    public void writeLog();\n}\n\n//数据库日志记录器：具体产品\nclass DatabaseLogger implements Logger {\n    public void writeLog() {\n        System.out.println(\"数据库日志记录。\");\n    }\n}\n\n//文件日志记录器：具体产品\nclass FileLogger implements Logger {\n    public void writeLog() {\n        System.out.println(\"文件日志记录。\");\n    }\n}\n\n//日志记录器工厂接口：抽象工厂\ninterface LoggerFactory {\n    public Logger createLogger();\n}\n\n//数据库日志记录器工厂类：具体工厂\nclass DatabaseLoggerFactory implements LoggerFactory {\n    public Logger createLogger() {\n            //连接数据库，代码省略\n            //创建数据库日志记录器对象\n            Logger logger = new DatabaseLogger(); \n            //初始化数据库日志记录器，代码省略\n            return logger;\n    }   \n}\n\n//文件日志记录器工厂类：具体工厂\nclass FileLoggerFactory implements LoggerFactory {\n    public Logger createLogger() {\n            //创建文件日志记录器对象\n            Logger logger = new FileLogger(); \n            //创建文件，代码省略\n            return logger;\n    }   \n}\n```\n\n编写如下客户端测试代码：\n\n```\nclass Client {\n    public static void main(String args[]) {\n        LoggerFactory factory;\n        Logger logger;\n        factory = new FileLoggerFactory(); //可引入配置文件实现\n        logger = factory.createLogger();\n        logger.writeLog();\n    }\n}\n```\n\n编译并运行程序，输出结果如下： \n\n```\n文件日志记录。\n```\n\n## 反射与配置文件\n\n为了让系统具有更好的灵活性和可扩展性，Sunny 公司开发人员决定对日志记录器客户端代码进行重构，使得可以在不修改任何客户端代码的基础上更换或增加新的日志记录方式。 \n\n在客户端代码中将不再使用 new 关键字来创建工厂对象，而是将具体工厂类的类名存储在配置文件（如 XML 文件）中，通过读取配置文件获取类名字符串，再使用Java的反射机制，根据类名字符串生成对象。在整个实现过程中需要用到两个技术：Java 反射机制与配置文件读取。软件系统的配置文件通常为XML文件，我们可以使用 DOM (Document Object Model)、SAX (Simple API for XML)、StAX (Streaming API for XML)等技术来处理 XML文件。关于 DOM、SAX、StAX 等技术的详细学习大家可以参考其他相关资料，在此不予扩展。 \n\n## 扩展\n\n关于 Java 与 XML 的相关资料，大家可以阅读 Tom Myers 和 Alexander Nakhimovsky所著的《Java XML编程指南》一书或访问 developer Works 中国中的“Java XML 技术专题”。\n\nJava 反射（Java Reflection）是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。在反射中使用最多的类是 Class，Class 类的实例表示正在运行的 Java 应用程序中的类和接口，其 forName(String className)方法可以返回与带有给定字符串名的类或接口相关联的 Class对象，再通过 Class 对象的 newInstance() 方法创建此对象所表示的类的一个新实例，即通过一个类名字符串得到类的实例。如创建一个字符串类型的对象，其代码如下： \n\n```\n  //通过类名生成实例对象并将其返回\n   Class c=Class.forName(\"String\");\n   Object obj=c.newInstance();\n   return obj;\n```\n\n此外，在 JDK 中还提供了 java.lang.reflect 包，封装了其他与反射相关的类，此处只用到上述简单的反射代码，在此不予扩展。\n\nSunny 公司开发人员创建了如下XML格式的配置文件 config.xml 用于存储具体日志记录器工厂类类名： \n\n```\n<!— config.xml -->\n<?xml version=\"1.0\"?>\n<config>\n    <className>FileLoggerFactory</className>\n</config>\n```\n\n为了读取该配置文件并通过存储在其中的类名字符串反射生成对象，Sunny 公司开发人员开发了一个名为 XMLUtil 的工具类，其详细代码如下所示： \n\n```\n//工具类XMLUtil.java\nimport javax.xml.parsers.*;\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\nimport java.io.*;\n\npublic class XMLUtil {\n//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象\n    public static Object getBean() {\n        try {\n            //创建DOM文档对象\n            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = dFactory.newDocumentBuilder();\n            Document doc;                           \n            doc = builder.parse(new File(\"config.xml\")); \n\n            //获取包含类名的文本节点\n            NodeList nl = doc.getElementsByTagName(\"className\");\n            Node classNode=nl.item(0).getFirstChild();\n            String cName=classNode.getNodeValue();\n\n            //通过类名生成实例对象并将其返回\n            Class c=Class.forName(cName);\n            Object obj=c.newInstance();\n            return obj;\n        }   \n        catch(Exception e) {\n            e.printStackTrace();\n            return null;\n         }\n    }\n}\n```\n\n有了 XMLUtil 类后，可以对日志记录器的客户端代码进行修改，不再直接使用 new 关键字来创建具体的工厂类，而是将具体工厂类的类名存储在 XML 文件中，再通过 XMLUtil 类的静态工厂方法 getBean() 方法进行对象的实例化，代码修改如下： \n\n```\nclass Client {\n    public static void main(String args[]) {\n        LoggerFactory factory;\n        Logger logger;\n        factory = (LoggerFactory)XMLUtil.getBean(); //getBean()的返回类型为Object，需要进行强制类型转换\n        logger = factory.createLogger();\n        logger.writeLog();\n    }\n}\n```\n\n引入 XMLUtil 类和 XML 配置文件后，如果要增加新的日志记录方式，只需要执行如下几个步骤：\n\n1. 新的日志记录器需要继承抽象日志记录器 Logger；\n\n2. 对应增加一个新的具体日志记录器工厂，继承抽象日志记录器工厂 LoggerFactory，并实现其中的工厂方法 createLogger()，设置好初始化参数和环境变量，返回具体日志记录器对象；\n\n3. 修改配置文件 config.xml，将新增的具体日志记录器工厂类的类名字符串替换原有工厂类类名字符串；\n\n4. 编译新增的具体日志记录器类和具体日志记录器工厂类，运行客户端测试类即可使用新的日志记录方式，而原有类库代码无须做任何修改，完全符合“开闭原则”。\n\n通过上述重构可以使得系统更加灵活，由于很多设计模式都关注系统的可扩展性和灵活性，因此都定义了抽象层，在抽象层中声明业务方法，而将业务方法的实现放在实现层中。 \n\n## 思考\n\n有人说：可以在客户端代码中直接通过反射机制来生成产品对象，在定义产品对象时使用抽象类型，同样可以确保系统的灵活性和可扩展性，增加新的具体产品类无须修改源代码，只需要将其作为抽象产品类的子类再修改配置文件即可，根本不需要抽象工厂类和具体工厂类。\n\n试思考这种做法的可行性？如果可行，这种做法是否存在问题？为什么？\n\n# 重载的工厂方法\n\nSunny 公司开发人员通过进一步分析，发现可以通过多种方式来初始化日志记录器，例如可以为各种日志记录器提供默认实现；还可以为数据库日志记录器提供数据库连接字符串，为文件日志记录器提供文件路径；也可以将参数封装在一个 Object 类型的对象中，通过 Object 对象将配置参数传入工厂类。此时，可以提供一组重载的工厂方法，以不同的方式对产品对象进行创建。当然，对于同一个具体工厂而言，无论使用哪个工厂方法，创建的产品类型均要相同。如图4所示： \n\n![](/images/design-pattern/factory-method-4.jpeg)\n\n引入重载方法后，抽象工厂 LoggerFactory 的代码修改如下： \n\n```\ninterface LoggerFactory {  \n    public Logger createLogger();  \n    public Logger createLogger(String args);  \n    public Logger createLogger(Object obj);  \n}  \n```\n\n具体工厂类 DatabaseLoggerFactory 代码修改如下： \n\n```\nclass DatabaseLoggerFactory implements LoggerFactory {\n    public Logger createLogger() {\n            //使用默认方式连接数据库，代码省略\n            Logger logger = new DatabaseLogger(); \n            //初始化数据库日志记录器，代码省略\n            return logger;\n    }\n\n    public Logger createLogger(String args) {\n            //使用参数args作为连接字符串来连接数据库，代码省略\n            Logger logger = new DatabaseLogger(); \n            //初始化数据库日志记录器，代码省略\n            return logger;\n    }   \n\n    public Logger createLogger(Object obj) {\n            //使用封装在参数obj中的连接字符串来连接数据库，代码省略\n            Logger logger = new DatabaseLogger(); \n            //使用封装在参数obj中的数据来初始化数据库日志记录器，代码省略\n            return logger;\n    }   \n}\n\n//其他具体工厂类代码省略\n```\n\n在抽象工厂中定义多个重载的工厂方法，在具体工厂中实现了这些工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同产品对象的需求。 \n\n# 工厂方法的隐藏\n\n有时候，为了进一步简化客户端的使用，还可以对客户端隐藏工厂方法，此时，在工厂类中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法。\n\n如果对客户端隐藏工厂方法，日志记录器的结构图将修改为图 5 所示：\n\n![](/images/design-pattern/factory-method-5.jpeg)\n\n在图中，抽象工厂类 LoggerFactory 的代码修改如下： \n\n```\n//改为抽象类\nabstract class LoggerFactory {\n    //在工厂类中直接调用日志记录器类的业务方法writeLog()\n    public void writeLog() {\n        Logger logger = this.createLogger();\n        logger.writeLog();\n    }\n\n    public abstract Logger createLogger();  \n}\n```\n\n通过将业务方法的调用移入工厂类，可以直接使用工厂对象来调用产品对象的业务方法，客户端无须直接使用工厂方法，在某些情况下我们也可以使用这种设计方案。 \n\n# 总结\n\n工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和 API 类库的核心模式。 \n\n## 主要优点\n\n1. 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。\n\n2. 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。\n\n3. 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 \n\n## 主要缺点\n\n1. 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。\n\n2. 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到 DOM、反射等技术，增加了系统的实现难度。 \n\n## 适用场景\n\n1. 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。\n\n2. 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 \n\n>练习:使用工厂方法模式设计一个程序来读取各种不同类型的图片格式，针对每一种图片格式都设计一个图片读取器，如 GIF 图片读取器用于读取 GIF 格式的图片、JPG 图片读取器用于读取 JPG 格式的图片。需充分考虑系统的灵活性和可扩展性。\n\n","categories":["设计模式"]},{"title":"设计模式-简单工厂模式","url":"/2017/04/10/design-pattern/design-pattern-simple-factory/","content":"\n工厂模式是最常用的一类创建型设计模式，通常我们所说的工厂模式是指工厂方法模式，它也是使用频率最高的工厂模式。本章将要学习的简单工厂模式是工厂方法模式的“小弟”，它不属于 GoF 23 种设计模式，但在软件开发中应用也较为频繁，通常将它作为学习其他工厂模式的入门。此外，工厂方法模式还有一位“大哥”——抽象工厂模式。这三种工厂模式各具特色，难度也逐个加大，在软件开发中它们都得到了广泛的应用，成为面向对象软件中常用的创建对象的工具。 \n\n<!-- more -->\n\n# 图表库的设计\n\nSunny 软件公司欲基于 Java 语言开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等。Sunny 软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。 \n\nSunny 软件公司图表库设计人员提出了一个初始设计方案，将所有图表的实现代码封装在一个 Chart 类中，其框架代码如下所示： \n\n```\nclass Chart {\n    private String type; //图表类型\n\n    public Chart(Object[][] data, String type) {\n        this.type = type;\n        if (type.equalsIgnoreCase(\"histogram\")) {\n            //初始化柱状图\n        }\n        else if (type.equalsIgnoreCase(\"pie\")) {\n            //初始化饼状图\n        }\n        else if (type.equalsIgnoreCase(\"line\")) {\n            //初始化折线图\n        }\n    }\n\n    public void display() {\n        if (this.type.equalsIgnoreCase(\"histogram\")) {\n            //显示柱状图\n        }\n        else if (this.type.equalsIgnoreCase(\"pie\")) {\n            //显示饼状图\n        }\n        else if (this.type.equalsIgnoreCase(\"line\")) {\n            //显示折线图\n        }   \n    }\n}\n```\n\n客户端代码通过调用 Chart 类的构造函数来创建图表对象，根据参数 type 的不同可以得到不同类型的图表，然后再调用 display() 方法来显示相应的图表。\n\n不难看出，Chart 类是一个“巨大的”类，在该类的设计中存在如下几个问题：\n\n1. 在 Chart 类中包含很多 if…else… 代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。\n\n2. Chart 类的职责过重，它负责初始化和显示所有的图表对象，将各种图表对象的初始化代码和显示代码集中在一个类中实现，违反了“单一职责原则”，不利于类的重用和维护；而且将大量的对象初始化代码都写在构造函数中将导致构造函数非常庞大，对象在创建时需要进行条件判断，降低了对象创建的效率。\n\n3. 当需要增加新类型的图表时，必须修改 Chart 类的源代码，违反了“开闭原则”。\n\n4. 客户端只能通过 new 关键字来直接创建 Chart 对象，Chart 类与客户端类耦合度较高，对象的创建和使用无法分离。\n\n5. 客户端在创建 Chart 对象之前可能还需要进行大量初始化设置，例如设置柱状图的颜色、高度等，如果在 Chart 类的构造函数中没有提供一个默认设置，那就只能由客户端来完成初始设置，这些代码在每次创建 Chart 对象时都会出现，导致代码的重复。\n\n面对一个如此巨大、职责如此重，且与客户端代码耦合度非常高的类，我们应该怎么办？本章将要介绍的简单工厂模式将在一定程度上解决上述问题。\n\n# 简单工厂概述\n\n简单工厂模式并不属于 GoF 23 个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下： \n\n首先将需要创建的各种不同对象（例如各种不同的 Chart 对象）的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。 \n\n简单工厂模式定义如下： \n\n>简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态（static）方法，因此简单工厂模式又被称为静态工厂方法（Static Factory Method）模式，它属于类创建型模式。 \n\n简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计，其结构如图所示：\n\n![](/images/design-pattern/simple-factory-1.jpeg)\n\n在简单工厂模式结构图中包含如下几个角色： \n\n* Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法 factoryMethod()，它的返回类型为抽象产品类型 Product。\n\n* Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。\n    \n* ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。\n\n在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用 new 关键字来创建对象，它是工厂模式家族中最简单的一员。 \n\n在使用简单工厂模式时，首先需要对产品类进行重构，**不能设计一个包罗万象的产品类，而需根据实际情况设计一个产品层次结构**，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：\n\n```\nabstract class Product {\n    //所有产品类的公共业务方法\n    public void methodSame() {\n        //公共方法的实现\n    }\n\n    //声明抽象业务方法\n    public abstract void methodDiff();\n}\n```\n\n在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示：\n\n```\nclass ConcreteProduct extends Product {\n    //实现业务方法\n    public void methodDiff() {\n        //业务方法的实现\n    }\n}\n```\n\n简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用 new 关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，典型的工厂类代码如下所示： \n\n```\nclass Factory {\n    //静态工厂方法\n    public static Product getProduct(String arg) {\n        Product product = null;\n        if (arg.equalsIgnoreCase(\"A\")) {\n            product = new ConcreteProductA();\n            //初始化设置product\n        }\n        else if (arg.equalsIgnoreCase(\"B\")) {\n            product = new ConcreteProductB();\n            //初始化设置product\n        }\n        return product;\n    }\n}\n```\n\n在客户端代码中，我们通过调用工厂类的工厂方法即可得到产品对象，典型代码如下所示： \n\n```\nclass Client {\n    public static void main(String args[]) {\n        Product product; \n        product = Factory.getProduct(\"A\"); //通过工厂类创建产品对象\n        product.methodSame();\n        product.methodDiff();\n    }\n}\n```\n\n# 完整解决方案\n\n为了将 Chart 类的职责分离，同时将 Chart 对象的创建和使用分离，Sunny 软件公司开发人员决定使用简单工厂模式对图表库进行重构，重构后的结构如图所示：\n\n![](/images/design-pattern/simple-factory-2.jpeg)\n\n在图中，Chart 接口充当抽象产品类，其子类HistogramChart、PieChart 和 LineChart 充当具体产品类，ChartFactory 充当工厂类。完整代码如下所示： \n\n```\n//抽象图表接口：抽象产品类\ninterface Chart {\n    public void display();\n}\n\n//柱状图类：具体产品类\nclass HistogramChart implements Chart {\n    public HistogramChart() {\n        System.out.println(\"创建柱状图！\");\n    }\n\n    public void display() {\n        System.out.println(\"显示柱状图！\");\n    }\n}\n\n//饼状图类：具体产品类\nclass PieChart implements Chart {\n    public PieChart() {\n        System.out.println(\"创建饼状图！\");\n    }\n\n    public void display() {\n        System.out.println(\"显示饼状图！\");\n    }\n}\n\n//折线图类：具体产品类\nclass LineChart implements Chart {\n    public LineChart() {\n        System.out.println(\"创建折线图！\");\n    }\n\n    public void display() {\n        System.out.println(\"显示折线图！\");\n    }\n}\n\n//图表工厂类：工厂类\nclass ChartFactory {\n    //静态工厂方法\n    public static Chart getChart(String type) {\n        Chart chart = null;\n        if (type.equalsIgnoreCase(\"histogram\")) {\n            chart = new HistogramChart();\n            System.out.println(\"初始化设置柱状图！\");\n        }\n        else if (type.equalsIgnoreCase(\"pie\")) {\n            chart = new PieChart();\n            System.out.println(\"初始化设置饼状图！\");\n        }\n        else if (type.equalsIgnoreCase(\"line\")) {\n            chart = new LineChart();\n            System.out.println(\"初始化设置折线图！\");            \n        }\n        return chart;\n    }\n}\n```\n\n编写如下客户端测试代码：\n\n```\nclass Client {\n    public static void main(String args[]) {\n        Chart chart;\n        chart = ChartFactory.getChart(\"histogram\"); //通过静态工厂方法创建产品\n        chart.display();\n    }\n}\n```\n\n编译并运行程序，输出结果如下：\n\n```\n创建柱状图！\n初始化设置柱状图！\n显示柱状图！\n```\n\n在客户端测试类中，我们使用工厂类的静态工厂方法创建产品对象，如果需要更换产品，只需修改静态工厂方法中的参数即可，例如将柱状图改为饼状图，只需将代码： \n\n```\nchart = ChartFactory.getChart(\"histogram\");\n```\n\n改为： \n\n```\nchart = ChartFactory.getChart(\"pie\");\n```\n\n编译并运行程序，输出结果如下： \n\n```\n创建饼状图！\n初始化设置饼状图！\n显示饼状图！\n```\n\n# 方案的改进\n\nSunny 软件公司开发人员发现在创建具体 Chart 对象时，每更换一个 Chart 对象都需要修改客户端代码中静态工厂方法的参数，客户端代码将要重新编译，这对于客户端而言，违反了“开闭原则”，有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？答案是肯定的，下面将介绍一种常用的实现方式。 \n\n我们可以将静态工厂方法的参数存储在 XML 或 properties 格式的配置文件中，如下 config.xml 所示： \n\n```\n<?xml version=\"1.0\"?>\n<config>\n    <chartType>histogram</chartType>\n</config>\n```\n\n再通过一个工具类 XMLUtil 来读取配置文件中的字符串参数，XMLUtil 类的代码如下所示：\n\n```\nimport javax.xml.parsers.*;\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\nimport java.io.*;\n\npublic class XMLUtil {\n    //该方法用于从XML配置文件中提取图表类型，并返回类型名\n    public static String getChartType() {\n        try {\n            //创建文档对象\n            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = dFactory.newDocumentBuilder();\n            Document doc;                           \n            doc = builder.parse(new File(\"config.xml\")); \n\n            //获取包含图表类型的文本节点\n            NodeList nl = doc.getElementsByTagName(\"chartType\");\n            Node classNode = nl.item(0).getFirstChild();\n            String chartType = classNode.getNodeValue().trim();\n            return chartType;\n        }   \n        catch(Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n```\n\n在引入了配置文件和工具类 XMLUtil 之后，客户端代码修改如下： \n\n```\nclass Client {\n    public static void main(String args[]) {\n        Chart chart;\n        String type = XMLUtil.getChartType(); //读取配置文件中的参数\n        chart = ChartFactory.getChart(type); //创建产品对象\n        chart.display();\n    }\n}\n```\n\n不难发现，在上述客户端代码中不包含任何与具体图表对象相关的信息，如果需要更换具体图表对象，只需修改配置文件 config.xml，无须修改任何源代码，符合“开闭原则”。 \n\n>思考：在简单工厂模式中增加新的具体产品时是否符合“开闭原则”？如果不符合，原有系统需作出哪些修改？ \n\n# 简单工厂模式的简化\n\n有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中，如图所示：\n\n![](/images/design-pattern/simple-factory-3.jpeg)\n\n在图中，客户端可以通过产品父类的静态工厂方法，根据参数的不同创建不同类型的产品子类对象，这种做法在 JDK 等类库和框架中也广泛存在。 \n\n# 总结\n\n简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。 \n\n## 主要优点\n\n* 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。\n\n* 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。\n\n* 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 \n\n## 主要缺点\n\n* 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。\n\n* 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。\n\n* 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。\n\n* 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 \n\n## 适用场景\n\n* 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。\n\n* 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。 \n\n>练习\n>使用简单工厂模式设计一个可以创建不同几何形状（如圆形、方形和三角形等）的绘图工具，每个几何图形都具有绘制 draw() 和擦除 erase() 两个方法，要求在绘制不支持的几何图形时，提示一个 UnSupportedShapeException。\n\n","categories":["设计模式"]},{"title":"核心动画-专用图层","url":"/2017/04/10/ios-core-animation/ios-core-animation-chapter-6/","content":"\n# 前言\n\n>复杂的组织都是专门化的\nCatharine R. Stimpson\n\n到目前为止，我们已经探讨过CALayer类了，同时我们也了解到了一些非常有用的绘图和动画功能。但是Core Animation图层不仅仅能作用于图片和颜色而已。本章就会学习其他的一些图层类，进一步扩展使用Core Animation绘图的能力。\n\n<!-- more -->\n\n# CAShapeLayer\n\n在第四章『视觉效果』我们学习到了不使用图片的情况下用CGPath去构造任意形状的阴影。如果我们能用同样的方式创建相同形状的图层就好了。\n\nCAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就自动渲染出来了。当然，你也可以用Core Graphics直接向原始的CALyer的内容中绘制一个路径，相比直下，使用CAShapeLayer有以下一些优点：\n\n* 渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。\n* 高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。\n* 不会被图层边界剪裁掉。一个CAShapeLayer可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉（如我们在第二章所见）。\n* 不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。\n\n## 创建一个CGPath\n\nCAShapeLayer可以用来绘制所有能够通过CGPath来表示的形状。这个形状不一定要闭合，图层路径也不一定要不可破，事实上你可以在一个图层上绘制好几个不同的形状。你可以控制一些属性比如lineWith（线宽，用点表示单位），lineCap（线条结尾的样子），和lineJoin（线条之间的结合点的样子）；但是在图层层面你只有一次机会设置这些属性。如果你想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。\n\n清单6.1 的代码用一个CAShapeLayer渲染一个简单的火柴人。CAShapeLayer属性是CGPathRef类型，但是我们用UIBezierPath帮助类创建了图层路径，这样我们就不用考虑人工释放CGPath了。图6.1是代码运行的结果。虽然还不是很完美，但是总算知道了大意对吧！\n\n清单6.1 用CAShapeLayer绘制一个火柴人\n\n```\n#import \"DrawingView.h\"\n#import \n\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *containerView;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n  [super viewDidLoad];\n  //create path\n  UIBezierPath *path = [[UIBezierPath alloc] init];\n  [path moveToPoint:CGPointMake(175, 100)];\n  \n  [path addArcWithCenter:CGPointMake(150, 100) radius:25 startAngle:0 endAngle:2*M_PI clockwise:YES];\n  [path moveToPoint:CGPointMake(150, 125)];\n  [path addLineToPoint:CGPointMake(150, 175)];\n  [path addLineToPoint:CGPointMake(125, 225)];\n  [path moveToPoint:CGPointMake(150, 175)];\n  [path addLineToPoint:CGPointMake(175, 225)];\n  [path moveToPoint:CGPointMake(100, 150)];\n  [path addLineToPoint:CGPointMake(200, 150)];\n\n  //create shape layer\n  CAShapeLayer *shapeLayer = [CAShapeLayer layer];\n  shapeLayer.strokeColor = [UIColor redColor].CGColor;\n  shapeLayer.fillColor = [UIColor clearColor].CGColor;\n  shapeLayer.lineWidth = 5;\n  shapeLayer.lineJoin = kCALineJoinRound;\n  shapeLayer.lineCap = kCALineCapRound;\n  shapeLayer.path = path.CGPath;\n  //add it to our view\n  [self.containerView.layer addSublayer:shapeLayer];\n}\n@end\n```\n\n![图6.1 用CAShapeLayer绘制一个简单的火柴人](/images/ios-core-animation/5.23.jpeg)\n\n## 圆角\n\n第二章里面提到了CAShapeLayer为创建圆角视图提供了一个方法，就是CALayer的cornerRadius属性（译者注：其实是在第四章提到的）。虽然使用CAShapeLayer类需要更多的工作，但是它有一个优势就是可以**单独指定每个角**。\n\n我们创建圆角矩形其实就是人工绘制单独的直线和弧度，但是事实上UIBezierPath有自动绘制圆角矩形的构造方法，下面这段代码绘制了一个有三个圆角一个直角的矩形：\n\n```\n//define path parameters\nCGRect rect = CGRectMake(50, 50, 100, 100);\nCGSize radii = CGSizeMake(20, 20);\nUIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;\n//create path\nUIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];\n```\n\n我们可以通过这个图层路径绘制一个既有直角又有圆角的视图。如果我们想依照此图形来剪裁视图内容，我们可以把CAShapeLayer作为视图的宿主图层，而不是添加一个子视图（图层蒙板的详细解释见第四章『视觉效果』）。\n\n# CATextLayer\n\n# CATransformLayer\n\n# CAGradientLayer\n\n# CAReplicatorLayer\n\n# CAScrollLayer\n\n# CATiledLayer\n\n# CAEmitterLayer\n\n# CAEAGLLayer\n\n# AVPlayerLayer\n\n# 总结\n\n","tags":["核心动画"],"categories":["iOS"]},{"title":"核心动画-变换","url":"/2017/04/10/ios-core-animation/ios-core-animation-chapter-5/","content":"\n# 前言\n\n>很不幸，没人能告诉你母体是什么，你只能自己体会 -- 骇客帝国\n\n在第四章“可视效果”中，我们研究了一些增强图层和它的内容显示效果的一些技术，在这一章中，我们将要研究可以用来对图层旋转，摆放或者扭曲的CGAffineTransform，以及可以将扁平物体转换成三维空间对象的CATransform3D（而不是仅仅对圆角矩形添加下沉阴影）。\n\n<!-- more -->\n\n# 仿射变换\n\n在第三章“图层几何学”中，我们使用了UIView的transform属性旋转了钟的指针，但并没有解释背后运作的原理，实际上UIView的transform属性是一个CGAffineTransform类型，用于在二维空间做旋转，缩放和平移。CGAffineTransform是一个可以和二维空间向量（例如CGPoint）做乘法的3X2的矩阵（见图5.1）。\n\n![图5.1 用矩阵表示的CGAffineTransform和CGPoint](/images/ios-core-animation/5.1.jpeg)\n\n用CGPoint的每一列和CGAffineTransform矩阵的每一行对应元素相乘再求和，就形成了一个新的CGPoint类型的结果。要解释一下图中显示的灰色元素，为了能让矩阵做乘法，左边矩阵的列数一定要和右边矩阵的行数个数相同，所以要给矩阵填充一些标志值，使得既可以让矩阵做乘法，又不改变运算结果，并且没必要存储这些添加的值，因为它们的值不会发生变化，但是要用来做运算。\n\n因此，通常会用3×3（而不是2×3）的矩阵来做二维变换，你可能会见到3行2列格式的矩阵，这是所谓的以列为主的格式，图5.1所示的是以行为主的格式，只要能保持一致，用哪种格式都无所谓。\n\n当对图层应用变换矩阵，图层矩形内的每一个点都被相应地做变换，从而形成一个新的四边形的形状。CGAffineTransform中的“仿射”的意思是无论变换矩阵用什么值，图层中平行的两条线在变换之后任然保持平行，CGAffineTransform可以做出任意符合上述标注的变换，图5.2显示了一些仿射的和非仿射的变换：\n\n![图5.2 仿射和非仿射变换](/images/ios-core-animation/5.2.jpeg)\n\n## 创建一个CGAffineTransform\n\n对矩阵数学做一个全面的阐述就超出本书的讨论范围了，不过如果你对矩阵完全不熟悉的话，矩阵变换可能会使你感到畏惧。幸运的是，Core Graphics提供了一系列函数，对完全没有数学基础的开发者也能够简单地做一些变换。如下几个函数都创建了一个CGAffineTransform实例：\n\n```\nCGAffineTransformMakeRotation(CGFloat angle) \nCGAffineTransformMakeScale(CGFloat sx, CGFloat sy)\nCGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty)\n```\n\n旋转和缩放变换都可以很好解释--分别旋转或者缩放一个向量的值。平移变换是指每个点都移动了向量指定的x或者y值--所以如果向量代表了一个点，那它就平移了这个点的距离。\n\n我们用一个很简单的项目来做个demo，把一个原始视图旋转45度角度（图5.3）\n\n![图5.3 使用仿射变换旋转45度角之后的视图](/images/ios-core-animation/5.3.jpeg)\n\nUIView可以通过设置transform属性做变换，但实际上它只是封装了内部图层的变换。\n\nCALayer同样也有一个transform属性，但它的类型是CATransform3D，而不是CGAffineTransform，本章后续将会详细解释。CALayer对应于UIView的transform属性叫做affineTransform，清单5.1的例子就是使用affineTransform对图层做了45度顺时针旋转。\n\n清单5.1 使用affineTransform对图层旋转45度\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *layerView;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //rotate the layer 45 degrees\n    CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);\n    self.layerView.layer.affineTransform = transform;\n}\n\n@end\n```\n\n注意我们使用的旋转常量是M_PI_4，而不是你想象的45，因为iOS的变换函数使用弧度而不是角度作为单位。弧度用数学常量pi的倍数表示，一个pi代表180度，所以四分之一的pi就是45度。\n\nC的数学函数库（iOS会自动引入）提供了pi的一些简便的换算，M_PI_4于是就是pi的四分之一，如果对换算不太清楚的话，可以用如下的宏做换算：\n\n```\n#define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0) \n#define DEGREES_TO_RADIANS(x) ((x)/180.0*M_PI)\n```\n\n## 混合变换\n\nCore Graphics提供了一系列的函数可以在一个变换的基础上做更深层次的变换，如果做一个既要缩放又要旋转的变换，这就会非常有用了。例如下面几个函数：\n\n```\nCGAffineTransformRotate(CGAffineTransform t, CGFloat angle)\nCGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy)\nCGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)\n```\n\n当操纵一个变换的时候，初始生成一个什么都不做的变换很重要--也就是创建一个CGAffineTransform类型的空值，矩阵论中称作单位矩阵，Core Graphics同样也提供了一个方便的常量：\n\n```\nCGAffineTransformIdentity\n```\n\n最后，如果需要混合两个已经存在的变换矩阵，就可以使用如下方法，在两个变换的基础上创建一个新的变换：\n\n```\nCGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);\n```\n\n我们来用这些函数组合一个更加复杂的变换，先缩小50%，再旋转30度，最后向右移动200个像素（清单5.2）。图5.4显示了图层变换最后的结果。\n\n清单5.2 使用若干方法创建一个复合变换\n\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //create a new transform\n    CGAffineTransform transform = CGAffineTransformIdentity; \n    //scale by 50%\n    transform = CGAffineTransformScale(transform, 0.5, 0.5);\n    //rotate by 30 degrees\n    transform = CGAffineTransformRotate(transform, M_PI / 180.0 * 30.0);\n    //translate by 200 points\n    transform = CGAffineTransformTranslate(transform, 200, 0);\n    //apply transform to layer\n    self.layerView.layer.affineTransform = transform;\n}\n```\n\n![图5.4 顺序应用多个仿射变换之后的结果](/images/ios-core-animation/5.4.jpeg)\n\n图5.4中有些需要注意的地方：图片向右边发生了平移，但并没有指定距离那么远（200像素），另外它还有点向下发生了平移。原因在于当你按顺序做了变换，上一个变换的结果将会影响之后的变换，所以200像素的向右平移同样也被旋转了30度，缩小了50%，所以它实际上是斜向移动了100像素。\n\n这意味着变换的顺序会影响最终的结果，也就是说旋转之后的平移和平移之后的旋转结果可能不同。\n\n## 剪切变换\n\nCore Graphics为你提供了计算变换矩阵的一些方法，所以很少需要直接设置CGAffineTransform的值。除非需要创建一个斜切的变换，Core Graphics并没有提供直接的函数。\n\n斜切变换是放射变换的第四种类型，较于平移，旋转和缩放并不常用（这也是Core Graphics没有提供相应函数的原因），但有些时候也会很有用。我们用一张图片可以很直接的说明效果（图5.5）。也许用“倾斜”描述更加恰当，具体做变换的代码见清单5.3。\n\n![图5.5 水平方向的斜切变换](/images/ios-core-animation/5.5.jpeg)\n\n清单5.3 实现一个斜切变换\n\n```\n@implementation ViewController\n\nCGAffineTransform CGAffineTransformMakeShear(CGFloat x, CGFloat y)\n{\n    CGAffineTransform transform = CGAffineTransformIdentity;\n    transform.c = -x;\n    transform.b = y;\n    return transform;\n}\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //shear the layer at a 45-degree angle\n    self.layerView.layer.affineTransform = CGAffineTransformMakeShear(1, 0);\n}\n\n@end\n```\n\n# 3D变换\n\nCG的前缀告诉我们，CGAffineTransform类型属于Core Graphics框架，Core Graphics实际上是一个严格意义上的2D绘图API，并且CGAffineTransform仅仅对2D变换有效。\n\n在第三章中，我们提到了zPosition属性，可以用来让图层靠近或者远离相机（用户视角），transform属性（CATransform3D类型）可以真正做到这点，即让图层在3D空间内移动或者旋转。\n\n和CGAffineTransform类似，CATransform3D也是一个矩阵，但是和2x3的矩阵不同，CATransform3D是一个可以在3维空间内做变换的4x4的矩阵（图5.6）。\n\n![图5.6 对一个3D像素点做CATransform3D矩阵变换](/images/ios-core-animation/5.6.jpeg)\n\n和CGAffineTransform矩阵类似，Core Animation提供了一系列的方法用来创建和组合CATransform3D类型的矩阵，和Core Graphics的函数类似，但是3D的平移和旋转多处了一个z参数，并且旋转函数除了angle之外多出了x,y,z三个参数，分别决定了每个坐标轴方向上的旋转：\n\n```\nCATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)\nCATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz) \nCATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)\n```\n\n你应该对X轴和Y轴比较熟悉了，分别以右和下为正方向（回忆第三章，这是iOS上的标准结构，在Mac OS，Y轴朝上为正方向），Z轴和这两个轴分别垂直，指向视角外为正方向（图5.7）。\n\n![图5.7 X，Y，Z轴，以及围绕它们旋转的方向](/images/ios-core-animation/5.7.jpeg)\n\n由图所见，绕Z轴的旋转等同于之前二维空间的仿射旋转，但是绕X轴和Y轴的旋转就突破了屏幕的二维空间，并且在用户视角看来发生了倾斜。\n\n举个例子：清单5.4的代码使用了CATransform3DMakeRotation对视图内的图层绕Y轴做了45度角的旋转，我们可以把视图向右倾斜，这样会看得更清晰。\n\n结果见图5.8，但并不像我们期待的那样。\n\n清单5.4 绕Y轴旋转图层\n\n```\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //rotate the layer 45 degrees along the Y axis\n    CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);\n    self.layerView.layer.transform = transform;\n}\n\n@end\n```\n\n![图5.8 绕y轴旋转45度的视图](/images/ios-core-animation/5.8.jpeg)\n\n看起来图层并没有被旋转，而是仅仅在水平方向上的一个压缩，是哪里出了问题呢？\n\n其实完全没错，视图看起来更窄实际上是因为我们在用一个斜向的视角看它，而不是透视。\n\n## 透视投影\n\n在真实世界中，当物体远离我们的时候，由于视角的原因看起来会变小，理论上说远离我们的视图的边要比靠近视角的边跟短，但实际上并没有发生，而我们当前的视角是等距离的，也就是在3D变换中任然保持平行，和之前提到的仿射变换类似。\n\n在等距投影中，远处的物体和近处的物体保持同样的缩放比例，这种投影也有它自己的用处（例如建筑绘图，颠倒，和伪3D视频），但当前我们并不需要。\n\n为了做一些修正，我们需要引入投影变换（又称作z变换）来对除了旋转之外的变换矩阵做一些修改，Core Animation并没有给我们提供设置透视变换的函数，因此我们需要手动修改矩阵值，幸运的是，很简单：\nCATransform3D的透视效果通过一个矩阵中一个很简单的元素来控制：m34。m34（图5.9）用于按比例缩放X和Y的值来计算到底要离视角多远。\n\n![图5.9 CATransform3D的m34元素，用来做透视](/images/ios-core-animation/5.9.jpeg)\n\nm34的默认值是0，我们可以通过设置m34为-1.0 / d来应用透视效果，d代表了想象中视角相机和屏幕之间的距离，以像素为单位，那应该如何计算这个距离呢？实际上并不需要，大概估算一个就好了。\n\n因为视角相机实际上并不存在，所以可以根据屏幕上的显示效果自由决定它的防止的位置。通常500-1000就已经很好了，但对于特定的图层有时候更小后者更大的值会看起来更舒服，减少距离的值会增强透视效果，所以一个非常微小的值会让它看起来更加失真，然而一个非常大的值会让它基本失去透视效果，对视图应用透视的代码见清单5.5，结果见图5.10。\n\n清单5.5 对变换应用透视效果\n\n```\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //create a new transform\n    CATransform3D transform = CATransform3DIdentity;\n    //apply perspective\n    transform.m34 = - 1.0 / 500.0;\n    //rotate by 45 degrees along the Y axis\n    transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);\n    //apply to layer\n    self.layerView.layer.transform = transform;\n}\n\n@end\n```\n\n![图5.10 应用透视效果之后再次对图层做旋转](/images/ios-core-animation/5.10.jpeg)\n\n## 灭点\n\n当在透视角度绘图的时候，远离相机视角的物体将会变小变远，当远离到一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。\n\n在现实中，这个点通常是视图的中心（图5.11），于是为了在应用中创建拟真效果的透视，这个点应该聚在屏幕中点，或者至少是包含所有3D对象的视图中点。\n\n![图5.11 灭点](/images/ios-core-animation/5.11.jpeg)\n\nCore Animation定义了这个点位于变换图层的anchorPoint（通常位于图层中心，但也有例外，见第三章）。这就是说，当图层发生变换时，这个点永远位于图层变换之前anchorPoint的位置。\n\n当改变一个图层的position，你也改变了它的灭点，做3D变换的时候要时刻记住这一点，当你视图通过调整m34来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置（而不是直接改变它的position），这样所有的3D图层都共享一个灭点。\n\n### sublayerTransform属性\n\n如果有多个视图或者图层，每个都做3D变换，那就需要分别设置相同的m34值，并且确保在变换之前都在屏幕中央共享同一个position，如果用一个函数封装这些操作的确会更加方便，但仍然有限制（例如，你不能在Interface Builder中摆放视图），这里有一个更好的方法。\n\nCALayer有一个属性叫做sublayerTransform。它也是CATransform3D类型，但和对一个图层的变换不同，它影响到所有的子图层。这意味着你可以一次性对包含这些图层的容器做变换，于是所有的子图层都自动继承了这个变换方法。\n\n相较而言，通过在一个地方设置透视变换会很方便，同时它会带来另一个显著的优势：灭点被设置在容器图层的中点，从而不需要再对子图层分别设置了。这意味着你可以随意使用position和frame来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的灭点用变换来做平移。\n\n我们来用一个demo举例说明。这里用Interface Builder并排放置两个视图（图5.12），然后通过设置它们容器视图的透视变换，我们可以保证它们有相同的透视和灭点，代码见清单5.6，结果见图5.13。\n\n![图5.12 在一个视图容器内并排放置两个视图](/images/ios-core-animation/5.12.jpeg)\n\n清单5.6 应用sublayerTransform\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *containerView;\n@property (nonatomic, weak) IBOutlet UIView *layerView1;\n@property (nonatomic, weak) IBOutlet UIView *layerView2;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //apply perspective transform to container\n    CATransform3D perspective = CATransform3DIdentity;\n    perspective.m34 = - 1.0 / 500.0;\n    self.containerView.layer.sublayerTransform = perspective;\n    //rotate layerView1 by 45 degrees along the Y axis\n    CATransform3D transform1 = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);\n    self.layerView1.layer.transform = transform1;\n    //rotate layerView2 by 45 degrees along the Y axis\n    CATransform3D transform2 = CATransform3DMakeRotation(-M_PI_4, 0, 1, 0);\n    self.layerView2.layer.transform = transform2;\n}\n```\n\n![图5.13 通过相同的透视效果分别对视图做变换](/images/ios-core-animation/5.13.jpeg)\n\n## 背面\n\n我们既然可以在3D场景下旋转图层，那么也可以从背面去观察它。如果我们在清单5.4中把角度修改为M_PI（180度）而不是当前的M_PI_4（45度），那么将会把图层完全旋转一个半圈，于是完全背对了相机视角。\n\n那么从背部看图层是什么样的呢，见图5.14\n\n![图5.14 视图的背面，一个镜像对称的图片](/images/ios-core-animation/5.14.jpeg)\n\n如你所见，图层是双面绘制的，反面显示的是正面的一个镜像图片。\n\n但这并不是一个很好的特性，因为如果图层包含文本或者其他控件，那用户看到这些内容的镜像图片当然会感到困惑。另外也有可能造成资源的浪费：想象用这些图层形成一个不透明的固态立方体，既然永远都看不见这些图层的背面，那为什么浪费GPU来绘制它们呢？\n\nCALayer有一个叫做doubleSided的属性来控制图层的背面是否要被绘制。这是一个BOOL类型，默认为YES，如果设置为NO，那么当图层正面从相机视角消失的时候，它将不会被绘制。\n\n## 扁平化图层\n\n如果对包含已经做过变换的图层的图层做反方向的变换将会发什么什么呢？是不是有点困惑？见图5.15\n\n![图5.15 反方向变换的嵌套图层](/images/ios-core-animation/5.15.jpeg)\n\n注意做了-45度旋转的内部图层是怎样抵消旋转45度的图层，从而恢复正常状态的。\n\n如果内部图层相对外部图层做了相反的变换（这里是绕Z轴的旋转），那么按照逻辑这两个变换将被相互抵消。\n\n验证一下，相应代码见清单5.7，结果见5.16\n\n清单5.7 绕Z轴做相反的旋转变换\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *outerView;\n@property (nonatomic, weak) IBOutlet UIView *innerView;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //rotate the outer layer 45 degrees\n    CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);\n    self.outerView.layer.transform = outer;\n    //rotate the inner layer -45 degrees\n    CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);\n    self.innerView.layer.transform = inner;\n}\n\n@end\n```\n\n![图5.16 旋转后的视图](/images/ios-core-animation/5.16.jpeg)\n\n运行结果和我们预期的一致。现在在3D情况下再试一次。修改代码，让内外两个视图绕Y轴旋转而不是Z轴，再加上透视效果，以便我们观察。注意不能用sublayerTransform属性，因为内部的图层并不直接是容器图层的子图层，所以这里分别对图层设置透视变换（清单5.8）。\n\n清单5.8 绕Y轴相反的旋转变换\n\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //rotate the outer layer 45 degrees\n    CATransform3D outer = CATransform3DIdentity;\n    outer.m34 = -1.0 / 500.0;\n    outer = CATransform3DRotate(outer, M_PI_4, 0, 1, 0);\n    self.outerView.layer.transform = outer;\n    //rotate the inner layer -45 degrees\n    CATransform3D inner = CATransform3DIdentity;\n    inner.m34 = -1.0 / 500.0;\n    inner = CATransform3DRotate(inner, -M_PI_4, 0, 1, 0);\n    self.innerView.layer.transform = inner;\n}\n```\n\n预期的效果应该如图5.17所示。\n\n![图5.17 绕Y轴做相反旋转的预期结果。](/images/ios-core-animation/5.17.jpeg)\n\n但其实这并不是我们所看到的，相反，我们看到的结果如图5.18所示。发什么了什么呢？内部的图层仍然向左侧旋转，并且发生了扭曲，但按道理说它应该保持正面朝上，并且显示正常的方块。\n\n这是由于尽管Core Animation图层存在于3D空间之内，但它们并不都存在同一个3D空间。每个图层的3D场景其实是扁平化的，当你从正面观察一个图层，看到的实际上由子图层创建的想象出来的3D场景，但当你倾斜这个图层，你会发现实际上这个3D场景仅仅是被绘制在图层的表面。\n\n![图5.18 绕Y轴做相反旋转的真实结果](/images/ios-core-animation/5.18.jpeg)\n\n类似的，当你在玩一个3D游戏，实际上仅仅是把屏幕做了一次倾斜，或许在游戏中可以看见有一面墙在你面前，但是倾斜屏幕并不能够看见墙里面的东西。所有场景里面绘制的东西并不会随着你观察它的角度改变而发生变化；图层也是同样的道理。\n\n这使得用Core Animation创建非常复杂的3D场景变得十分困难。你不能够使用图层树去创建一个3D结构的层级关系--在相同场景下的任何3D表面必须和同样的图层保持一致，这是因为每个的父视图都把它的子视图扁平化了。\n\n至少当你用正常的CALayer的时候是这样，CALayer有一个叫做CATransformLayer的子类来解决这个问题。具体在第六章“特殊的图层”中将会具体讨论。\n\n# 固体对象\n\n现在你懂得了在3D空间的一些图层布局的基础，我们来试着创建一个固态的3D对象（实际上是一个技术上所谓的空洞对象，但它以固态呈现）。我们用六个独立的视图来构建一个立方体的各个面。\n\n在这个例子中，我们用Interface Builder来构建立方体的面（图5.19），我们当然可以用代码来写，但是用Interface Builder的好处是可以方便的在每一个面上添加子视图。记住这些面仅仅是包含视图和控件的普通的用户界面元素，它们完全是我们界面交互的部分，并且当把它折成一个立方体之后也不会改变这个性质。\n\n![图5.19 用Interface Builder对立方体的六个面进行布局](/images/ios-core-animation/5.19.jpeg)\n\n这些面视图并没有放置在主视图当中，而是松散地排列在根nib文件里面。我们并不关心在这个容器中如何摆放它们的位置，因为后续将会用图层的transform对它们进行重新布局，并且用Interface Builder在容器视图之外摆放他们可以让我们容易看清楚它们的内容，如果把它们一个叠着一个都塞进主视图，将会变得很难看。\n\n我们把一个有颜色的UILabel放置在视图内部，是为了清楚的辨别它们之间的关系，并且UIButton被放置在第三个面视图里面，后面会做简单的解释。\n\n具体把视图组织成立方体的代码见清单5.9，结果见图5.20\n\n清单5.9 创建一个立方体\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *containerView;\n@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;\n\n@end\n\n@implementation ViewController\n\n- (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform\n{\n    //get the face view and add it to the container\n    UIView *face = self.faces[index];\n    [self.containerView addSubview:face];\n    //center the face view within the container\n    CGSize containerSize = self.containerView.bounds.size;\n    face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);\n    // apply the transform\n    face.layer.transform = transform;\n}\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //set up the container sublayer transform\n    CATransform3D perspective = CATransform3DIdentity;\n    perspective.m34 = -1.0 / 500.0;\n    self.containerView.layer.sublayerTransform = perspective;\n    //add cube face 1\n    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);\n    [self addFace:0 withTransform:transform];\n    //add cube face 2\n    transform = CATransform3DMakeTranslation(100, 0, 0);\n    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);\n    [self addFace:1 withTransform:transform];\n    //add cube face 3\n    transform = CATransform3DMakeTranslation(0, -100, 0);\n    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);\n    [self addFace:2 withTransform:transform];\n    //add cube face 4\n    transform = CATransform3DMakeTranslation(0, 100, 0);\n    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);\n    [self addFace:3 withTransform:transform];\n    //add cube face 5\n    transform = CATransform3DMakeTranslation(-100, 0, 0);\n    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);\n    [self addFace:4 withTransform:transform];\n    //add cube face 6\n    transform = CATransform3DMakeTranslation(0, 0, -100);\n    transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);\n    [self addFace:5 withTransform:transform];\n}\n\n@end\n```\n![图5.20 正面朝上的立方体](/images/ios-core-animation/5.20.jpeg)\n\n从这个角度看立方体并不是很明显；看起来只是一个方块，为了更好地欣赏它，我们将更换一个不同的视角。\n\n旋转这个立方体将会显得很笨重，因为我们要单独对每个面做旋转。另一个简单的方案是通过调整容器视图的sublayerTransform去旋转照相机。\n\n添加如下几行去旋转containerView图层的perspective变换矩阵：\n\n```\nperspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0); \nperspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);\n```\n\n这就对相机（或者相对相机的整个场景，你也可以这么认为）绕Y轴旋转45度，并且绕X轴旋转45度。现在从另一个角度去观察立方体，就能看出它的真实面貌（图5.21）。\n\n![图5.21 从一个边角观察的立方体](/images/ios-core-animation/5.21.jpeg)\n\n## 光亮和阴影\n\n现在它看起来更像是一个立方体没错了，但是对每个面之间的连接还是很难分辨。Core Animation可以用3D显示图层，但是它对光线并没有概念。如果想让立方体看起来更加真实，需要自己做一个阴影效果。你可以通过改变每个面的背景颜色或者直接用带光亮效果的图片来调整。\n\n如果需要动态地创建光线效果，你可以根据每个视图的方向应用不同的alpha值做出半透明的阴影图层，但为了计算阴影图层的不透明度，你需要得到每个面的正太向量（垂直于表面的向量），然后根据一个想象的光源计算出两个向量叉乘结果。叉乘代表了光源和图层之间的角度，从而决定了它有多大程度上的光亮。\n\n清单5.10实现了这样一个结果，我们用GLKit框架来做向量的计算（你需要引入GLKit库来运行代码），每个面的CATransform3D都被转换成GLKMatrix4，然后通过GLKMatrix4GetMatrix3函数得出一个3×3的旋转矩阵。这个旋转矩阵指定了图层的方向，然后可以用它来得到正太向量的值。\n\n结果如图5.22所示，试着调整LIGHT_DIRECTION和AMBIENT_LIGHT的值来切换光线效果\n\n清单5.10 对立方体的表面应用动态的光线效果\n\n```\n#import \"ViewController.h\" \n#import  \n#import \n\n#define LIGHT_DIRECTION 0, 1, -0.5 \n#define AMBIENT_LIGHT 0.5\n\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *containerView;\n@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;\n\n@end\n\n@implementation ViewController\n\n- (void)applyLightingToFace:(CALayer *)face\n{\n    //add lighting layer\n    CALayer *layer = [CALayer layer];\n    layer.frame = face.bounds;\n    [face addSublayer:layer];\n    //convert the face transform to matrix\n    //(GLKMatrix4 has the same structure as CATransform3D)\n    //译者注：GLKMatrix4和CATransform3D内存结构一致，但坐标类型有长度区别，所以理论上应该做一次float到CGFloat的转换，感谢[@zihuyishi](https://github.com/zihuyishi)同学~\n    CATransform3D transform = face.transform;\n    GLKMatrix4 matrix4 = *(GLKMatrix4 *)&transform;\n    GLKMatrix3 matrix3 = GLKMatrix4GetMatrix3(matrix4);\n    //get face normal\n    GLKVector3 normal = GLKVector3Make(0, 0, 1);\n    normal = GLKMatrix3MultiplyVector3(matrix3, normal);\n    normal = GLKVector3Normalize(normal);\n    //get dot product with light direction\n    GLKVector3 light = GLKVector3Normalize(GLKVector3Make(LIGHT_DIRECTION));\n    float dotProduct = GLKVector3DotProduct(light, normal);\n    //set lighting layer opacity\n    CGFloat shadow = 1 + dotProduct - AMBIENT_LIGHT;\n    UIColor *color = [UIColor colorWithWhite:0 alpha:shadow];\n    layer.backgroundColor = color.CGColor;\n}\n\n- (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform\n{\n    //get the face view and add it to the container\n    UIView *face = self.faces[index];\n    [self.containerView addSubview:face];\n    //center the face view within the container\n    CGSize containerSize = self.containerView.bounds.size;\n    face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);\n    // apply the transform\n    face.layer.transform = transform;\n    //apply lighting\n    [self applyLightingToFace:face.layer];\n}\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //set up the container sublayer transform\n    CATransform3D perspective = CATransform3DIdentity;\n    perspective.m34 = -1.0 / 500.0;\n    perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);\n    perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);\n    self.containerView.layer.sublayerTransform = perspective;\n    //add cube face 1\n    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);\n    [self addFace:0 withTransform:transform];\n    //add cube face 2\n    transform = CATransform3DMakeTranslation(100, 0, 0);\n    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);\n    [self addFace:1 withTransform:transform];\n    //add cube face 3\n    transform = CATransform3DMakeTranslation(0, -100, 0);\n    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);\n    [self addFace:2 withTransform:transform];\n    //add cube face 4\n    transform = CATransform3DMakeTranslation(0, 100, 0);\n    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);\n    [self addFace:3 withTransform:transform];\n    //add cube face 5\n    transform = CATransform3DMakeTranslation(-100, 0, 0);\n    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);\n    [self addFace:4 withTransform:transform];\n    //add cube face 6\n    transform = CATransform3DMakeTranslation(0, 0, -100);\n    transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);\n    [self addFace:5 withTransform:transform];\n}\n\n@end\n```\n![图5.22 动态计算光线效果之后的立方体](/images/ios-core-animation/5.22.jpeg)\n\n## 点击事件\n\n你应该能注意到现在可以在第三个表面的顶部看见按钮了，点击它，什么都没发生，为什么呢？\n\n这并不是因为iOS在3D场景下正确地处理响应事件，实际上是可以做到的。问题在于视图顺序。在第三章中我们简要提到过，点击事件的处理由视图在父视图中的顺序决定的，并不是3D空间中的Z轴顺序。当给立方体添加视图的时候，我们实际上是按照一个顺序添加，所以按照视图/图层顺序来说，4，5，6在3的前面。\n\n即使我们看不见4，5，6的表面（因为被1，2，3遮住了），iOS在事件响应上仍然保持之前的顺序。当试图点击表面3上的按钮，表面4，5，6截断了点击事件（取决于点击的位置），这就和普通的2D布局在按钮上覆盖物体一样。\n\n你也许认为把doubleSided设置成NO可以解决这个问题，因为它不再渲染视图后面的内容，但实际上并不起作用。因为背对相机而隐藏的视图仍然会响应点击事件（这和通过设置hidden属性或者设置alpha为0而隐藏的视图不同，那两种方式将不会响应事件）。所以即使禁止了双面渲染仍然不能解决这个问题（虽然由于性能问题，还是需要把它设置成NO）。\n\n这里有几种正确的方案：把除了表面3的其他视图userInteractionEnabled属性都设置成NO来禁止事件传递。或者简单通过代码把视图3覆盖在视图6上。无论怎样都可以点击按钮了（图5.23）。\n\n![图5.23 背景视图不再阻碍按钮，我们可以点击它了](/images/ios-core-animation/5.23.jpeg)\n\n# 总结\n\n这一章涉及了一些2D和3D的变换。你学习了一些矩阵计算的基础，以及如何用Core Animation创建3D场景。你看到了图层背后到底是如何呈现的，并且知道了不能把扁平的图片做成真实的立体效果，最后我们用demo说明了触摸事件的处理，视图中图层添加的层级顺序会比屏幕上显示的顺序更有意义。\n\n第六章我们会研究一些Core Animation提供不同功能的具体的CALayer子类。\n\n","tags":["核心动画"],"categories":["iOS"]},{"title":"设计模式原则-开闭原则","url":"/2017/04/09/design-pattern/design-pattern-principle-6/","content":"\n# 定义\n\n一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n<!-- more -->\n\n# 问题由来\n\n在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。\n\n# 解决方案\n\n当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。\n\n开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我\"你进行设计的时候一定要遵守开闭原则\"，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。\n\n在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的\"平均得分\"，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。\n\n其实笔者认为，开闭原则无非就是想表达这样一层意思：**用抽象构建框架，用实现扩展细节**。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。\n\n说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用**抽象构建框架，用实现扩展细节**的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。\n\n最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。\n\n![](/images/design-pattern/principle-6-1.gif)\n\n图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。\n\n![](/images/design-pattern/principle-6-2.gif)\n\n在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。\n\n到这里，设计模式的六大原则就写完了。主要参考书籍有《设计模式》《设计模式之禅》《大话设计模式》以及网上一些零散的文章，但主要内容主要还是我本人对这六个原则的感悟。写出来的目的一方面是对这六项原则系统地整理一下，一方面也与广大的网友分享，因为设计模式对编程人员来说，的确非常重要。正如有句话叫做一千个读者眼中有一千个哈姆雷特，如果大家对这六项原则的理解跟我有所不同，欢迎留言，大家共同探讨。\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/principle-6.html]\n\n","categories":["设计模式"]},{"title":"设计模式原则-迪米特法则","url":"/2017/04/09/design-pattern/design-pattern-principle-5/","content":"\n# 定义\n\n一个对象应该对其他对象保持最少的了解。\n\n<!-- more -->\n\n# 问题由来\n\n类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。\n\n# 解决方案\n\n尽量降低类与类之间的耦合。\n\n自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。\n\n迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：**只与直接的朋友通信**。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为**直接的朋友**，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。\n\n举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。\n\n```\n //总公司员工\n    class Employee{\n        private String id;\n        public void setId(String id){\n            this.id = id;\n        }\n        public String getId(){\n            return id;\n        }\n    }\n\n    //分公司员工\n    class SubEmployee{\n        private String id;\n        public void setId(String id){\n            this.id = id;\n        }\n        public String getId(){\n            return id;\n        }\n    }\n\n    class SubCompanyManager{\n        public List getAllEmployee(){\n            List list = new ArrayList();\n            for(int i=0; i<100; i++){\n                SubEmployee emp = new SubEmployee();\n                //为分公司人员按顺序分配一个ID\n                emp.setId(\"分公司\"+i);\n                list.add(emp);\n            }\n            return list;\n        }\n    }\n\n    class CompanyManager{\n\n        public List getAllEmployee(){\n            List list = new ArrayList();\n            for(int i=0; i<30; i++){\n                Employee emp = new Employee();\n                //为总公司人员按顺序分配一个ID\n                emp.setId(\"总公司\"+i);\n                list.add(emp);\n            }\n            return list;\n        }\n\n        public void printAllEmployee(SubCompanyManager sub){\n            List list1 = sub.getAllEmployee();\n            for(SubEmployee e:list1){\n                System.out.println(e.getId());\n            }\n\n            List list2 = this.getAllEmployee();\n            for(Employee e:list2){\n                System.out.println(e.getId());\n            }\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            CompanyManager e = new CompanyManager();\n            e.printAllEmployee(new SubCompanyManager());\n        }\n    }\n```\n\n现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:\n\n```\nclass SubCompanyManager{\n        public List getAllEmployee(){\n            List list = new ArrayList();\n            for(int i=0; i<100; i++){\n                SubEmployee emp = new SubEmployee();\n                //为分公司人员按顺序分配一个ID\n                emp.setId(\"分公司\"+i);\n                list.add(emp);\n            }\n            return list;\n        }\n        public void printEmployee(){\n            List list = this.getAllEmployee();\n            for(SubEmployee e:list){\n                System.out.println(e.getId());\n            }\n        }\n    }\n\n    class CompanyManager{\n        public List getAllEmployee(){\n            List list = new ArrayList();\n            for(int i=0; i<30; i++){\n                Employee emp = new Employee();\n                //为总公司人员按顺序分配一个ID\n                emp.setId(\"总公司\"+i);\n                list.add(emp);\n            }\n            return list;\n        }\n\n        public void printAllEmployee(SubCompanyManager sub){\n            sub.printEmployee();\n            List list2 = this.getAllEmployee();\n            for(Employee e:list2){\n                System.out.println(e.getId());\n            }\n        }\n    }\n```\n\n修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。\n\n迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个\"中介\"来发生联系，例如本例中，总公司就是通过分公司这个\"中介\"来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。 \n\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/principle-5.html]\n\n","categories":["设计模式"]},{"title":"设计模式原则-单一职责","url":"/2017/04/08/design-pattern/design-pattern-principle-1/","content":"\n# 定义\n\n不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。\n\n<!-- more -->\n\n# 问题由来\n\n类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。\n\n# 解决方案\n\n遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。\n\n说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。**所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2**。\n\n比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）\n\n举例说明，用一个类描述动物呼吸这个场景：\n\n```\nclass Animal{\n        public void breathe(String animal){\n            System.out.println(animal+\"呼吸空气\");\n        }\n    }\n    public class Client{\n        public static void main(String[] args){\n            Animal animal = new Animal();\n            animal.breathe(\"牛\");\n            animal.breathe(\"羊\");\n            animal.breathe(\"猪\");\n        }\n    }\n```\n\n运行结果：\n\n```\n牛呼吸空气  \n羊呼吸空气  \n猪呼吸空气\n```\n\n程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：\n\n```\nclass Terrestrial{\n        public void breathe(String animal){\n            System.out.println(animal+\"呼吸空气\");\n        }\n    }\n    class Aquatic{\n        public void breathe(String animal){\n            System.out.println(animal+\"呼吸水\");\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            Terrestrial terrestrial = new Terrestrial();\n            terrestrial.breathe(\"牛\");\n            terrestrial.breathe(\"羊\");\n            terrestrial.breathe(\"猪\");\n\n            Aquatic aquatic = new Aquatic();\n            aquatic.breathe(\"鱼\");\n        }\n    }\n```\n\n运行结果：\n\n```\n牛呼吸空气  \n羊呼吸空气  \n猪呼吸空气  \n鱼呼吸水\n```\n\n我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：\n\n```\nclass Animal{\n        public void breathe(String animal){\n            if(\"鱼\".equals(animal)){\n                System.out.println(animal+\"呼吸水\");\n            }else{\n                System.out.println(animal+\"呼吸空气\");\n            }\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            Animal animal = new Animal();\n            animal.breathe(\"牛\");\n            animal.breathe(\"羊\");\n            animal.breathe(\"猪\");\n            animal.breathe(\"鱼\");\n        }\n    }\n```\n\n可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用\"猪\"\"牛\"\"羊\"等相关功能带来风险，也许某一天你会发现程序运行的结果变为\"牛呼吸水\"了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：\n\n```\nclass Animal{\n        public void breathe(String animal){\n            System.out.println(animal+\"呼吸空气\");\n        }\n\n        public void breathe2(String animal){\n            System.out.println(animal+\"呼吸水\");\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            Animal animal = new Animal();\n            animal.breathe(\"牛\");\n            animal.breathe(\"羊\");\n            animal.breathe(\"猪\");\n            animal.breathe2(\"鱼\");\n        }\n    }\n```\n\n可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；\n\n例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。\n\n遵循单一职责原的优点有：\n\n* 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；\n* 提高类的可读性，提高系统的可维护性；\n* 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。\n\n需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。 \n\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/principle-1.html]\n\n","categories":["设计模式"]},{"title":"设计模式原则-依赖倒置原则","url":"/2017/04/08/design-pattern/design-pattern-principle-3/","content":"\n# 定义\n\n高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。\n\n<!-- more -->\n\n# 问题由来\n\n类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。\n\n# 解决方案\n\n将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。\n\n依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。\n\n依赖倒置原则的核心思想是**面向接口编程**，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：\n\n```\nclass Book{\n        public String getContent(){\n            return \"很久很久以前有一个阿拉伯的故事……\";\n        }\n    }\n\n    class Mother{\n        public void narrate(Book book){\n            System.out.println(\"妈妈开始讲故事\");\n            System.out.println(book.getContent());\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            Mother mother = new Mother();\n            mother.narrate(new Book());\n        }\n    }\n```\n\n运行结果:\n\n```\n妈妈开始讲故事  \n很久很久以前有一个阿拉伯的故事……\n```\n\n运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：\n\n```\nclass Newspaper{\n        public String getContent(){\n            return \"林书豪38+7领导尼克斯击败湖人……\";\n        }\n    }\n```\n\n这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。\n\n我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：\n\n```\ninterface IReader{\n        public String getContent();\n    }\n```\n\nMother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：\n\n```\nclass Newspaper implements IReader {\n        public String getContent(){\n            return \"林书豪17+9助尼克斯击败老鹰……\";\n        }\n    }\n    class Book implements IReader{\n        public String getContent(){\n            return \"很久很久以前有一个阿拉伯的故事……\";\n        }\n    }\n\n    class Mother{\n        public void narrate(IReader reader){\n            System.out.println(\"妈妈开始讲故事\");\n            System.out.println(reader.getContent());\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            Mother mother = new Mother();\n            mother.narrate(new Book());\n            mother.narrate(new Newspaper());\n        }\n    }\n```\n\n运行结果：\n\n```\n妈妈开始讲故事  \n很久很久以前有一个阿拉伯的故事……  \n妈妈开始讲故事  \n林书豪17+9助尼克斯击败老鹰……\n```\n\n这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。\n\n采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。\n\n传递依赖关系有三种方式，以上的例子中使用的方法是**接口传递*，另外还有两种传递方式：*构造方法传递和setter方法传递*，相信用过Spring框架的，对依赖的传递方式一定不会陌生。\n在实际编程中，我们一般需要做到如下3点：\n\n* 低层模块尽量都要有抽象类或接口，或者两者都有。\n* 变量的声明类型尽量是抽象类或接口。\n* 使用继承时遵循里氏替换原则。\n\n依赖倒置原则的核心就是要我们**面向接口编程**，理解了面向接口编程，也就理解了依赖倒置。 \n\n\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/principle-3.html]\n\n","categories":["设计模式"]},{"title":"设计模式原则-接口隔离原则","url":"/2017/04/08/design-pattern/design-pattern-principle-4/","content":"\n# 定义\n\n客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。\n\n<!-- more -->\n\n# 问题由来\n\n类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。\n\n# 解决方案\n\n将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。\n\n举例来说明接口隔离原则：\n\n![图 1 - 未遵循接口隔离原则的设计](/images/design-pattern/principle-4-1.jpeg)\n\n这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下：\n\n```\ninterface I {\n        public void method1();\n        public void method2();\n        public void method3();\n        public void method4();\n        public void method5();\n    }\n\n    class A{\n        public void depend1(I i){\n            i.method1();\n        }\n        public void depend2(I i){\n            i.method2();\n        }\n        public void depend3(I i){\n            i.method3();\n        }\n    }\n\n    class B implements I{\n        public void method1() {\n            System.out.println(\"类B实现接口I的方法1\");\n        }\n        public void method2() {\n            System.out.println(\"类B实现接口I的方法2\");\n        }\n        public void method3() {\n            System.out.println(\"类B实现接口I的方法3\");\n        }\n        //对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，\n        //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。\n        public void method4() {}\n        public void method5() {}\n    }\n\n    class C{\n        public void depend1(I i){\n            i.method1();\n        }\n        public void depend2(I i){\n            i.method4();\n        }\n        public void depend3(I i){\n            i.method5();\n        }\n    }\n\n    class D implements I{\n        public void method1() {\n            System.out.println(\"类D实现接口I的方法1\");\n        }\n        //对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，\n        //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。\n        public void method2() {}\n        public void method3() {}\n\n        public void method4() {\n            System.out.println(\"类D实现接口I的方法4\");\n        }\n        public void method5() {\n            System.out.println(\"类D实现接口I的方法5\");\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            A a = new A();\n            a.depend1(new B());\n            a.depend2(new B());\n            a.depend3(new B());\n\n            C c = new C();\n            c.depend1(new D());\n            c.depend2(new D());\n            c.depend3(new D());\n        }\n    }\n```\n\n可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：\n\n![图 2 - 遵循接口隔离原则的设计](/images/design-pattern/principle-4-2.jpeg)\n\n照例贴出程序的代码，供不熟悉类图的朋友参考：\n\n```\ninterface I1 {\n        public void method1();\n    }\n\n    interface I2 {\n        public void method2();\n        public void method3();\n    }\n\n    interface I3 {\n        public void method4();\n        public void method5();\n    }\n\n    class A{\n        public void depend1(I1 i){\n            i.method1();\n        }\n        public void depend2(I2 i){\n            i.method2();\n        }\n        public void depend3(I2 i){\n            i.method3();\n        }\n    }\n\n    class B implements I1, I2{\n        public void method1() {\n            System.out.println(\"类B实现接口I1的方法1\");\n        }\n        public void method2() {\n            System.out.println(\"类B实现接口I2的方法2\");\n        }\n        public void method3() {\n            System.out.println(\"类B实现接口I2的方法3\");\n        }\n    }\n\n    class C{\n        public void depend1(I1 i){\n            i.method1();\n        }\n        public void depend2(I3 i){\n            i.method4();\n        }\n        public void depend3(I3 i){\n            i.method5();\n        }\n    }\n\n    class D implements I1, I3{\n        public void method1() {\n            System.out.println(\"类D实现接口I1的方法1\");\n        }\n        public void method4() {\n            System.out.println(\"类D实现接口I3的方法4\");\n        }\n        public void method5() {\n            System.out.println(\"类D实现接口I3的方法5\");\n        }\n    }\n```\n\n接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的\"契约\"，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。\n\n说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。\n\n采用接口隔离原则对接口进行约束时，要注意以下几点：\n\n* 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。\n* 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。\n* 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。\n\n运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。\n\n\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/principle-4.html]\n\n","categories":["设计模式"]},{"title":"设计模式原则-里氏替换原则","url":"/2017/04/08/design-pattern/design-pattern-principle-2/","content":"\n肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。\n\n<!-- more -->\n\n# 定义 1\n\n如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。\n\n# 定义 2\n\n所有引用基类的地方必须能透明地使用其子类的对象。\n\n# 问题由来\n\n有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。\n\n# 解决方案\n\n当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。\n\n继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。\n\n继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。\n\n举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。\n\n```\n class A{\n        public int func1(int a, int b){\n            return a-b;\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            A a = new A();\n            System.out.println(\"100-50=\"+a.func1(100, 50));\n            System.out.println(\"100-80=\"+a.func1(100, 80));\n        }\n    }\n```\n\n运行结果：\n\n```\n100-50=50  \n100-80=20\n```\n\n后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：\n\n* 两数相减。\n* 两数相加，然后再加100。\n\n由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：\n\n```\nclass B extends A{\n        public int func1(int a, int b){\n            return a+b;\n        }\n\n        public int func2(int a, int b){\n            return func1(a,b)+100;\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            B b = new B();\n            System.out.println(\"100-50=\"+b.func1(100, 50));\n            System.out.println(\"100-80=\"+b.func1(100, 80));\n            System.out.println(\"100+20+100=\"+b.func2(100, 20));\n        }\n    }\n```\n\n类B完成后，运行结果：\n\n```\n100-50=150  \n100-80=180  \n100+20+100=220\n```\n\n我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。\n\n里氏替换原则通俗的来讲就是：**子类可以扩展父类的功能，但不能改变父类原有的功能**。它包含以下4层含义：\n\n* 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。\n* 子类中可以增加自己特有的方法。\n* 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。\n* 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。\n\n看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？\n\n后果就是：**你写的代码出问题的几率将会大大增加**。 \n\n\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/principle-2.html]\n\n","categories":["设计模式"]},{"title":"设计模式原则-目录","url":"/2017/04/08/design-pattern/design-pattern-principle-catalogue/","content":"\n设计模式的学习，可以增强自己的代码复用意识。同时，也可以清晰地表达自己的编程思路。本文将介绍设计模式的六大原则：\n\n<!-- more -->\n\n* [单一职责原则](http://blog.devjackcat.com/2017/04/08/design-pattern-principle-1/)\n* [里氏替换原则](http://blog.devjackcat.com/2017/04/08/design-pattern-principle-2/)\n* [依赖倒置原则](http://blog.devjackcat.com/2017/04/08/design-pattern-principle-3/)\n* [接口隔离原则](http://blog.devjackcat.com/2017/04/08/design-pattern-principle-4/)\n* [迪米特法则](http://blog.devjackcat.com/2017/04/09/design-pattern-principle-5/)\n* [开闭原则](http://blog.devjackcat.com/2017/04/09/design-pattern-principle-6/)\n\n\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/]\n\n","categories":["设计模式"]},{"title":"设计模式-命令模式","url":"/2017/04/08/design-pattern/design-pattern-command/","content":"\n装修新房的最后几道工序之一是安装插座和开关，通过开关可以控制一些电器的打开和关闭，例如电灯或者排气扇。在购买开关时，我们并不知道它将来到底用于控制什么电器，也就是说，开关与电灯、排气扇并无直接关系，一个开关在安装之后可能用来控制电灯，也可能用来控制排气扇或者其他电器设备。开关与电器之间通过电线建立连接，如果开关打开，则电线通电，电器工作；反之，开关关闭，电线断电，电器停止工作。相同的开关可以通过不同的电线来控制不同的电器，如图1所示：\n\n<!-- more -->\n\n![图1 开关与电灯、排气扇示意图](/images/design-pattern/command-1.jpeg)\n\n在图1中，我们可以将开关理解成一个请求的发送者，用户通过它来发送一个“开灯”请求，而电灯是“开灯”请求的最终接收者和处理者，在图中，开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者，只需更换一根电线，相同的发送者（开关）即可对应不同的接收者（电器）。\n\n在软件开发中也存在很多与开关和电器类似的请求发送者和接收者对象，例如一个按钮，它可能是一个“关闭窗口”请求的发送者，而按钮点击事件处理类则是该请求的接收者。为了降低系统的耦合度，将请求的发送者和接收者解耦，我们可以使用一种被称之为命令模式的设计模式来设计系统，在命令模式中，发送者与接收者之间引入了新的命令对象（类似图1中的电线），将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法。本章我们将学习用于将请求发送者和接收者解耦的命令模式。\n\n# 自定义功能键\n\nSunny软件公司开发人员为公司内部OA系统开发了一个桌面版应用程序，该应用程序为用户提供了一系列自定义功能键，用户可以通过这些功能键来实现一些快捷操作。Sunny软件公司开发人员通过分析，发现不同的用户可能会有不同的使用习惯，在设置功能键的时候每个人都有自己的喜好，例如有的人喜欢将第一个功能键设置为“打开帮助文档”，有的人则喜欢将该功能键设置为“最小化至托盘”，为了让用户能够灵活地进行功能键的设置，开发人员提供了一个“功能键设置”窗口，该窗口界面如图2所示：\n\n![图2  “功能键设置”界面效果图](/images/design-pattern/command-2.jpeg)\n\n通过如图2所示界面，用户可以将功能键和相应功能绑定在一起，还可以根据需要来修改功能键的设置，而且系统在未来可能还会增加一些新的功能或功能键。\n\nSunny软件公司某开发人员欲使用如下代码来实现功能键与功能处理类之间的调用关系：\n\n```\n//FunctionButton：功能键类，请求发送者\nclass FunctionButton {\n\tprivate HelpHandler help; //HelpHandler：帮助文档处理类，请求接收者\n\t\n    //在FunctionButton的onClick()方法中调用HelpHandler的display()方法\npublic void onClick() {\n\t\thelp = new HelpHandler();\n\t\thelp.display(); //显示帮助文档\n\t}\n}\n```\n\n在上述代码中，功能键类FunctionButton充当请求的发送者，帮助文档处理类HelpHandler充当请求的接收者，在发送者FunctionButton的onClick()方法中将调用接收者HelpHandler的display()方法。显然，如果使用上述代码，将给系统带来如下几个问题：\n\n1. 由于请求发送者和请求接收者之间存在方法的直接调用，耦合度很高，**更换请求接收者必须修改发送者的源代码**，如果需要将请求接收者HelpHandler改为WindowHanlder（窗口处理类），则需要修改FunctionButton的源代码，违背了“开闭原则”。\n\n2. FunctionButton类在设计和实现时功能已被固定，如果增加一个新的请求接收者，如果不修改原有的FunctionButton类，则必须增加一个新的与FunctionButton功能类似的类，**这将导致系统中类的个数急剧增加**。由于请求接收者HelpHandler、WindowHanlder等类之间可能不存在任何关系，它们没有共同的抽象层，因此也很难依据“依赖倒转原则”来设计FunctionButton。\n\n3. **用户无法按照自己的需要来设置某个功能键的功能**，一个功能键类的功能一旦固定，在不修改源代码的情况下无法更换其功能，系统缺乏灵活性。\n\n不难得知，所有这些问题的产生都是因为请求发送者FunctionButton类和请求接收者HelpHandler、WindowHanlder等类之间存在直接耦合关系，如何降低请求发送者和接收者之间的耦合度，让相同的发送者可以对应不同的接收者？这是Sunny软件公司开发人员在设计“功能键设置”模块时不得不考虑的问题。命令模式正为解决这类问题而诞生，此时，如果我们使用命令模式，可以在一定程度上解决上述问题（*注：命令模式无法解决类的个数增加的问题*），下面就让我们正式进入命令模式的学习，看看命令模式到底如何实现请求发送者和接收者解耦。\n\n\n# 命令模式概述\n\n在软件开发中，我们经常需要向某些对象发送请求（调用其中的某个或某些方法），但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，此时，我们特别希望能够以一种松耦合的方式来设计软件，使得请求发送者与请求接收者能够消除彼此之间的耦合，让对象之间的调用关系更加灵活，可以灵活地指定请求接收者以及被请求的操作。命令模式为此类问题提供了一个较为完美的解决方案。\n\n**命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。**\n\n命令模式定义如下：\n\n>命令模式(Command Pattern)：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。\n\n命令模式的定义比较复杂，提到了很多术语，例如“用不同的请求对客户进行参数化”、“对请求排队”，“记录请求日志”、“支持可撤销操作”等，在后面我们将对这些术语进行一一讲解。\n\n命令模式的核心在于引入了命令类，通过命令类来降低发送者和接收者的耦合度，请求发送者只需指定一个命令对象，再通过命令对象来调用请求接收者的处理方法，其结构如图3所示：\n\n![图3 命令模式结构图](/images/design-pattern/command-3.jpeg)\n\n在命令模式结构图中包含如下几个角色：\n\n* **Command（抽象命令类）**：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。\n\n* **ConcreteCommand（具体命令类）**：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。\n\n* **Invoker（调用者）**：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。\n\n* **Receiver（接收者）**：接收者执行与请求相关的操作，它具体实现对请求的业务处理。\n\n**命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开**。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作。**命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。**\n\n**命令模式的关键在于引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联**。在最简单的抽象命令类中只包含了一个抽象的execute()方法，每个具体命令类将一个Receiver类型的对象作为一个实例变量进行存储，从而具体指定一个请求的接收者，不同的具体命令类提供了execute()方法的不同实现，并调用不同接收者的请求处理方法。\n\n典型的抽象命令类代码如下所示：\n\n```\nabstract class Command {\n\tpublic abstract void execute();\n}\n```\n\n对于请求发送者即调用者而言，将针对抽象命令类进行编程，**可以通过构造注入或者设值注入的方式在运行时传入具体命令类对象，并在业务方法中调用命令对象的execute()方法**，其典型代码如下所示：\n\n```\nclass Invoker {\n\tprivate Command command;\n\t\n    //构造注入\n\tpublic Invoker(Command command) {\n\t\tthis.command = command;\n\t}\n\t\n    //设值注入\n\tpublic void setCommand(Command command) {\n\t\tthis.command = command;\n\t}\n\t\n\t//业务方法，用于调用命令类的execute()方法\n\tpublic void call() {\n\t\tcommand.execute();\n\t}\n}\n```\n\n具体命令类继承了抽象命令类，它与请求接收者相关联，实现了在抽象命令类中声明的execute()方法，并在实现时调用接收者的请求响应方法action()，其典型代码如下所示：\n\n```\nclass ConcreteCommand extends Command {\n\tprivate Receiver receiver; //维持一个对请求接收者对象的引用\n\n\tpublic void execute() {\n\t\treceiver.action(); //调用请求接收者的业务处理方法action()\n\t}\n}\n```\n\n请求接收者Receiver类具体实现对请求的业务处理，它提供了action()方法，用于执行与请求相关的操作，其典型代码如下所示：\n\n```\nclass Receiver {\n\tpublic void action() {\n\t\t//具体操作\n\t}\n}\n```\n\n\n>思考：一个请求发送者能否对应多个请求接收者？如何实现？\n\n\n# 完整解决方案\n\n为了降低功能键与功能处理类之间的耦合度，让用户可以自定义每一个功能键的功能，Sunny软件公司开发人员使用命令模式来设计“自定义功能键”模块，其核心结构如图4所示：\n\n![图4 自定义功能键核心结构图](/images/design-pattern/command-4.jpeg)\n\n在图4中，FBSettingWindow是“功能键设置”界面类，FunctionButton充当请求调用者，Command充当抽象命令类，MinimizeCommand和HelpCommand充当具体命令类，WindowHanlder和HelpHandler充当请求接收者。完整代码如下所示：\n\n```\nimport java.util.*;\n\n//功能键设置窗口类\nclass FBSettingWindow {\n\tprivate String title; //窗口标题\n    //定义一个ArrayList来存储所有功能键\n\tprivate ArrayList<FunctionButton> functionButtons = new ArrayList<FunctionButton>();\n\t\n\tpublic FBSettingWindow(String title) {\n\t\tthis.title = title;\n\t}\n\t\n\tpublic void setTitle(String title) {\n\t\tthis.title = title;\n\t}\n\t\n\tpublic String getTitle() {\n\t\treturn this.title;\n\t}\n\t\n\tpublic void addFunctionButton(FunctionButton fb) {\n\t\tfunctionButtons.add(fb);\n\t}\n\t\n\tpublic void removeFunctionButton(FunctionButton fb) {\n\t\tfunctionButtons.remove(fb);\n\t}\n\t\n    //显示窗口及功能键\n\tpublic void display() {\n\t\tSystem.out.println(\"显示窗口：\" + this.title);\n\t\tSystem.out.println(\"显示功能键：\");\n\t\tfor (Object obj : functionButtons) {\n\t\t\tSystem.out.println(((FunctionButton)obj).getName());\n\t\t}\n\t\tSystem.out.println(\"------------------------------\");\n\t}\t\n}\n\n//功能键类：请求发送者\nclass FunctionButton {\n\tprivate String name; //功能键名称\n\tprivate Command command; //维持一个抽象命令对象的引用\n\t\n\tpublic FunctionButton(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\t\n    //为功能键注入命令\n\tpublic void setCommand(Command command) {\n\t\tthis.command = command;\n\t}\n\t\n    //发送请求的方法\n\tpublic void onClick() {\n\t\tSystem.out.print(\"点击功能键：\");\n\t\tcommand.execute();\n\t}\n}\n\n//抽象命令类\nabstract class Command {\n\tpublic abstract void execute();\n}\n\n//帮助命令类：具体命令类\nclass HelpCommand extends Command {\n\tprivate HelpHandler hhObj; //维持对请求接收者的引用\n\t\n\tpublic HelpCommand() {\n\t\thhObj = new HelpHandler();\n\t}\n\t\n    //命令执行方法，将调用请求接收者的业务方法\n\tpublic void execute() {\n\t\thhObj.display();\n\t}\n}\n\n//最小化命令类：具体命令类\nclass MinimizeCommand extends Command {\n\tprivate WindowHanlder whObj; //维持对请求接收者的引用\n\t\n\tpublic MinimizeCommand() {\n\t\twhObj = new WindowHanlder();\n\t}\n\t\n//命令执行方法，将调用请求接收者的业务方法\n\tpublic void execute() {\n\t\twhObj.minimize();\n\t}\n}\n\n//窗口处理类：请求接收者\nclass WindowHanlder {\n\tpublic void minimize() {\n\t\tSystem.out.println(\"将窗口最小化至托盘！\");\n\t}\n}\n\n//帮助文档处理类：请求接收者\nclass HelpHandler {\n\tpublic void display() {\n\t\tSystem.out.println(\"显示帮助文档！\");\n\t}\n}\n```\n\n为了提高系统的灵活性和可扩展性，我们将具体命令类的类名存储在配置文件中，并通过工具类XMLUtil来读取配置文件并反射生成对象，XMLUtil类的代码如下所示：\n\n```\nimport javax.xml.parsers.*;\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\nimport java.io.*;\n\npublic class XMLUtil {\n//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象，可以通过参数的不同返回不同类名节点所对应的实例\n\tpublic static Object getBean(int i) {\n\t\ttry {\n\t\t\t//创建文档对象\n\t\t\tDocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder builder = dFactory.newDocumentBuilder();\n\t\t\tDocument doc;\t\t\t\t\t\t\t\n\t\t\tdoc = builder.parse(new File(\"config.xml\")); \n\t\t\n\t\t\t//获取包含类名的文本节点\n\t\t\tNodeList nl = doc.getElementsByTagName(\"className\");\n            Node classNode = null;\n            if (0 == i) {\n            \tclassNode = nl.item(0).getFirstChild();\n            }\n            else {\n            \tclassNode = nl.item(1).getFirstChild();\n            } \n\n            String cName = classNode.getNodeValue();\n            \n            //通过类名生成实例对象并将其返回\n            Class c = Class.forName(cName);\n\t  \t    Object obj = c.newInstance();\n            return obj;\n        }   \n        catch(Exception e){\n            e.printStackTrace();\n           \treturn null;\n        }\n\t}\n}\n\n```\n\n配置文件config.xml中存储了具体建造者类的类名，代码如下所示：\n\n```\n<?xml version=\"1.0\"?>\n<config>\n\t<className>HelpCommand</className>\n    <className>MinimizeCommand</className>\n</config>\n```\n\n编写如下客户端测试代码：\n\n```\nclass Client {\n\tpublic static void main(String args[]) {\n\t\tFBSettingWindow fbsw = new FBSettingWindow(\"功能键设置\");\n\t\t\t\n\t\tFunctionButton fb1,fb2;\n\t\tfb1 = new FunctionButton(\"功能键1\");\n\t\tfb2 = new FunctionButton(\"功能键1\");\n\t\t\n\t\tCommand command1,command2;\n        //通过读取配置文件和反射生成具体命令对象\n\t\tcommand1 = (Command)XMLUtil.getBean(0);\n\t\tcommand2 = (Command)XMLUtil.getBean(1);\n\t    \n        //将命令对象注入功能键\n\t\tfb1.setCommand(command1);\n\t\tfb2.setCommand(command2);\n\t\t\n\t\tfbsw.addFunctionButton(fb1);\n\t\tfbsw.addFunctionButton(fb2);\n\t\tfbsw.display();\n\t\t\n        //调用功能键的业务方法\n\t\tfb1.onClick();\n\t\tfb2.onClick();\n\t}\n}\n```\n\n编译并运行程序，输出结果如下：\n\n```\n显示窗口：功能键设置\n\n显示功能键：\n\n功能键1\n\n功能键1\n\n------------------------------\n\n点击功能键：显示帮助文档！\n\n点击功能键：将窗口最小化至托盘！\n```\n\n如果需要修改功能键的功能，例如某个功能键可以实现“自动截屏”，只需要对应增加一个新的具体命令类，在该命令类与屏幕处理者(ScreenHandler)之间创建一个关联关系，然后将该具体命令类的对象通过配置文件注入到某个功能键即可，原有代码无须修改，符合“开闭原则”。在此过程中，**每一个具体命令类对应一个请求的处理者（接收者），通过向请求发送者注入不同的具体命令对象可以使得相同的发送者对应不同的接收者，从而实现“将一个请求封装为一个对象，用不同的请求对客户进行参数化”**，客户端只需要将具体命令对象作为参数注入请求发送者，无须直接操作请求的接收者。\n\n# 命令队列的实现\n\n有时候我们需要**将多个请求排队，当一个请求发送者发送一个请求时，将不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理**。此时，我们可以通过**命令队列**来实现。\n\n命令队列的实现方法有多种形式，其中最常用、灵活性最好的一种方式是增加一个CommandQueue类，由该类来负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者，CommandQueue类的典型代码如下所示：\n\n```\nimport java.util.*;\n\nclass CommandQueue {\n    //定义一个ArrayList来存储命令队列\n\tprivate ArrayList<Command> commands = new ArrayList<Command>();\n\t\n\tpublic void addCommand(Command command) {\n\t\tcommands.add(command);\n\t}\n\t\n\tpublic void removeCommand(Command command) {\n\t\tcommands.remove(command);\n\t}\n\t\n    //循环调用每一个命令对象的execute()方法\n\tpublic void execute() {\n\t\tfor (Object command : commands) {\n\t\t\t((Command)command).execute();\n\t\t}\n\t}\n}\n```\n\n在增加了命令队列类CommandQueue以后，请求发送者类Invoker将针对CommandQueue编程，代码修改如下：\n\n```\nclass Invoker {\n\tprivate CommandQueue commandQueue; //维持一个CommandQueue对象的引用\n\t\n    //构造注入\n\tpublic Invoker(CommandQueue commandQueue) {\n\t\tthis. commandQueue = commandQueue;\n\t}\n\t\n    //设值注入\n\tpublic void setCommandQueue(CommandQueue commandQueue) {\n\t\tthis.commandQueue = commandQueue;\n\t}\n\t\n\t//调用CommandQueue类的execute()方法\n\tpublic void call() {\n\t\tcommandQueue.execute();\n\t}\n}\n```\n\n命令队列与我们常说的“批处理”有点类似。批处理，顾名思义，可以对一组对象（命令）进行批量处理，当一个发送者发送请求后，将有一系列接收者对请求作出响应，命令队列可以用于设计批处理应用程序，如果请求接收者的接收次序没有严格的先后次序，我们还可以使用多线程技术来并发调用命令对象的execute()方法，从而提高程序的执行效率。\n\n# 撤销操作的实现\n\n在命令模式中，我们可以通过调用一个命令对象的execute()方法来实现对请求的处理，如果需要撤销(Undo)请求，可通过在命令类中增加一个逆向操作来实现。\n\n除了通过一个**逆向操作**来实现撤销(Undo)外，还可以通过**保存对象的历史状态**来实现撤销，后者可使用备忘录模式(Memento Pattern)来实现。\n\n下面通过一个简单的实例来学习如何使用命令模式实现撤销操作：\n\nSunny软件公司欲开发一个简易计算器，该计算器可以实现简单的数学运算，还可以对运算实施撤销操作。\n\nSunny软件公司开发人员使用命令模式设计了如图5所示结构图，其中计算器界面类CalculatorForm充当请求发送者，实现了数据求和功能的加法类Adder充当请求接收者，界面类可间接调用加法类中的add()方法实现加法运算，并且提供了可撤销加法运算的undo()方法。\n\n本实例完整代码如下所示：\n\n```\n//加法类：请求接收者\nclass Adder {\n\tprivate int num=0; //定义初始值为0\n\t\n    //加法操作，每次将传入的值与num作加法运算，再将结果返回\n\tpublic int add(int value) {\n\t\tnum += value;\n\t\treturn num;\n\t}\n}\n\n//抽象命令类\nabstract class AbstractCommand {\n\tpublic abstract int execute(int value); //声明命令执行方法execute()\n\tpublic abstract int undo(); //声明撤销方法undo()\n}\n\n//具体命令类\nclass ConcreteCommand extends AbstractCommand {\n\tprivate Adder adder = new Adder();\n\tprivate int value;\n\t\t\n\t//实现抽象命令类中声明的execute()方法，调用加法类的加法操作\npublic int execute(int value) {\n\t\tthis.value=value;\n\t\treturn adder.add(value);\n\t}\n\t\n    //实现抽象命令类中声明的undo()方法，通过加一个相反数来实现加法的逆向操作\n\tpublic int undo() {\n\t\treturn adder.add(-value);\n\t}\n}\n\n//计算器界面类：请求发送者\nclass CalculatorForm {\n\tprivate AbstractCommand command;\n\t\n\tpublic void setCommand(AbstractCommand command) {\n\t\tthis.command = command;\n\t}\n\t\n    //调用命令对象的execute()方法执行运算\n\tpublic void compute(int value) {\n\t\tint i = command.execute(value);\n\t\tSystem.out.println(\"执行运算，运算结果为：\" + i);\n\t}\n\t\n    //调用命令对象的undo()方法执行撤销\n\tpublic void undo() {\n\t\tint i = command.undo();\n\t\tSystem.out.println(\"执行撤销，运算结果为：\" + i);\n\t}\n}\n```\n\n编写如下客户端测试代码：\n\n```\nclass Client {\n\tpublic static void main(String args[]) {\n\t\tCalculatorForm form = new CalculatorForm();\n\t\tAbstractCommand command;\n\t\tcommand = new ConcreteCommand();\n\t\tform.setCommand(command); //向发送者注入命令对象\n\t\t\n\t\tform.compute(10);\n\t\tform.compute(5);\n\t\tform.compute(10);\n\t\tform.undo();\n\t}\n}\n```\n\n编译并运行程序，输出结果如下：\n\n```\n执行运算，运算结果为：10\n\n执行运算，运算结果为：15\n\n执行运算，运算结果为：25\n\n执行撤销，运算结果为：15\n```\n\n>思考：如果连续调用“form.undo()”两次，预测客户端代码的输出结果。\n\n需要注意的是在本实例中只能实现一步撤销操作，因为没有保存命令对象的历史状态，可以通过引入一个命令集合或其他方式来存储每一次操作时命令的状态，从而实现多次撤销操作。除了Undo操作外，还可以采用类似的方式实现恢复(Redo)操作，即恢复所撤销的操作（或称为二次撤销）。\n\n>练习：修改简易计算器源代码，使之能够实现多次撤销(Undo)和恢复(Redo)。\n\n# 请求日志\n\n请求日志就是将请求的历史记录保存下来，通常以日志文件(Log File)的形式永久存储在计算机中。很多系统都提供了日志文件，例如Windows日志文件、Oracle日志文件等，日志文件可以记录用户对系统的一些操作（例如对数据的更改）。请求日志文件可以实现很多功能，常用功能如下：\n\n1. “天有不测风云”，一旦系统发生故障，日志文件可以为系统提供一种恢复机制，在请求日志文件中可以记录用户对系统的每一步操作，从而让系统能够顺利恢复到某一个特定的状态；\n\n2. 请求日志也可以用于实现批处理，在一个请求日志文件中可以存储一系列命令对象，例如一个命令队列；\n\n3. 可以将命令队列中的所有命令对象都存储在一个日志文件中，每执行一个命令则从日志文件中删除一个对应的命令对象，防止因为断电或者系统重启等原因造成请求丢失，而且可以避免重新发送全部请求时造成某些命令的重复执行，只需读取请求日志文件，再继续执行文件中剩余的命令即可。\n\n在实现请求日志时，我们可以**将命令对象通过序列化写到日志文件中**，此时命令类必须实现Java.io.Serializable接口。下面我们通过一个简单实例来说明日志文件的用途以及如何实现请求日志。\n\nSunny软件公司开发了一个网站配置文件管理工具，可以通过一个可视化界面对网站配置文件进行增删改等操作，该工具使用命令模式进行设计，结构如图6所示：\n\n![图6  网站配置文件管理工具结构图](/images/design-pattern/command-6.jpeg)\n\n现在Sunny软件公司开发人员希望将对配置文件的操作请求记录在日志文件中，如果网站重新部署，只需要执行保存在日志文件中的命令对象即可修改配置文件。\n\n本实例完整代码如下所示：\n\n```\nimport java.io.*;\nimport java.util.*;\n\n//抽象命令类，由于需要将命令对象写入文件，因此它实现了Serializable接口\nabstract class Command implements Serializable {\n\tprotected String name; //命令名称\n\tprotected String args; //命令参数\n\tprotected ConfigOperator configOperator; //维持对接收者对象的引用\n\t\n\tpublic Command(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic void setConfigOperator(ConfigOperator configOperator) {\n\t\tthis.configOperator = configOperator;\n\t}\n\t\n    //声明两个抽象的执行方法execute()\n\tpublic abstract void execute(String args);\n\tpublic abstract void execute();\n}\n\n//增加命令类：具体命令\nclass InsertCommand extends Command {\n\tpublic InsertCommand(String name) {\n\t\tsuper(name);\n\t}\n\t\n\tpublic void execute(String args) {\n\t\tthis.args = args;\n\t\tconfigOperator.insert(args);\n\t}\n\t\n\tpublic void execute() {\n\t\tconfigOperator.insert(this.args);\n\t}\n}\n\n//修改命令类：具体命令\nclass ModifyCommand extends Command {\n\tpublic ModifyCommand(String name) {\n\t\tsuper(name);\n\t}\n\t\n\tpublic void execute(String args) {\n\t\tthis.args = args;\n\t\tconfigOperator.modify(args);\n\t}\n\t\n\tpublic void execute() {\n\t\tconfigOperator.modify(this.args);\n\t}\n}\n\n//省略了删除命令类DeleteCommand\n\n//配置文件操作类：请求接收者。由于ConfigOperator类的对象是Command的成员对象，它也将随Command对象一起写入文件，因此ConfigOperator也需要实现Serializable接口\nclass ConfigOperator implements Serializable {\n\tpublic void insert(String args) {\n\t\tSystem.out.println(\"增加新节点：\" + args);\n\t}\n\t\n\tpublic void modify(String args) {\n\t\tSystem.out.println(\"修改节点：\" + args);\n\t}\n\t\n\tpublic void delete(String args) {\n\t\tSystem.out.println(\"删除节点：\" + args);\n\t}\n}\n\n//配置文件设置窗口类：请求发送者\nclass ConfigSettingWindow {\n    //定义一个集合来存储每一次操作时的命令对象\n\tprivate ArrayList<Command> commands = new ArrayList<Command>();\n\tprivate Command command; \n\n    //注入具体命令对象\n\tpublic void setCommand(Command command) {\n\t\tthis.command = command;\n\t}\n\t\n    //执行配置文件修改命令，同时将命令对象添加到命令集合中\n\tpublic void call(String args) {\n\t\tcommand.execute(args);\n\t\tcommands.add(command);\n\t}\n\t\n    //记录请求日志，生成日志文件，将命令集合写入日志文件\n\tpublic void save() {\n\t\tFileUtil.writeCommands(commands);\n\t}\n\t\n    //从日志文件中提取命令集合，并循环调用每一个命令对象的execute()方法来实现配置文件的重新设置\n\tpublic void recover() {\n\t\tArrayList list;\n\t\tlist = FileUtil.readCommands();\n\t\t\n\t\tfor (Object obj : list) {\n\t\t\t((Command)obj).execute();\n\t\t}\n\t}\n}\n\n//工具类：文件操作类\nclass FileUtil {\n    //将命令集合写入日志文件\n\tpublic static void writeCommands(ArrayList commands) {\n\t\ttry {\n\t\t\tFileOutputStream file = new FileOutputStream(\"config.log\");\n\t\t\t//创建对象输出流用于将对象写入到文件中\n    \t\tObjectOutputStream objout = new ObjectOutputStream(new BufferedOutputStream(file));\n\t\t\t//将对象写入文件\n    \t\tobjout.writeObject(commands);\n    \t\tobjout.close();\n    \t\t}\n    \tcatch(Exception e) {\n    \t\t\tSystem.out.println(\"命令保存失败！\");\t\n    \t\t\te.printStackTrace();\n    \t    }\n\t}\n\t\n    //从日志文件中提取命令集合\n\tpublic static ArrayList readCommands() {\n\t\ttry {\n\t\t\tFileInputStream file = new FileInputStream(\"config.log\");\n\t\t\t//创建对象输入流用于从文件中读取对象\n    \t\tObjectInputStream objin = new ObjectInputStream(new BufferedInputStream(file));\n\t\t\t\n\t\t\t//将文件中的对象读出并转换为ArrayList类型\n    \t\tArrayList commands = (ArrayList)objin.readObject();\n    \t\tobjin.close();\n    \t\treturn commands;\n    \t\t}\n    \tcatch(Exception e) {\n    \t\t\tSystem.out.println(\"命令读取失败！\");\n    \t\t\te.printStackTrace();\n    \t\t\treturn null;\t\n    \t    }\t\t\n\t}\n}\n```\n\n编写如下客户端测试代码：\n\n```\nclass Client {\n\tpublic static void main(String args[]) {\n\t\tConfigSettingWindow csw = new ConfigSettingWindow(); //定义请求发送者\n\t\tCommand command; //定义命令对象\n\t\tConfigOperator co = new ConfigOperator(); //定义请求接收者\n\t\t\n        //四次对配置文件的更改\n\t\tcommand = new InsertCommand(\"增加\");\n\t\tcommand.setConfigOperator(co);\n\t\tcsw.setCommand(command);\n\t\tcsw.call(\"网站首页\");\n\t\t\n\t\tcommand = new InsertCommand(\"增加\");\n\t\tcommand.setConfigOperator(co);\n\t\tcsw.setCommand(command);\n\t\tcsw.call(\"端口号\");\n\t\t\n\t\tcommand = new ModifyCommand(\"修改\");\n\t\tcommand.setConfigOperator(co);\n\t\tcsw.setCommand(command);\n\t\tcsw.call(\"网站首页\");\n\t\t\n\t\tcommand = new ModifyCommand(\"修改\");\n\t\tcommand.setConfigOperator(co);\n\t\tcsw.setCommand(command);\t\t\n\t\tcsw.call(\"端口号\");\n\t\t\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println(\"保存配置\");\n\t\tcsw.save();\n\t\t\t\n\t\tSystem.out.println(\"----------------------------\");\t\n\t\tSystem.out.println(\"恢复配置\");\n\t\tSystem.out.println(\"----------------------------\");\t\n\t\tcsw.recover();\t\n\t}\n}\n```\n\n编译并运行程序，输出结果如下：\n\n```\n增加新节点：网站首页\n\n增加新节点：端口号\n\n修改节点：网站首页\n\n修改节点：端口号\n\n----------------------------\n\n保存配置\n\n----------------------------\n\n恢复配置\n\n----------------------------\n\n增加新节点：网站首页\n\n增加新节点：端口号\n\n修改节点：网站首页\n\n修改节点：端口号\n```\n\n# 宏命令\n\n**宏命令(Macro Command)又称为组合命令，它是组合模式和命令模式联用的产物**。宏命令是一个具体命令类，它拥有一个集合属性，在该集合中包含了对其他命令对象的引用。**通常宏命令不直接与请求接收者交互，而是通过它的成员来调用接收者的方法**。当调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法，一个宏命令的成员可以是简单命令，还可以继续是宏命令。**执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理**，其结构如图7所示：\n\n\n![图7  宏命令结构图](/images/design-pattern/command-7.jpeg)\n\n# 总结\n\n命令模式是一种使用频率非常高的设计模式，它可以将请求发送者与接收者解耦，请求发送者通过命令对象来间接引用请求接收者，使得系统具有更好的灵活性和可扩展性。在基于GUI的软件开发，无论是在电脑桌面应用还是在移动应用中，命令模式都得到了广泛的应用。\n\n* **主要优点**\n\n    1. **降低系统的耦合度**。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。\n\n    2. **新的命令可以很容易地加入到系统中**。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。\n\n    3. **可以比较容易地设计一个命令队列或宏命令（组合命令）**。\n\n    4. **为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案**。\n\n* **主要缺点**\n\n    1. **使用命令模式可能会导致某些系统有过多的具体命令类**。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。\n\n* **适用场景**\n\n    1. 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。\n\n    2. 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。\n\n    3. 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。\n\n    4. 系统需要将一组操作组合在一起形成宏命令。\n\n>练习: Sunny软件公司欲开发一个基于Windows平台的公告板系统。该系统提供了一个主菜单(Menu)，在主菜单中包含了一些菜单项(MenuItem)，可以通过Menu类的addMenuItem()方法增加菜单项。菜单项的主要方法是click()，每一个菜单项包含一个抽象命令类，具体命令类包括OpenCommand(打开命令)，CreateCommand(新建命令)，EditCommand(编辑命令)等，命令类具有一个execute()方法，用于调用公告板系统界面类(BoardScreen)的open()、create()、edit()等方法。试使用命令模式设计该系统，以便降低MenuItem类与BoardScreen类之间的耦合度。\n\n\n[原文: http://wiki.jikexueyuan.com/project/design-pattern-behavior/command-one.html]\n\n","categories":["设计模式"]},{"title":"设计模式-职责链模式","url":"/2017/04/08/design-pattern/design-pattern-chain/","content":"\n“一对二”，“过”，“过”……这声音熟悉吗？你会想到什么？对！纸牌。在类似“斗地主”这样的纸牌游戏中，某人出牌给他的下家，下家看看手中的牌，如果要不起上家的牌则将出牌请求再转发给他的下家，其下家再进行判断。一个循环下来，如果其他人都要不起该牌，则最初的出牌者可以打出新的牌。在这个过程中，牌作为一个请求沿着一条链在传递，每一位纸牌的玩家都可以处理该请求。在设计模式中，我们也有一种专门用于处理这种请求链式传递的模式，它就是本章将要介绍的职责链模式。\n\n<!-- more -->\n\n# 采购单的分级审批\n\nSunny软件公司承接了某企业SCM(Supply Chain Management，供应链管理)系统的开发任务，其中包含一个采购审批子系统。该企业的采购审批是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批，主任可以审批5万元以下（不包括5万元）的采购单，副董事长可以审批5万元至10万元（不包括10万元）的采购单，董事长可以审批10万元至50万元（不包括50万元）的采购单，50万元及以上的采购单就需要开董事会讨论决定。如图16-1所示：\n\n![](/images/design-pattern/chain-1.gif)\n\n\n如何在软件中实现采购单的分级审批？Sunny软件公司开发人员提出了一个初始解决方案，在系统中提供一个采购单处理类PurchaseRequestHandler用于统一处理采购单，其框架代码如下所示：\n\n```\n//采购单处理类\nclass PurchaseRequestHandler {\n\t//递交采购单给主任\n\tpublic void sendRequestToDirector(PurchaseRequest request) {\n\t\tif (request.getAmount() < 50000) {\n\t\t\t//主任可审批该采购单\n\t\t\tthis.handleByDirector(request);\n\t\t}\n\t\telse if (request.getAmount() < 100000) {\n\t\t\t//副董事长可审批该采购单\n\t\t\tthis.handleByVicePresident(request);\n\t\t}\n\t\telse if (request.getAmount() < 500000) {\n\t\t\t//董事长可审批该采购单\n\t\t\tthis.handleByPresident(request);\n\t\t}\n\t\telse {\n\t\t\t//董事会可审批该采购单\n\t\t\tthis.handleByCongress(request);\n\t\t}\n\t}\n\t\n\t//主任审批采购单\n\tpublic void handleByDirector(PurchaseRequest request) {\n\t\t//代码省略\n\t}\n\t\n\t//副董事长审批采购单\n\tpublic void handleByVicePresident(PurchaseRequest request) {\n\t\t//代码省略\n\t}\n\t\n\t//董事长审批采购单\n\tpublic void handleByPresident(PurchaseRequest request) {\n\t\t//代码省略\n\t}\n\t\n\t//董事会审批采购单\n\tpublic void handleByCongress(PurchaseRequest request) {\n\t\t//代码省略\n\t}\n}\n```\n\n问题貌似很简单，但仔细分析，发现上述方案存在如下几个问题：\n\n1. PurchaseRequestHandler类较为庞大，各个级别的审批方法都集中在一个类中，违反了“单一职责原则”，测试和维护难度大。\n2. 如果需要增加一个新的审批级别或调整任何一级的审批金额和审批细节（例如将董事长的审批额度改为60万元）时都必须修改源代码并进行严格测试，此外，如果需要移除某一级别（例如金额为10万元及以上的采购单直接由董事长审批，不再设副董事长一职）时也必须对源代码进行修改，违反了“开闭原则”。\n3. 审批流程的设置缺乏灵活性，现在的审批流程是“主任-->副董事长-->董事长-->董事会”，如果需要改为“主任-->董事长-->董事会”，在此方案中只能通过修改源代码来实现，客户端无法定制审批流程。\n\n如何针对上述问题对系统进行改进？Sunny公司开发人员迫切需要一种新的设计方案，还好有职责链模式，通过使用职责链模式我们可以最大程度地解决这些问题，下面让我们正式进入职责链模式的学习。\n\n# 职责链模式概述\n\n很多情况下，在一个软件系统中可以处理某个请求的对象不止一个，例如SCM系统中的采购单审批，主任、副董事长、董事长和董事会都可以处理采购单，他们可以构成一条处理采购单的链式结构，采购单沿着这条链进行传递，这条链就称为职责链。职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现请求发送者和请求处理者解耦。\n\n职责链模式定义如下：\n\n>职责链模式(Chain of Responsibility  Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。\n\n职责链模式结构的核心在于引入了一个抽象处理者。职责链模式结构如图16-2所示：\n\n![](/images/design-pattern/chain-2.gif)\n\n在职责链模式结构图中包含如下几个角色：\n\n* **Handler（抽象处理者）**：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor），作为其对下家的引用。通过该引用，处理者可以连成一条链。\n\n* **ConcreteHandler（具体处理者）**：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。\n\n在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在**不影响客户端的情况下动态地重新组织链和分配责任**。\n\n职责链模式的核心在于抽象处理者类的设计，抽象处理者的典型代码如下所示：\n\n```\nabstract class Handler {\n//维持对下家的引用\nprotected Handler successor;\n\t\n\tpublic void setSuccessor(Handler successor) {\n\t\tthis.successor=successor;\n\t}\n\t\n\tpublic abstract void handleRequest(String request);\n}\n```\n\n上述代码中，抽象处理者类定义了对下家的引用对象，以便将请求转发给下家，该对象的访问符可设为protected，在其子类中可以使用。在抽象处理者类中声明了抽象的请求处理方法，具体实现交由子类完成。\n\n具体处理者是抽象处理者的子类，它具有两大作用：**第一是处理请求**，不同的具体处理者以不同的形式实现抽象请求处理方法handleRequest()；**第二是转发请求**，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。具体处理者类的典型代码如下\n\n```\nclass ConcreteHandler extends Handler {\n\tpublic void handleRequest(String request) {\n\t\tif (请求满足条件) {\n\t\t\t//处理请求\n\t\t}\n\t\telse {\n\t\t\tthis.successor.handleRequest(request);  //转发请求\n\t\t}\n\t}\n}\n```\n\n在具体处理类中通过对请求进行判断可以做出相应的处理。\n\n需要注意的是，**职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链**。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。\n\n>思考：如何在客户端创建一条职责链？\n\n# 完整解决方案\n\n为了让采购单的审批流程更加灵活，并实现采购单的链式传递和处理，Sunny公司开发人员使用职责链模式来实现采购单的分级审批，其基本结构如图16-3所示：\n\n![](/images/design-pattern/chain-3.gif)\n\n在图16-3中，抽象类Approver充当抽象处理者（抽象传递者），Director、VicePresident、President和Congress充当具体处理者（具体传递者），PurchaseRequest充当请求类。完整代码如下所示：\n\n```\n//采购单：请求类\nclass PurchaseRequest {\n\tprivate double amount;  //采购金额\n\tprivate int number;  //采购单编号\n\tprivate String purpose;  //采购目的\n\t\n\tpublic PurchaseRequest(double amount, int number, String purpose) {\n\t\tthis.amount = amount;\n\t\tthis.number = number;\n\t\tthis.purpose = purpose;\n\t}\n\t\n\tpublic void setAmount(double amount) {\n\t\tthis.amount = amount;\n\t}\n\t\n\tpublic double getAmount() {\n\t\treturn this.amount;\n\t}\n\t\n\tpublic void setNumber(int number) {\n\t\tthis.number = number;\n\t}\n\t\n\tpublic int getNumber() {\n\t\treturn this.number;\n\t}\n\t\n\tpublic void setPurpose(String purpose) {\n\t\tthis.purpose = purpose;\n\t}\n\t\n\tpublic String getPurpose() {\n\t\treturn this.purpose;\n\t}\n}\n\n//审批者类：抽象处理者\nabstract class Approver {\n\tprotected Approver successor; //定义后继对象\n\tprotected String name; //审批者姓名\n\t\n\tpublic Approver(String name) {\n\t\tthis.name = name;\n\t}\n\n\t//设置后继者\n\tpublic void setSuccessor(Approver successor) { \n\t\tthis.successor = successor;\n\t}\n\n    //抽象请求处理方法\n    public abstract void processRequest(PurchaseRequest request);\n}\n\n//主任类：具体处理者\nclass Director extends Approver {\n\tpublic Director(String name) {\n\t\tsuper(name);\n\t}\n\t\n    //具体请求处理方法\n \tpublic void processRequest(PurchaseRequest request) {\n \t\tif (request.getAmount() < 50000) {\n \t\t\tSystem.out.println(\"主任\" + this.name + \"审批采购单：\" + request.getNumber() + \"，金额：\" + request.getAmount() + \"元，采购目的：\" + request.getPurpose() + \"。\");  //处理请求\n \t\t}\n \t\telse {\n \t\t\tthis.successor.processRequest(request);  //转发请求\n \t\t}\t\n \t}\n}\n\n//副董事长类：具体处理者\nclass VicePresident extends Approver {\n\tpublic VicePresident(String name) {\n\t\tsuper(name);\n\t}\n\t\n    //具体请求处理方法\n \tpublic void processRequest(PurchaseRequest request) {\n \t\tif (request.getAmount() < 100000) {\n \t\t\tSystem.out.println(\"副董事长\" + this.name + \"审批采购单：\" + request.getNumber() + \"，金额：\" + request.getAmount() + \"元，采购目的：\" + request.getPurpose() + \"。\");  //处理请求\n \t\t}\n \t\telse {\n \t\t\tthis.successor.processRequest(request);  //转发请求\n \t\t}\t\n \t}\n}\n\n//董事长类：具体处理者\nclass President extends Approver {\n\tpublic President(String name) {\n\t\tsuper(name);\n\t}\n\t\n    //具体请求处理方法\n \tpublic void processRequest(PurchaseRequest request) {\n \t\tif (request.getAmount() < 500000) {\n \t\t\tSystem.out.println(\"董事长\" + this.name + \"审批采购单：\" + request.getNumber() + \"，金额：\" + request.getAmount() + \"元，采购目的：\" + request.getPurpose() + \"。\");  //处理请求\n \t\t}\n \t\telse {\n \t\t\tthis.successor.processRequest(request);  //转发请求\n \t\t}\n \t}\n}\n\n//董事会类：具体处理者\nclass Congress extends Approver {\n\tpublic Congress(String name) {\n\t\tsuper(name);\n\t}\n\t\n    //具体请求处理方法\n \tpublic void processRequest(PurchaseRequest request) {\n \t\tSystem.out.println(\"召开董事会审批采购单：\" + request.getNumber() + \"，金额：\" + request.getAmount() + \"元，采购目的：\" + request.getPurpose() + \"。\");\t    //处理请求\n \t}    \n}\n```\n\n编写如下客户端测试代码： \n\n```\nclass Client {\n\tpublic static void main(String[] args) {\n\t\tApprover wjzhang,gyang,jguo,meeting;\n\t\twjzhang = new Director(\"张无忌\");\n\t\tgyang = new VicePresident(\"杨过\");\n\t\tjguo = new President(\"郭靖\");\n\t\tmeeting = new Congress(\"董事会\");\n\t\n\t\t//创建职责链\n\t\twjzhang.setSuccessor(gyang);\n\t\tgyang.setSuccessor(jguo);\n\t\tjguo.setSuccessor(meeting);\n\t\t\n\t\t//创建采购单\n\t\tPurchaseRequest pr1 = new PurchaseRequest(45000,10001,\"购买倚天剑\");\n\t\twjzhang.processRequest(pr1);\n\t\t\n\t\tPurchaseRequest pr2 = new PurchaseRequest(60000,10002,\"购买《葵花宝典》\");\n\t\twjzhang.processRequest(pr2);\n\t\n\t\tPurchaseRequest pr3 = new PurchaseRequest(160000,10003,\"购买《金刚经》\");\n\t\twjzhang.processRequest(pr3);\n\n\t\tPurchaseRequest pr4 = new PurchaseRequest(800000,10004,\"购买桃花岛\");\n\t\twjzhang.processRequest(pr4);\n\t}\n} \n```\n\n编译并运行程序，输出结果如下：\n\n```\n主任张无忌审批采购单：10001，金额：45000.0元，采购目的：购买倚天剑。\n\n副董事长杨过审批采购单：10002，金额：60000.0元，采购目的：购买《葵花宝典》。\n\n董事长郭靖审批采购单：10003，金额：160000.0元，采购目的：购买《金刚经》。\n\n召开董事会审批采购单：10004，金额：800000.0元，采购目的：购买桃花岛。\n```\n\n如果需要在系统增加一个新的具体处理者，如增加一个经理(Manager)角色可以审批5万元至8万元（不包括8万元）的采购单，需要编写一个新的具体处理者类Manager，作为抽象处理者类Approver的子类，实现在Approver类中定义的抽象处理方法，如果采购金额大于等于8万元，则将请求转发给下家，代码如下所示：\n\n```\n//经理类：具体处理者\nclass Manager extends Approver {\n\tpublic Manager(String name) {\n\t\tsuper(name);\n\t}\n\t\n    //具体请求处理方法\n \tpublic void processRequest(PurchaseRequest request) {\n \t\tif (request.getAmount() < 80000) {\n \t\t\tSystem.out.println(\"经理\" + this.name + \"审批采购单：\" + request.getNumber() + \"，金额：\" + request.getAmount() + \"元，采购目的：\" + request.getPurpose() + \"。\");  //处理请求\n \t\t}\n \t\telse {\n \t\t\tthis.successor.processRequest(request);  //转发请求\n \t\t}\t\n \t}\n}\n```\n\n由于链的创建过程由客户端负责，因此增加新的具体处理者类对原有类库无任何影响，无须修改已有类的源代码，符合“开闭原则”。\n\n在客户端代码中，如果要将新的具体请求处理者应用在系统中，需要创建新的具体处理者对象，然后将该对象加入职责链中。如在客户端测试代码中增加如下代码：\n\n```\nApprover rhuang;\nrhuang = new Manager(\"黄蓉\");\n```\n\n将建链代码改为：\n\n```\n//创建职责链\nwjzhang.setSuccessor(rhuang); //将“黄蓉”作为“张无忌”的下家\nrhuang.setSuccessor(gyang); //将“杨过”作为“黄蓉”的下家\ngyang.setSuccessor(jguo);\njguo.setSuccessor(meeting);\n```\n\n重新编译并运行程序，输出结果如下：\n\n```\n主任张无忌审批采购单：10001，金额：45000.0元，采购目的：购买倚天剑。\n\n经理黄蓉审批采购单：10002，金额：60000.0元，采购目的：购买《葵花宝典》。\n\n董事长郭靖审批采购单：10003，金额：160000.0元，采购目的：购买《金刚经》。\n\n召开董事会审批采购单：10004，金额：800000.0元，采购目的：购买桃花岛。\n```\n\n>思考：如果将审批流程由“主任-->副董事长-->董事长-->董事会”调整为“主任-->董事长-->董事会”，系统将做出哪些改动？预测修改之后客户端代码的输出结果。\n\n# 纯与不纯的职责链模式\n\n职责链模式可分为纯的职责链模式和不纯的职责链模式两种：\n\n* 纯的职责链模式\n\n一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：**要么承担全部责任，要么将责任推给下家**，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，**要求一个请求必须被某一个处理者对象所接收**，不能出现某个请求未被任何一个处理者对象处理的情况。在前面的采购单审批实例中应用的是纯的职责链模式。\n\n* 不纯的职责链模式\n\n在一个不纯的职责链模式中**允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收**。Java AWT 1.0中的事件处理模型应用的是不纯的职责链模式，其基本原理如下：由于窗口组件（如按钮、文本框等）一般都位于容器组件中，因此当事件发生在某一个组件上时，先通过组件对象的handleEvent()方法将事件传递给相应的事件处理方法，该事件处理方法将处理此事件，然后决定是否将该事件向上一级容器组件传播；上级容器组件在接到事件之后可以继续处理此事件并决定是否继续向上级容器组件传播，如此反复，直到事件到达顶层容器组件为止；如果一直传到最顶层容器仍没有处理方法，则该事件不予处理。**每一级组件在接收到事件时，都可以处理此事件，而不论此事件是否在上一级已得到处理，还存在事件未被处理的情况**。显然，这就是不纯的职责链模式，早期的Java AWT事件模型(JDK 1.0及更早)中的这种事件处理机制又叫**事件浮升(Event Bubbling)机制**。从Java.1.1以后，JDK使用观察者模式代替职责链模式来处理事件。目前，在JavaScript中仍然可以使用这种事件浮升机制来进行事件处理。\n\n# 总结\n\n职责链模式通过建立一条链来组织请求的处理者，请求将沿着链进行传递，请求发送者无须知道请求在何时、何处以及如何被处理，实现了请求发送者与处理者的解耦。在软件开发中，如果遇到有多个对象可以处理同一请求时可以应用职责链模式，例如在Web应用开发中创建一个**过滤器(Filter)链**来对请求数据进行过滤，在工作流系统中实现公文的分级审批等等，使用职责链模式可以较好地解决此类问题。\n\n\n* **主要优点**\n\n    1. 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。\n\n    2. 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。\n\n    3. 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。\n\n    4. 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。\n\n* **主要缺点**\n\n    1. 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。\n\n    2. 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。\n\n    3. 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。\n\n\n* **适用场景**\n\n    1. 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。\n\n    2. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。\n\n    3. 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 \n\n>练习：Sunny软件公司的OA系统需要提供一个假条审批模块：如果员工请假天数小于3天，主任可以审批该假条；如果员工请假天数大于等于3天，小于10天，经理可以审批；如果员工请假天数大于等于10天，小于30天，总经理可以审批；如果超过30天，总经理也不能审批，提示相应的拒绝信息。试用职责链模式设计该假条审批模块。\n\n\n[原文: http://wiki.jikexueyuan.com/project/design-pattern-behavior/chain-one.html]\n\n","categories":["设计模式"]},{"title":"设计模式-目录","url":"/2017/04/08/design-pattern/design-pattern-catalogue/","content":"\n### 创建型模式\n\n* [简单工厂模式 (Simple Factory Pattern)](http://blog.devjackcat.com/2017/04/10/design-pattern/design-pattern-simple-factory/)\n* [工厂方法模式 (Factory Method Pattern)](http://blog.devjackcat.com/2017/04/10/design-pattern/design-pattern-factory-method/)\n* 抽象工厂模式 (Abstract  Factory Pattern)\n* 单例模式 (Singleton Pattern)\n* 原型模式 (Prototype Pattern)\n* 建造者模式 (Builder Pattern)\n\n<!-- more -->\n\n### 结构型模式\n\n* 适配器模式 (Adapter Pattern)\n* 桥接模式 (Bridge Pattern)\n* 组合模式 (Composite Pattern)\n* 装饰模式 (Decorator Pattern)\n* 外观模式 (Facade Pattern)\n* 享元模式 (Flyweight Pattern)\n* 代理模式 (Proxy Pattern)\n\n### 行为型模式\n\n* [职责链模式 (Chain of Responsibility Pattern)](http://blog.devjackcat.com/2017/04/08/design-pattern-chain/)\n* [命令模式 (Command Pattern)](http://blog.devjackcat.com/2017/04/08/design-pattern-command/)\n* 解释器模式 (Interpreter Pattern)\n* 迭代器模式 (Iterator Pattern)\n* 中介者模式 (Mediator Pattern)\n* 备忘录模式 (Memento Pattern)\n* 观察者模式 (Observer Pattern)\n* 状态模式 (State Pattern)\n* 策略模式 (Strategy Pattern)\n* 模板方法 (Template Method Pattern)\n* 访问模式 (Visitor Pattern)\n\n### 设计模式趣味学习 (复习)\n\n* 设计模式与足球(一):创建型模式\n* 设计模式与足球(二):结构型模式\n* 设计模式与足球(三):行为型模式(上)\n* 设计模式与足球(四):行为型模式(下)\n\n### 设计模式综合应用实例\n\n#### 多人联机设计游戏\n\n* 多人联机射击游戏中的设计模式应用（一）：抽象工厂模式，建造者模式，工厂方法模式，迭代器模式，命令模式\n* 多人联机射击游戏中的设计模式应用（二）：观察者模式，单例模式，状态模式，适配器模式\n\n#### 数据库同步系统\n\n* 设计模式综合实例分析之数据库同步系统（一）：数据库同步系统概述，建造者模式，简单工厂模式\n* 设计模式综合实例分析之数据库同步系统（二）：享元模式，单例模式，观察者模式，模板方法模式\n* 设计模式综合实例分析之数据库同步系统（三）：策略模式，组合模式，命令模式，职责链模式\n\n\n[ 作者：刘伟  http://blog.csdn.net/lovelion/article/details/17517213 ]\n\n","categories":["设计模式"]},{"title":"核心动画-视觉效果","url":"/2017/04/08/ios-core-animation/ios-core-animation-chapter-4/","content":"\n# 前言\n\n>嗯，圆和椭圆还不错，但如果是带圆角的矩形呢？\n我们现在能做到那样了么？\n史蒂芬·乔布斯\n\n我们在第三章『图层几何学』中讨论了图层的frame，第二章『寄宿图』则讨论了图层的寄宿图。但是图层不仅仅可以是图片或是颜色的容器；还有一系列内建的特性使得创造美丽优雅的令人深刻的界面元素成为可能。在这一章，我们将会探索一些能够通过使用CALayer属性实现的视觉效果。\n\n<!-- more -->\n\n# 圆角\n\n圆角矩形是iOS的一个标志性审美特性。这在iOS的每一个地方都得到了体现，不论是主屏幕图标，还是警告弹框，甚至是文本框。按照这流行程度，你可能会认为一定有不借助Photoshop就能轻易创建圆角举行的方法。恭喜你，猜对了。\n\nCALayer有一个叫做conrnerRadius的属性控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角），但是你可以把它设置成任意值。默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层。不过，如果把masksToBounds设置成YES的话，图层里面的所有东西都会被截取。\n\n我们可以通过一个简单的项目来演示这个效果。在Interface Builder中，我们放置一些视图，他们有一些子视图。而且这些子视图有一些超出了边界（如图4.1）。你可能无法看到他们超出了边界，因为在编辑界面的时候，超出的部分总是被Interface Builder裁切掉了。不过，你相信我就好了 :)\n\n\n![图4.1 两个白色的大视图，他们都包含了小一些的红色视图。](/images/ios-core-animation/4.1.png)\n\n然后在代码中，我们设置角的半径为20个点，并裁剪掉第一个视图的超出部分（见清单4.1）。技术上来说，这些属性都可以在Interface Builder的探测板中分别通过『用户定义运行时属性』和勾选『裁剪子视图』(Clip Subviews)选择框来直接设置属性的值。不过，在这个示例中，代码能够表示得更清楚。图4.2是运行代码的结果\n\n清单4.1 设置cornerRadius和masksToBounds\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *layerView1;\n@property (nonatomic, weak) IBOutlet UIView *layerView2;\n\n@end\n\n@implementation ViewController\n- (void)viewDidLoad\n{\n  [super viewDidLoad];\n\n  //set the corner radius on our layers\n  self.layerView1.layer.cornerRadius = 20.0f;\n  self.layerView2.layer.cornerRadius = 20.0f;\n\n  //enable clipping on the second layer\n  self.layerView2.layer.masksToBounds = YES;\n}\n@end\n```\n\n![图4.1 两个白色的大视图，他们都包含了小一些的红色视图。](/images/ios-core-animation/4.2.png)\n\n右图中，红色的子视图沿角半径被裁剪了\n\n如你所见，右边的子视图沿边界被裁剪了。\n\n单独控制每个层的圆角曲率也不是不可能的。如果想创建有些圆角有些直角的图层或视图时，你可能需要一些不同的方法。比如使用一个图层蒙板（本章稍后会讲到）或者是CAShapeLayer（见第六章『专用图层』）。\n\n# 圆角边框\n\nCALayer另外两个非常有用属性就是borderWidth和borderColor。二者共同定义了图层边的绘制样式。这条线（也被称作stroke）沿着图层的bounds绘制，同时也包含图层的角。\n\nborderWidth是以点为单位的定义边框粗细的浮点数，默认为0.borderColor定义了边框的颜色，默认为黑色。\n\nborderColor是CGColorRef类型，而不是UIColor，所以它不是Cocoa的内置对象。不过呢，你肯定也清楚图层引用了borderColor，虽然属性声明并不能证明这一点。CGColorRef在引用/释放时候的行为表现得与NSObject极其相似。但是Objective-C语法并不支持这一做法，所以CGColorRef属性即便是强引用也只能通过assign关键字来声明。\n\n边框是绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前。如果我们在之前的示例中（清单4.2）加入图层的边框，你就能看到到底是怎么一回事了（如图4.3）.\n\n清单4.2 加上边框\n\n```\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n  [super viewDidLoad];\n\n  //set the corner radius on our layers\n  self.layerView1.layer.cornerRadius = 20.0f;\n  self.layerView2.layer.cornerRadius = 20.0f;\n\n  //add a border to our layers\n  self.layerView1.layer.borderWidth = 5.0f;\n  self.layerView2.layer.borderWidth = 5.0f;\n\n  //enable clipping on the second layer\n  self.layerView2.layer.masksToBounds = YES;\n}\n\n@end\n```\n\n![图4.3 给图层增加一个边框](/images/ios-core-animation/4.3.png)\n\n仔细观察会发现边框并不会把寄宿图或子图层的形状计算进来，如果图层的子图层超过了边界，或者是寄宿图在透明区域有一个透明蒙板，边框仍然会沿着图层的边界绘制出来（如图4.4）.\n\n![图4.4 边框是跟随图层的边界变化的，而不是图层里面的内容](/images/ios-core-animation/4.4.png)\n\n# 阴影\n\niOS的另一个常见特性呢，就是阴影。阴影往往可以达到图层深度暗示的效果。也能够用来强调正在显示的图层和优先级（比如说一个在其他视图之前的弹出框），不过有时候他们只是单纯的装饰目的。\n\n给shadowOpacity属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下。shadowOpacity是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。如果设置为1.0，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。若要改动阴影的表现，你可以使用CALayer的另外三个属性：shadowColor，shadowOffset和shadowRadius。\n\n显而易见，shadowColor属性控制着阴影的颜色，和borderColor和backgroundColor一样，它的类型也是CGColorRef。阴影默认是黑色，大多数时候你需要的阴影也是黑色的（其他颜色的阴影看起来是不是有一点点奇怪。。）。\n\nshadowOffset属性控制着阴影的方向和距离。它是一个CGSize的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。shadowOffset的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。\n\n为什么要默认向上的阴影呢？尽管Core Animation是从图层套装演变而来（可以认为是为iOS创建的私有动画框架），但是呢，它却是在Mac OS上面世的，前面有提到，二者的Y轴是颠倒的。这就导致了默认的3个点位移的阴影是向上的。在Mac上，shadowOffset的默认值是阴影向下的，这样你就能理解为什么iOS上的阴影方向是向上的了（如图4.5）.\n\n![图4.5 在iOS（左）和Mac OS（右）上shadowOffset的表现。](/images/ios-core-animation/4.5.png)\n\n苹果更倾向于用户界面的阴影应该是垂直向下的，所以在iOS把阴影宽度设为0，然后高度设为一个正值不失为一个做法。\n\nshadowRadius属性控制着阴影的*模糊度*，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。苹果自家的应用设计更偏向于自然的阴影，所以一个非零值再合适不过了。\n\n通常来讲，如果你想让视图或控件非常醒目独立于背景之外（比如弹出框遮罩层），你就应该给shadowRadius设置一个稍大的值。阴影越模糊，图层的深度看上去就会更明显（如图4.6）.\n\n![](/images/ios-core-animation/4.6.png)\n\n## 阴影裁剪\n\n和图层边框不同，图层的阴影继承自内容的外形，而不是根据边界和角半径来确定。为了计算出阴影的形状，Core Animation会将寄宿图（包括子视图，如果有的话）考虑在内，然后通过这些来完美搭配图层形状从而创建一个阴影（见图4.7）。\n\n![图4.7 阴影是根据寄宿图的轮廓来确定的](/images/ios-core-animation/4.7.png)\n\n当阴影和裁剪扯上关系的时候就有一个头疼的限制：阴影通常就是在Layer的边界之外，如果你开启了masksToBounds属性，所有从图层中突出来的内容都会被才剪掉。如果我们在我们之前的边框示例项目中增加图层的阴影属性时，你就会发现问题所在（见图4.8）.\n\n![图4.8 maskToBounds属性裁剪掉了阴影和内容](/images/ios-core-animation/4.8.png)\n\n从技术角度来说，这个结果是可以是可以理解的，但确实又不是我们想要的效果。如果你想沿着内容裁切，你需要用到两个图层：一个只画阴影的空的外图层，和一个用masksToBounds裁剪内容的内图层。\n\n如果我们把之前项目的右边用单独的视图把裁剪的视图包起来，我们就可以解决这个问题（如图4.9）\n\n![图4.9 右边，用额外的阴影转换视图包裹被裁剪的视图](/images/ios-core-animation/4.9.png)\n\n我们只把阴影用在最外层的视图上，内层视图进行裁剪。清单4.3是代码实现，图4.10是运行结果。\n\n清单4.3 用一个额外的视图来解决阴影裁切的问题\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *layerView1;\n@property (nonatomic, weak) IBOutlet UIView *layerView2;\n@property (nonatomic, weak) IBOutlet UIView *shadowView;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n  [super viewDidLoad];\n\n  //set the corner radius on our layers\n  self.layerView1.layer.cornerRadius = 20.0f;\n  self.layerView2.layer.cornerRadius = 20.0f;\n\n  //add a border to our layers\n  self.layerView1.layer.borderWidth = 5.0f;\n  self.layerView2.layer.borderWidth = 5.0f;\n\n  //add a shadow to layerView1\n  self.layerView1.layer.shadowOpacity = 0.5f;\n  self.layerView1.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);\n  self.layerView1.layer.shadowRadius = 5.0f;\n\n  //add same shadow to shadowView (not layerView2)\n  self.shadowView.layer.shadowOpacity = 0.5f;\n  self.shadowView.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);\n  self.shadowView.layer.shadowRadius = 5.0f;\n\n  //enable clipping on the second layer\n  self.layerView2.layer.masksToBounds = YES;\n}\n\n@end\n```\n\n![图4.10 右边视图，不受裁切阴影的阴影视图。](/images/ios-core-animation/4.10.png)\n\n## shadowPath属性\n\n我们已经知道图层阴影并不总是方的，而是从图层内容的形状继承而来。这看上去不错，但是实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候。\n\n如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个shadowPath来提高性能。shadowPath是一个CGPathRef类型（一个指向CGPath的指针）。CGPath是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。\n\n图4.11 展示了同一寄宿图的不同阴影设定。如你所见，我们使用的图形很简单，但是它的阴影可以是你想要的任何形状。清单4.4是代码实现。\n\n![图4.11 用shadowPath指定任意阴影形状](/images/ios-core-animation/4.11.png)\n\n清单4.4 创建简单的阴影形状\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *layerView1;\n@property (nonatomic, weak) IBOutlet UIView *layerView2;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n  [super viewDidLoad];\n\n  //enable layer shadows\n  self.layerView1.layer.shadowOpacity = 0.5f;\n  self.layerView2.layer.shadowOpacity = 0.5f;\n\n  //create a square shadow\n  CGMutablePathRef squarePath = CGPathCreateMutable();\n  CGPathAddRect(squarePath, NULL, self.layerView1.bounds);\n  self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);\n\n  //create a circular shadow\n  CGMutablePathRef circlePath = CGPathCreateMutable();\n  CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);\n  self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);\n}\n@end\n```\n\n如果是一个矩形或者是圆，用CGPath会相当简单明了。但是如果是更加复杂一点的图形，UIBezierPath类会更合适，它是一个由UIKit提供的在CGPath基础上的Objective-C包装类。\n\n图4.6 大一些的阴影位移和角半径会增加图层的深度即视感\n\n# 图层蒙版\n\n通过masksToBounds属性，我们可以沿边界裁剪图形；通过cornerRadius属性，我们还可以设定一个圆角。但是有时候你希望展现的内容不是在一个矩形或圆角矩形。比如，你想展示一个有星形框架的图片，又或者想让一些古卷文字慢慢渐变成背景色，而不是一个突兀的边界。\n\n使用一个32位有alpha通道的png图片通常是创建一个无矩形视图最方便的方法，你可以给它指定一个透明蒙板来实现。但是这个方法不能让你以编码的方式动态地生成蒙板，也不能让子图层或子视图裁剪成同样的形状。\n\nCALayer有一个属性叫做mask可以解决这个问题。这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，mask图层定义了父图层的部分可见区域。\n \nmask图层的Color属性是无关紧要的，真正重要的是图层的轮廓。mask属性就像是一个饼干切割机，mask图层实心的部分会被保留下来，其他的则会被抛弃。（如图4.12）\n \n如果mask图层比父图层要小，只有在mask图层里面的内容才是它关心的，除此以外的一切都会被隐藏起来。\n \n![图4.12 把图片和蒙板图层作用在一起的效果](/images/ios-core-animation/4.12.png)\n\n我们将代码演示一下这个过程，创建一个简单的项目，通过图层的mask属性来作用于图片之上。为了简便一些，我们用Interface Builder来创建一个包含UIImageView的图片图层。这样我们就只要代码实现蒙板图层了。清单4.5是最终的代码，图4.13是运行后的结果。\n\n清单4.5 应用蒙板图层\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIImageView *imageView;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n  [super viewDidLoad];\n\n  //create mask layer\n  CALayer *maskLayer = [CALayer layer];\n  maskLayer.frame = self.layerView.bounds;\n  UIImage *maskImage = [UIImage imageNamed:@\"Cone.png\"];\n  maskLayer.contents = (__bridge id)maskImage.CGImage;\n\n  //apply mask to image layer\n  self.imageView.layer.mask = maskLayer;\n}\n@end\n```\n![图4.13 使用了mask之后的UIImageView](/images/ios-core-animation/4.13.png)\n\nCALayer蒙板图层真正厉害的地方在于蒙板图不局限于静态图。任何有图层构成的都可以作为mask属性，这意味着你的蒙板可以通过代码甚至是动画实时生成。\n\n# 拉伸过滤\n\n最后我们再来谈谈minificationFilter和magnificationFilter属性。总得来讲，当我们视图显示一个图片的时候，都应该正确地显示这个图片（意即：以正确的比例和正确的1：1像素显示在屏幕上）。原因如下：\n\n* 能够显示最好的画质，像素既没有被压缩也没有被拉伸。\n* 能更好的使用内存，因为这就是所有你要存储的东西。\n* 最好的性能表现，CPU不需要为此额外的计算。\n\n不过有时候，显示一个非真实大小的图片确实是我们需要的效果。比如说一个头像或是图片的缩略图，再比如说一个可以被拖拽和伸缩的大图。这些情况下，为同一图片的不同大小存储不同的图片显得又不切实际。\n\n当图片需要显示不同的大小的时候，有一种叫做*拉伸过滤*的算法就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。\n\n事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。CALayer为此提供了三种拉伸过滤方法，他们是：\n\n* kCAFilterLinear\n* kCAFilterNearest\n* kCAFilterTrilinear\n\nminification（缩小图片）和magnification（放大图片）默认的过滤器都是kCAFilterLinear，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。\n\nkCAFilterTrilinear和kCAFilterLinear非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而\b得到最后的结果。\n\n这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题\n\n![图4.14 对于大图来说，双线性滤波和三线性滤波表现得更出色](/images/ios-core-animation/4.14.png)\n\nkCAFilterNearest是一种比较武断的方法。从名字不难看出，这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重。\n\n![图4.15 对于没有斜线的小图来说，最近过滤算法要好很多](/images/ios-core-animation/4.15.png)\n\n总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。\n\n让我们来实验一下。我们对第三章的时钟项目改动一下，用LCD风格的数字方式显示。我们用简单的像素字体（一种用像素构成字符的字体，而非矢量图形）创造数字显示方式，用图片存储起来，而且用第二章介绍过的拼合技术来显示（如图4.16）。\n\n![图4.16 一个简单的运用拼合技术显示的LCD数字风格的像素字体](/images/ios-core-animation/4.16.png)\n\n我们在Interface Builder中放置了六个视图，小时、分钟、秒钟各两个，图4.17显示了这六个视图是如何在Interface Builder中放置的。如果每个都用一个淡出的outlets对象就会显得太多了，所以我们就用了一个IBOutletCollection对象把他们和控制器联系起来，这样我们就可以以数组的方式访问视图了。清单4.6是代码实现。\n\n清单4.6 显示一个LCD风格的时钟\n\n```\n@interface ViewController ()\n\n@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *digitViews;\n@property (nonatomic, weak) NSTimer *timer;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n  [super viewDidLoad]; //get spritesheet image\n  UIImage *digits = [UIImage imageNamed:@\"Digits.png\"];\n\n  //set up digit views\n  for (UIView *view in self.digitViews) {\n    //set contents\n    view.layer.contents = (__bridge id)digits.CGImage;\n    view.layer.contentsRect = CGRectMake(0, 0, 0.1, 1.0);\n    view.layer.contentsGravity = kCAGravityResizeAspect;\n  }\n\n  //start timer\n  self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];\n\n  //set initial clock time\n  [self tick];\n}\n\n- (void)setDigit:(NSInteger)digit forView:(UIView *)view\n{\n  //adjust contentsRect to select correct digit\n  view.layer.contentsRect = CGRectMake(digit * 0.1, 0, 0.1, 1.0);\n}\n\n- (void)tick\n{\n  //convert time to hours, minutes and seconds\n  NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier: NSGregorianCalendar];\n  NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;\n  \n  NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];\n\n  //set hours\n  [self setDigit:components.hour / 10 forView:self.digitViews[0]];\n  [self setDigit:components.hour % 10 forView:self.digitViews[1]];\n\n  //set minutes\n  [self setDigit:components.minute / 10 forView:self.digitViews[2]];\n  [self setDigit:components.minute % 10 forView:self.digitViews[3]];\n\n  //set seconds\n  [self setDigit:components.second / 10 forView:self.digitViews[4]];\n  [self setDigit:components.second % 10 forView:self.digitViews[5]];\n}\n@end\n```\n\n如图4.18，这样做的确起了效果，但是图片看起来模糊了。看起来默认的kCAFilterLinear选项让我们失望了。\n\n![图4.18 一个模糊的时钟，由默认的kCAFilterLinear引起](/images/ios-core-animation/4.18.png)\n\n为了能像图4.19中那样，我们需要在for循环中加入如下代码：\n\n```\nview.layer.magnificationFilter = kCAFilterNearest;\n```\n\n![图4.19 设置了最近过滤之后的清晰显示](/images/ios-core-animation/4.19.png)\n\n# 组透明\n\nUIView有一个叫做alpha的属性来确定视图的透明度。CALayer有一个等同的属性叫做opacity，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了opacity属性，那它的子图层都会受此影响。\n\niOS常见的做法是把一个控件的alpha值设置为0.5（50%）以使其看上去呈现为不可用状态。对于独立的视图来说还不错，但是当一个控件有子视图的时候就有点奇怪了，图4.20展示了一个内嵌了UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。我们可以注意到，里面的标签的轮廓跟按钮的背景很不搭调。\n\n![图4.20 右边的渐隐按钮中，里面的标签清晰可见](/images/ios-core-animation/4.20.png)\n\n这是由透明度的混合叠加造成的，当你显示一个50%透明度的图层时，图层的每个像素都会一半显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。\n\n在我们的示例中，按钮和表情都是白色背景。虽然他们都是50%的可见度，但是合起来的可见度是75%，所以标签所在的区域看上去就没有周围的部分那么透明。所以看上去子视图就高亮了，使得这个显示效果都糟透了。\n\n理想状况下，当你设置了一个图层的透明度，你希望它包含的整个图层树像一个整体一样的透明效果。你可以通过设置Info.plist文件中的UIViewGroupOpacity为YES来达到这个效果，但是这个设置会影响到这个应用，整个app可能会受到不良影响。如果UIViewGroupOpacity并未设置，iOS 6和以前的版本会默认为NO（也许以后的版本会有一些改变）。\n \n另一个方法就是，你可以设置CALayer的一个叫做shouldRasterize属性（见清单4.7）来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了（如图4.21）。\n\n为了启用shouldRasterize属性，我们设置了图层的rasterizationScale属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了shouldRasterize属性，你就要确保你设置了rasterizationScale属性去匹配屏幕，以防止出现Retina屏幕像素化的问题。\n \n当shouldRasterize和UIViewGroupOpacity一起的时候，性能问题就出现了（我们在第12章『速度』和第15章『图层性能』将做出介绍），但是性能碰撞都本地化了（译者注：这句话需要再翻译）。\n\n清单4.7 使用shouldRasterize属性解决组透明问题\n\n```\n@interface ViewController ()\n@property (nonatomic, weak) IBOutlet UIView *containerView;\n@end\n\n@implementation ViewController\n\n- (UIButton *)customButton\n{\n  //create button\n  CGRect frame = CGRectMake(0, 0, 150, 50);\n  UIButton *button = [[UIButton alloc] initWithFrame:frame];\n  button.backgroundColor = [UIColor whiteColor];\n  button.layer.cornerRadius = 10;\n\n  //add label\n  frame = CGRectMake(20, 10, 110, 30);\n  UILabel *label = [[UILabel alloc] initWithFrame:frame];\n  label.text = @\"Hello World\";\n  label.textAlignment = NSTextAlignmentCenter;\n  [button addSubview:label];\n  return button;\n}\n\n- (void)viewDidLoad\n{\n  [super viewDidLoad];\n\n  //create opaque button\n  UIButton *button1 = [self customButton];\n  button1.center = CGPointMake(50, 150);\n  [self.containerView addSubview:button1];\n\n  //create translucent button\n  UIButton *button2 = [self customButton];\n  \n  button2.center = CGPointMake(250, 150);\n  button2.alpha = 0.5;\n  [self.containerView addSubview:button2];\n\n  //enable rasterization for the translucent button\n  button2.layer.shouldRasterize = YES;\n  button2.layer.rasterizationScale = [UIScreen mainScreen].scale;\n}\n@end\n```\n\n![图4.21 修正后的图](/images/ios-core-animation/4.21.png)\n\n# 总结\n\n这一章介绍了一些可以通过代码应用到图层上的视觉效果，比如圆角，阴影和蒙板。我们也了解了拉伸过滤器和组透明。\n\n在第五章，『变换』中，我们将会研究图层变化和3D转换\n\n","tags":["核心动画"],"categories":["iOS"]},{"title":"核心动画-图层几何学","url":"/2017/04/06/ios-core-animation/ios-core-animation-chapter-3/","content":"\n# 前言\n\n>不熟悉几何学的人就不要来这里了 --柏拉图学院入口的签名\n\n在第二章里面，我们介绍了图层背后的图片，和一些控制图层坐标和旋转的属性。在这一章中，我们将要看一看图层内部是如何根据父图层和兄弟图层来控制位置和尺寸的。另外我们也会涉及如何管理图层的几何结构，以及它是如何被自动调整和自动布局影响的。\n\n<!-- more -->\n\n# 布局\n\nUIView有三个比较重要的布局属性：frame，bounds和center，CALayer对应地叫做frame，bounds和position。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。\n\nframe代表了图层的外部坐标（也就是在父图层上占据的空间），bounds是内部坐标（{0, 0}通常是图层的左上角），center和position都代表了相对于父图层anchorPoint所在的位置。anchorPoint的属性将会在后续介绍到，现在把它想成图层的中心点就好了。图3.1显示了这些属性是如何相互依赖的。\n\n![图3.1 UIView和CALayer的坐标系](/images/ios-core-animation/3.1.jpeg)\n\n视图的frame，bounds和center属性仅仅是存取方法，当操纵视图的frame，实际上是在改变位于视图下方CALayer的frame，不能够独立于图层之外改变视图的frame\n\n对于视图或者图层来说，frame并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据bounds，position和transform计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值\n\n记住当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了（图3.2）\n\n![图3.2 旋转一个视图或者图层之后的frame属性](/images/ios-core-animation/3.2.jpeg)\n\n# 锚点\n\n之前提到过，视图的center属性和图层的position属性都指定了anchorPoint相对于父图层的位置。图层的anchorPoint通过position来控制它的frame的位置，你可以认为anchorPoint是用来移动图层的把柄。\n\n默认来说，anchorPoint位于图层的中点，所以图层的将会以这个点为中心放置。anchorPoint属性并没有被UIView接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的anchorPoint可以被移动，比如你可以把它置于图层frame的左上角，于是图层的内容将会向右下角的position方向移动（图3.3），而不是居中了。\n\n![图3.3 改变anchorPoint的效果](/images/ios-core-animation/3.3.jpeg)\n\n和第二章提到的contentsRect和contentsCenter属性类似，anchorPoint用单位坐标来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是{0.5, 0.5}。anchorPoint可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。\n\n注意在图3.3中，当改变了anchorPoint，position属性保持固定的值并没有发生改变，但是frame却移动了。\n\n那在什么场合需要改变anchorPoint呢？既然我们可以随意改变图层位置，那改变anchorPoint不会造成困惑么？为了举例说明，我们来举一个实用的例子，创建一个模拟闹钟的项目。\n\n钟面和钟表由四张图片组成（图3.4），为了简单说明，我们还是用传统的方式来装载和加载图片，使用四个UIImageView实例（当然你也可以用正常的视图，设置他们图层的contents图片）。\n\n![图3.4 组成钟面和钟表的四张图片](/images/ios-core-animation/3.4.jpeg)\n\n闹钟的组件通过IB来排列（图3.5），这些图片视图嵌套在一个容器视图之内，并且自动调整和自动布局都被禁用了。这是因为自动调整会影响到视图的frame，而根据图3.2的演示，当视图旋转的时候，frame是会发生改变的，这将会导致一些布局上的失灵。\n\n我们用NSTimer来更新闹钟，使用视图的transform属性来旋转钟表（如果你对这个属性不太熟悉，不要着急，我们将会在第5章“变换”当中详细说明），具体代码见清单3.1\n\n![图3.5 在Interface Builder中布局闹钟视图](/images/ios-core-animation/3.5.jpeg)\n\n清单3.1 Clock\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIImageView *hourHand;\n@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;\n@property (nonatomic, weak) IBOutlet UIImageView *secondHand;\n@property (nonatomic, weak) NSTimer *timer;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //start timer\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];\n                  \n    //set initial hand positions\n    [self tick];\n}\n\n- (void)tick\n{\n    //convert time to hours, minutes and seconds\n    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];\n    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;\n    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];\n    CGFloat hoursAngle = (components.hour / 12.0) * M_PI * 2.0;\n    //calculate hour hand angle //calculate minute hand angle\n    CGFloat minsAngle = (components.minute / 60.0) * M_PI * 2.0;\n    //calculate second hand angle\n    CGFloat secsAngle = (components.second / 60.0) * M_PI * 2.0;\n    //rotate hands\n    self.hourHand.transform = CGAffineTransformMakeRotation(hoursAngle);\n    self.minuteHand.transform = CGAffineTransformMakeRotation(minsAngle);\n    self.secondHand.transform = CGAffineTransformMakeRotation(secsAngle);\n}\n\n@end\n```\n\n运行项目，看起来有点奇怪（图3.6），因为钟表的图片在围绕着中心旋转，这并不是我们期待的一个支点。\n\n![图3.6 钟面，和不对齐的钟指针](/images/ios-core-animation/3.6.jpeg)\n\n你也许会认为可以在Interface Builder当中调整指针图片的位置来解决，但其实并不能达到目的，因为如果不放在钟面中间的话，同样不能正确的旋转。\n\n也许在图片末尾添加一个透明空间也是个解决方案，但这样会让图片变大，也会消耗更多的内存，这样并不优雅。\n\n更好的方案是使用anchorPoint属性，我们来在-viewDidLoad方法中添加几行代码来给每个钟指针的anchorPoint做一些平移（清单3.2），图3.7显示了正确的结果。\n\n清单3.2\n\n```\n- (void)viewDidLoad \n{\n    [super viewDidLoad];\n    // adjust anchor points\n\nself.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); \n    self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); \n    self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);\n\n    // start timer\n}\n```\n\n![图3.7 钟面，和正确对齐的钟指针](/images/ios-core-animation/3.7.jpeg)\n\n\n# 坐标系\n\n和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的position依赖于它父图层的bounds，如果父图层发生了移动，它的所有子图层也会跟着移动。\n\n这样对于放置图层会更加方便，因为你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的绝对位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。\n\nCALayer给不同坐标系之间的图层转换提供了一些工具类方法：\n\n```\n- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer;\n- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer;\n- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;\n- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;\n```\n\n这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形.\n\n## 翻转的几何结构\n\n常规说来，在iOS上，一个图层的position位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过geometryFlipped属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个BOOL类型。在iOS上通过设置它为YES意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们的geometryFlipped属性也设为YES）。\n\n### Z坐标轴\n\n和UIView严格的二维坐标系不同，CALayer存在于一个三维空间当中。除了我们已经讨论过的position和anchorPoint属性之外，CALayer还有另外两个属性，zPosition和anchorPointZ，二者都是在Z轴上描述图层位置的浮点类型。\n\n注意这里并没有更深的属性来描述由宽和高做成的bounds了，图层是一个完全扁平的对象，你可以把它们想象成类似于一页二维的坚硬的纸片，用胶水粘成一个空洞，就像三维结构的折纸一样。\n\nzPosition属性在大多数情况下其实并不常用。在第五章，我们将会涉及CATransform3D，你会知道如何在三维空间移动和旋转图层，除了做变换之外，zPosition最实用的功能就是改变图层的显示顺序了。\n\n通常，图层是根据它们子图层的sublayers出现的顺序来类绘制的，这就是所谓的画家的算法--就像一个画家在墙上作画--后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的zPosition，就可以把图层向相机方向前置，于是它就在所有其他图层的前面了（或者至少是小于它的zPosition值的图层的前面）。\n\n这里所谓的“相机”实际上是相对于用户是视角，这里和iPhone背后的内置相机没任何关系。\n\n图3.8显示了在Interface Builder内的一对视图，正如你所见，首先出现在视图层级绿色的视图被绘制在红色视图的后面。\n\n![图3.8 在视图层级中绿色视图被绘制在红色视图的后面](/images/ios-core-animation/3.8.jpeg)\n\n我们希望在真实的应用中也能显示出绘图的顺序，同样地，如果我们提高绿色视图的zPosition（清单3.3），我们会发现顺序就反了（图3.9）。其实并不需要增加太多，视图都非常地薄，所以给zPosition提高一个像素就可以让绿色视图前置，当然0.1或者0.0001也能够做到，但是最好不要这样，因为浮点类型四舍五入的计算可能会造成一些不便的麻烦。\n\n清单3.3\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *greenView;\n@property (nonatomic, weak) IBOutlet UIView *redView;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    //move the green view zPosition nearer to the camera\n    self.greenView.layer.zPosition = 1.0f;\n}\n@end\n```\n\n![图3.9 绿色视图被绘制在红色视图的前面](/images/ios-core-animation/3.9.jpeg)\n\n# Hit Testing\n\n第一章“图层树”证实了最好使用图层相关视图，而不是创建独立的图层关系。其中一个原因就是要处理额外复杂的触摸事件。\n\nCALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：-containsPoint:和-hitTest:。\n\n-containsPoint:接受一个在本图层坐标系下的CGPoint，如果这个点在图层frame范围内就返回YES。如清单3.4所示第一章的项目的另一个合适的版本，也就是使用-containsPoint:方法来判断到底是白色还是蓝色的图层被触摸了 （图3.10）。这需要把触摸坐标转换成每个图层坐标系下的坐标，结果很不方便。\n\n清单3.4 使用containsPoint判断被点击的图层\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *layerView;\n@property (nonatomic, weak) CALayer *blueLayer;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //create sublayer\n    self.blueLayer = [CALayer layer];\n    self.blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);\n    self.blueLayer.backgroundColor = [UIColor blueColor].CGColor;\n    //add it to our view\n    [self.layerView.layer addSublayer:self.blueLayer];\n}\n\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //get touch position relative to main view\n    CGPoint point = [[touches anyObject] locationInView:self.view];\n    //convert point to the white layer's coordinates\n    point = [self.layerView.layer convertPoint:point fromLayer:self.view.layer];\n    //get layer using containsPoint:\n    if ([self.layerView.layer containsPoint:point]) {\n        //convert point to blueLayer’s coordinates\n        point = [self.blueLayer convertPoint:point fromLayer:self.layerView.layer];\n        if ([self.blueLayer containsPoint:point]) {\n            [[[UIAlertView alloc] initWithTitle:@\"Inside Blue Layer\"\n                                        message:nil\n                                       delegate:nil\n                              cancelButtonTitle:@\"OK\"\n                              otherButtonTitles:nil] show];\n        } else {\n            [[[UIAlertView alloc] initWithTitle:@\"Inside White Layer\"\n                                        message:nil\n                                       delegate:nil\n                              cancelButtonTitle:@\"OK\"\n                              otherButtonTitles:nil] show];\n        }\n    }\n}\n\n@end\n```\n\n![图3.10 点击图层被正确标识](/images/ios-core-animation/3.10.jpeg)\n\n-hitTest:方法同样接受一个CGPoint类型参数，而不是BOOL类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。这意味着不再需要像使用-containsPoint:那样，人工地在每个子图层变换或者测试点击的坐标。如果这个点在最外面图层的范围之外，则返回nil。具体使用-hitTest:方法被点击图层的代码如清单3.5所示。\n\n清单3.5 使用hitTest判断被点击的图层\n\n```\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //get touch position\n    CGPoint point = [[touches anyObject] locationInView:self.view];\n    //get touched layer\n    CALayer *layer = [self.layerView.layer hitTest:point];\n    //get layer using hitTest\n    if (layer == self.blueLayer) {\n        [[[UIAlertView alloc] initWithTitle:@\"Inside Blue Layer\"\n                                    message:nil\n                                   delegate:nil\n                          cancelButtonTitle:@\"OK\"\n                          otherButtonTitles:nil] show];\n    } else if (layer == self.layerView.layer) {\n        [[[UIAlertView alloc] initWithTitle:@\"Inside White Layer\"\n                                    message:nil\n                                   delegate:nil\n                          cancelButtonTitle:@\"OK\"\n                          otherButtonTitles:nil] show];\n    }\n}\n```\n\n注意当调用图层的-hitTest:方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的zPosition属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。\n\n这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的zPosition值较小，但是在图层树中的顺序靠前。我们将在第五章详细讨论这个问题。\n\n# 自动布局\n\n你可能用过UIViewAutoresizingMask类型的一些常量，应用于当父视图改变尺寸的时候，相应UIView的frame也跟着更新的场景（通常用于横竖屏切换）。\n\n在iOS6中，苹果介绍了自动排版机制，它和自动调整不同，并且更加复杂。\n\n在Mac OS平台，CALayer有一个叫做layoutManager的属性可以通过CALayoutManager协议和CAConstraintLayoutManager类来实现自动排版的机制。但由于某些原因，这在iOS上并不适用。\n\n当使用视图的时候，可以充分利用UIView类接口暴露出来的UIViewAutoresizingMask和NSLayoutConstraintAPI，但如果想随意控制CALayer的布局，就需要手工操作。最简单的方法就是使用CALayerDelegate如下函数：\n\n```\n- (void)layoutSublayersOfLayer:(CALayer *)layer;\n```\n\n当图层的bounds发生改变，或者图层的-setNeedsLayout方法被调用的时候，这个函数将会被执行。这使得你可以手动地重新摆放或者重新调整子图层的大小，但是不能像UIView的autoresizingMask和constraints属性做到自适应屏幕旋转。\n\n这也是为什么最好使用视图而不是单独的图层来构建应用程序的另一个重要原因之一。\n\n# 总结\n\n本章涉及了CALayer的集合结构，包括它的frame，position和bounds，介绍了三维空间内图层的概念，以及如何在独立的图层内响应事件，最后简单说明了在iOS平台，Core Animation对自动调整和自动布局支持的缺乏。\n\n在第四章“视觉效果”当中，我们接着介绍一些图层外表的特性。\n\n\n","tags":["核心动画"],"categories":["iOS"]},{"title":"核心动画-寄宿图","url":"/2017/04/06/ios-core-animation/ios-core-animation-chapter-2/","content":"\n# 前言\n\n>图片胜过千言万语，界面抵得上千图片 ——Ben Shneiderman\n\n我们在第一章『图层树』中介绍了CALayer类并创建了一个简单的有蓝色背景的图层。背景颜色还好啦，但是如果它仅仅是展现了一个单调的颜色未免也太无聊了。事实上CALayer类能够包含一张你喜欢的图片，这一章节我们将来探索CALayer的寄宿图（即图层中包含的图）\n\n<!-- more -->\n\n# contents属性\n\nCALayer 有一个属性叫做contents，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给contents属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给contents赋的不是CGImage，那么你得到的图层将是空白的。\n\ncontents这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。\n\n头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个\"CGImageRef\",如果你想把这个值直接赋值给CALayer的contents，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。\n\n尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-free bridging），他们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要给图层的寄宿图赋值，你可以按照以下这个方法：\n\n```\nlayer.contents = (__bridge id)image.CGImage;\n```\n\n如果你没有使用ARC（自动引用计数），你就不需要__bridge这部分。但是，你干嘛不用ARC？！\n\n让我们来继续修改我们在第一章新建的工程，以便能够展示一张图片而不仅仅是一个背景色。我们已经用代码的方式建立一个图层，那我们就不需要额外的图层了。那么我们就直接把layerView的宿主图层的contents属性设置成图片。\n\n清单2.1 更新后的代码。\n\n```\n@implementation ViewController\n- (void)viewDidLoad\n{\n  [super viewDidLoad]; //load an image\n  UIImage *image = [UIImage imageNamed:@\"Snowman.png\"];\n\n  //add it directly to our view's layer\n  self.layerView.layer.contents = (__bridge id)image.CGImage;\n}\n@end\n```\n\n![图2.1 在UIView的宿主图层中显示一张图片](/images/ios-core-animation/2.1.png)\n\n我们用这些简单的代码做了一件很有趣的事情：我们利用CALayer在一个普通的UIView中显示了一张图片。这不是一个UIImageView，它不是我们通常用来展示图片的方法。通过直接操作图层，我们使用了一些新的函数，使得UIView更加有趣了。\n\n## contentGravity\n\n你可能已经注意到了我们的雪人看起来有点。。。胖 ＝＝！ 我们加载的图片并不刚好是一个方的，为了适应这个视图，它有一点点被拉伸了。在使用UIImageView的时候遇到过同样的问题，解决方法就是把contentMode属性设置成更合适的值，像这样：\n\n```\nview.contentMode = UIViewContentModeScaleAspectFit;\n```\n\n这个方法基本和我们遇到的情况的解决方法已经接近了（你可以试一下 :) ），不过UIView大多数视觉相关的属性比如contentMode，对这些属性的操作其实是对对应图层的操作。\n\nCALayer与contentMode对应的属性叫做contentsGravity，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。contentsGravity可选的常量值有以下一些：\n\n* kCAGravityCenter\n* kCAGravityTop\n* kCAGravityBottom\n* kCAGravityLeft\n* kCAGravityRight\n* kCAGravityTopLeft\n* kCAGravityTopRight\n* kCAGravityBottomLeft\n* kCAGravityBottomRight\n* kCAGravityResize\n* kCAGravityResizeAspect\n* kCAGravityResizeAspectFill\n\n和cotentMode一样，contentsGravity的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界\n\n```\nself.layerView.layer.contentsGravity = kCAGravityResizeAspect;\n```\n\n![图2.2](/images/ios-core-animation/2.2.png)\n\n## contentsScale\n\ncontentsScale属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。\n\ncontentsScale的目的并不是那么明显。它并不是总会对屏幕上的寄宿图有影响。如果你尝试对我们的例子设置不同的值，你就会发现根本没任何影响。因为contents由于设置了contentsGravity属性，所以它已经被拉伸以适应图层的边界。\n\n如果你只是单纯地想放大图层的contents图片，你可以通过使用图层的transform和affineTransform属性来达到这个目的（见第五章『Transforms』，里面对此有解释），这(指放大)也不是contengsScale的目的所在.\n\ncontentsScale属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置contentsGravity属性）。UIView有一个类似功能但是非常少用到的contentScaleFactor属性。\n\n如果contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。（如果你对像素和点的概念不是很清楚的话，这个章节的后面部分将会对此做出解释）。\n\n这并不会对我们在使用kCAGravityResizeAspect时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把contentsGravity设置为kCAGravityCenter（这个值并不会拉伸图片），那将会有很明显的变化\n\n\n![图2.3 用错误的contentsScale属性显示Retina图片](/images/ios-core-animation/2.3.png)\n\n如你所见，我们的雪人不仅有点大还有点像素的颗粒感。那是因为和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取我们的雪人图片的时候，他读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。不过我们可以通过手动设置contentsScale来修复这个问题\n\n清单2.2\n\n```\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n  [super viewDidLoad]; //load an image\n  UIImage *image = [UIImage imageNamed:@\"Snowman.png\"]; //add it directly to our view's layer\n  self.layerView.layer.contents = (__bridge id)image.CGImage; //center the image\n  self.layerView.layer.contentsGravity = kCAGravityCenter;\n\n  //set the contentsScale to match image\n  self.layerView.layer.contentsScale = image.scale;\n}\n\n@end\n```\n\n![图2.4 同样的Retina图片设置了正确的contentsScale之后](/images/ios-core-animation/2.4.png)\n\n当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的contentsScale属性，否则，你的图片在Retina设备上就显示得不正确啦。代码如下：\n\n```\nlayer.contentsScale = [UIScreen mainScreen].scale;\n```\n\n## maskToBounds\n\n现在我们的雪人总算是显示了正确的大小，不过你也许已经发现了另外一些事情：他超出了视图的边界。默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。\n\nUIView有一个叫做clipsToBounds的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做masksToBounds，把它设置为YES，雪人就在边界里啦～\n\n![图2.5 使用masksToBounds来修建图层内容](/images/ios-core-animation/2.5.png)\n\n## contentsRect\n\nCALayer的contentsRect属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比contentsGravity灵活多了\n\n和bounds，frame不同，contentsRect不是按点来计算的，它使用了单位坐标，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。iOS使用了以下的坐标系统：\n\n* 点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。\n* 像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。\n* 单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。\n\n默认的contentsRect是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪（如图2.6）\n\n![图2.6 一个自定义的contentsRect（左）和之前显示的内容（右）](/images/ios-core-animation/2.6.png)\n\n事实上给contentsRect设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。\n\ncontentsRect在app中最有趣的地方在于一个叫做image sprites（图片拼合）的用法。如果你有游戏编程的经验，那么你一定对图片拼合的概念很熟悉，图片能够在屏幕上独立地变更位置。抛开游戏编程不谈，这个技术常用来指代载入拼合的图片，跟移动图片一点关系也没有。\n\n典型地，图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等\n\n2D游戏引擎入Cocos2D使用了拼合技术，它使用OpenGL来显示图片。不过我们可以使用拼合在一个普通的UIKit应用中，对！就是使用contentsRect\n\n首先，我们需要一个拼合后的图表 —— 一个包含小一些的拼合图的大图片。如图2.7所示：\n\n![图2.7](/images/ios-core-animation/2.7.png)\n\n接下来，我们要在app中载入并显示这些拼合图。规则很简单：像平常一样载入我们的大图，然后把它赋值给四个独立的图层的contents，然后设置每个图层的contentsRect来去掉我们不想显示的部分。\n\n我们的工程中需要一些额外的视图。（为了避免太多代码。我们将使用Interface Builder来拜访他们的位置，如果你愿意还是可以用代码的方式来实现的）。清单2.3有需要的代码，图2.8展示了结果\n\n```\n@interface ViewController ()\n@property (nonatomic, weak) IBOutlet UIView *coneView;\n@property (nonatomic, weak) IBOutlet UIView *shipView;\n@property (nonatomic, weak) IBOutlet UIView *iglooView;\n@property (nonatomic, weak) IBOutlet UIView *anchorView;\n@end\n\n@implementation ViewController\n\n- (void)addSpriteImage:(UIImage *)image withContentRect:(CGRect)rect toLayer:(CALayer *)layer //set image\n{\n  layer.contents = (__bridge id)image.CGImage;\n\n  //scale contents to fit\n  layer.contentsGravity = kCAGravityResizeAspect;\n\n  //set contentsRect\n  layer.contentsRect = rect;\n}\n\n- (void)viewDidLoad \n{\n  [super viewDidLoad]; //load sprite sheet\n  UIImage *image = [UIImage imageNamed:@\"Sprites.png\"];\n  //set igloo sprite\n  [self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.iglooView.layer];\n  //set cone sprite\n  [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.coneView.layer];\n  //set anchor sprite\n  [self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.anchorView.layer];\n  //set spaceship sprite\n  [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.shipView.layer];\n}\n@end\n```\n\n![图2.8](/images/ios-core-animation/2.8.png)\n\n拼合不仅给app提供了一个整洁的载入方式，还有效地提高了载入性能（单张大图比多张小图载入地更快），但是如果有手动安排的话，他们还是有一些不方便的，如果你需要在一个已经创建好的品和图上做一些尺寸上的修改或者其他变动，无疑是比较麻烦的。\n\nMac上有一些商业软件可以为你自动拼合图片，这些工具自动生成一个包含拼合后的坐标的XML或者plist文件，拼合图片的使用大大简化。这个文件可以和图片一同载入，并给每个拼合的图层设置contentsRect，这样开发者就不用手动写代码来摆放位置了。\n\n这些文件通常在OpenGL游戏中使用，不过呢，你要是有兴趣在一些常见的app中使用拼合技术，那么一个叫做LayerSprites的开源库（https://github.com/nicklockwood/LayerSprites)，它能够读取Cocos2D格式中的拼合图并在普通的Core Animation层中显示出来。\n\n## contentsCenter\n\n本章我们介绍的最后一个和内容有关的属性是contentsCenter，看名字你可能会以为它可能跟图片的位置有关，不过这名字着实误导了你。contentsCenter其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变contentsCenter的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。\n\n默认情况下，contentsCenter是{0, 0, 1, 1}，这意味着如果大小（由conttensGravity决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。图2.9展示了contentsCenter设置为{0.25, 0.25, 0.5, 0.5}的效果。\n\n![图2.9 contentsCenter的例子](/images/ios-core-animation/2.9.png)\n\n这意味着我们可以随意重设尺寸，边框仍然会是连续的。他工作起来的效果和UIImage里的-resizableImageWithCapInsets: 方法效果非常类似，只是它可以运用到任何寄宿图，甚至包括在Core Graphics运行时绘制的图形（本章稍后会讲到）。\n\n![图2.10 同一图片使用不同的contentsCenter](/images/ios-core-animation/2.10.png)\n\n清单2.4 演示了如何编写这些可拉伸视图。不过，contentsCenter的另一个很酷的特性就是，它可以在Interface Builder里面配置，根本不用写代码。如图2.11\n\n清单2.4 用contentsCenter设置可拉伸视图\n\n```\n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *button1;\n@property (nonatomic, weak) IBOutlet UIView *button2;\n\n@end\n\n@implementation ViewController\n\n- (void)addStretchableImage:(UIImage *)image withContentCenter:(CGRect)rect toLayer:(CALayer *)layer\n{  \n  //set image\n  layer.contents = (__bridge id)image.CGImage;\n\n  //set contentsCenter\n  layer.contentsCenter = rect;\n}\n\n- (void)viewDidLoad\n{\n  [super viewDidLoad]; //load button image\n  UIImage *image = [UIImage imageNamed:@\"Button.png\"];\n\n  //set button 1\n  [self addStretchableImage:image withContentCenter:CGRectMake(0.25, 0.25, 0.5, 0.5) toLayer:self.button1.layer];\n\n  //set button 2\n  [self addStretchableImage:image withContentCenter:CGRectMake(0.25, 0.25, 0.5, 0.5) toLayer:self.button2.layer];\n}\n\n@end\n```\n\n![图2.11 用Interface Builder 探测窗口控制contentsCenter属性](/images/ios-core-animation/2.11.png)\n\n# Custom Drawing\n\n给contents赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现-drawRect:方法来自定义绘制。\n\ndrawRect: 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到-drawRect: 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 contentsScale的值。\n\n如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。\n\n当视图在屏幕上出现的时候 -drawRect:方法就会被自动调用。-drawRect:方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了-setNeedsDisplay方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如bounds属性）。虽然-drawRect:方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。\n\nCALayer有一个可选的delegate属性，实现了CALayerDelegate协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（delegate属性被声明为id类型，所有的代理方法都是可选的）。\n\n当需要被重绘时，CALayer会请求它的代理给他一个寄宿图来显示。它通过调用下面这个方法做到的:\n\n```\n- (void)displayLayer:(CALayerCALayer *)layer;\n```\n\n趁着这个机会，如果代理想直接设置contents属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现-displayLayer:方法，CALayer就会转而尝试调用下面这个方法：\n\n```\n- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;\n```\n\n在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由bounds和contentsScale决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。\n\n让我们来继续第一章的项目让它实现CALayerDelegate并做一些绘图工作吧（见清单2.5）.图2.12是他的结果\n\n清单2.5 实现CALayerDelegate\n\n```\n@implementation ViewController\n- (void)viewDidLoad\n{\n  [super viewDidLoad];\n  \n  //create sublayer\n  CALayer *blueLayer = [CALayer layer];\n  blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);\n  blueLayer.backgroundColor = [UIColor blueColor].CGColor;\n\n  //set controller as layer delegate\n  blueLayer.delegate = self;\n\n  //ensure that layer backing image uses correct scale\n  blueLayer.contentsScale = [UIScreen mainScreen].scale; //add layer to our view\n  [self.layerView.layer addSublayer:blueLayer];\n\n  //force layer to redraw\n  [blueLayer display];\n}\n\n- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx\n{\n  //draw a thick red circle\n  CGContextSetLineWidth(ctx, 10.0f);\n  CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);\n  CGContextStrokeEllipseInRect(ctx, layer.bounds);\n}\n@end\n```\n\n![图2.12 实现CALayerDelegate来绘制图层](/images/ios-core-animation/2.12.png)\n\n注意一下一些有趣的事情：\n\n* 我们在blueLayer上显式地调用了-display。不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。\n* 尽管我们没有用masksToBounds属性，绘制的那个圆仍然沿边界被裁剪了。这是因为当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。\n\n现在你理解了CALayerDelegate，并知道怎么使用它。但是除非你创建了一个单独的图层，你几乎没有机会用到CALayerDelegate协议。因为当UIView创建了它的宿主图层时，它就会自动地把图层的delegate设置为它自己，并提供了一个-displayLayer:的实现，那所有的问题就都没了。\n\n当使用寄宿了视图的图层的时候，你也不必实现-displayLayer:和-drawLayer:inContext:方法来绘制你的寄宿图。通常做法是实现UIView的-drawRect:方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用-display方法。\n\n# 总结\n\n本章介绍了寄宿图和一些相关的属性。你学到了如何显示和放置图片， 使用拼合技术来显示， 以及用CALayerDelegate和Core Graphics来绘制图层内容。\n\n在第三章，\"图层几何学\"中，我们将会探讨一下图层的几何，观察他们是如何放置和改变相互的尺寸的。\n\n\n","tags":["核心动画"],"categories":["iOS"]},{"title":"核心动画-图层树","url":"/2017/04/06/ios-core-animation/ios-core-animation-chapter-1/","content":"\n# 前言\n\n\n>巨妖有图层，洋葱也有图层，你有吗？我们都有图层 -- 史莱克\n\nCore Animation其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做Layer Kit这么一个不怎么和动画有关的名字演变而来，所以做动画这只是Core Animation特性的冰山一角。\n\n Core Animation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的图层，存储在一个叫做图层树的体系之中。于是这个树形成了UIKit以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。\n\n在我们讨论动画之前，我们将从图层树开始，涉及一下Core Animation的静态组合以及布局特性。\n\n<!-- more -->\n\n# 图层与视图\n\n如果你曾经在iOS或者Mac OS平台上写过应用程序，你可能会对视图的概念比较熟悉。一个视图就是在屏幕上显示的一个矩形块（比如图片，文字或者视频），它能够拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。图1.1显示了一种典型的视图层级关系\n\n![图1.1 一种典型的iOS屏幕（左边）和形成视图的层级关系（右边）](/images/ios-core-animation/1.1.jpeg)\n\n在iOS当中，所有的视图都从一个叫做UIVIew的基类派生而来，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。\n\n## CALayer\n\nCALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。\n\nCALayer并不清楚具体的响应链（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内（具体见第三章，“图层的几何学”）\n\n## 平行的层级关系\n\n每一个UIview都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作（见图1.2）。 \n\n![图1.2 层的树状结构（左边）以及对应的视图层级（右边）](/images/ios-core-animation/1.2.jpeg)\n\n实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。\n\n但是为什么iOS要基于UIView和CALayer提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和UIView，但是Mac OS有AppKit和NSView的原因。他们功能上很相似，但是在实现上有着显著的区别。\n\n绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。\n\n实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在呈现树和渲染树，将在第七章“隐式动画”和第十二章“性能调优”分别讨论。\n\n# 图层的能力\n\n如果说CALayer是UIView内部实现细节，那我们为什么要全面地了解它呢？苹果当然为我们提供了优美简洁的UIView接口，那么我们是否就没必要直接去处理Core Animation的细节了呢？\n\n某种意义上说的确是这样，对一些简单的需求来说，我们确实没必要处理CALayer，因为苹果已经通过UIView的高级API间接地使得动画变得很简单。\n\n但是这种简单会不可避免地带来一些灵活上的缺陷。如果你略微想在底层做一些改变，或者使用一些苹果没有在UIView上实现的接口功能，这时除了介入Core Animation底层之外别无选择。\n\n我们已经证实了图层不能像视图那样处理触摸事件，那么他能做哪些视图不能做的呢？这里有一些UIView没有暴露出来的CALayer的功能：\n\n\n* 阴影，圆角，带颜色的边框\n* 3D变换\n* 非矩形范围\n* 透明遮罩\n* 多级非线性动画\n\n我们将会在后续章节中探索这些功能，首先我们要关注一下在应用程序当中CALayer是怎样被利用起来的。\n\n# 使用图层\n\n首先我们来创建一个简单的项目，来操纵一些layer的属性。打开Xcode，使用Single View Application模板创建一个工程。\n\n在屏幕中央创建一个小视图（大约200 X 200的尺寸），当然你可以手工编码，或者使用Interface Builder（随你方便）。确保你的视图控制器要添加一个视图的属性以便可以直接访问它。我们把它称作layerView。\n\n运行项目，应该能在浅灰色屏幕背景中看见一个白色方块（图1.3），如果没看见，可能需要调整一下背景window或者view的颜色\n\n![图1.3 灰色背景上的一个白色UIView](/images/ios-core-animation/1.3.jpeg)\n\n这并没有什么令人激动的地方，我们来添加一个色块，在白色方块中间添加一个小的蓝色块。\n\n我们当然可以简单地在已经存在的UIView上添加一个子视图（随意用代码或者IB），但这不能真正学到任何关于图层的东西。\n\n于是我们来创建一个CALayer，并且把它作为我们视图相关图层的子图层。尽管UIView类的接口中暴露了图层属性，但是标准的Xcode项目模板并没有包含Core Animation相关头文件。所以如果我们不给项目添加合适的库，是不能够使用任何图层相关的方法或者访问它的属性。所以首先需要添加QuartzCore框架到Build Phases标签（图1.4），然后在vc的.m文件中引入库。\n\n![图1.4 把QuartzCore库添加到项目](/images/ios-core-animation/1.4.jpeg)\n\n之后就可以在代码中直接引用CALayer的属性和方法。在清单1.1中，我们用创建了一个CALayer，设置了它的backgroundColor属性，然后添加到layerView背后相关图层的子图层（这段代码的前提是通过IB创建了layerView并做好了连接），图1.5显示了结果。\n\n清单1.1 给视图添加一个蓝色子图层\n\n```\n#import \"ViewController.h\"\n#import \n@interface ViewController ()\n\n@property (nonatomic, weak) IBOutlet UIView *layerView;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //create sublayer\n    CALayer *blueLayer = [CALayer layer];\n    blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);\n    blueLayer.backgroundColor = [UIColor blueColor].CGColor;\n    //add it to our view\n    [self.layerView.layer addSublayer:blueLayer];\n}\n@end\n```\n\n![图1.5 白色UIView内部嵌套的蓝色CALayer](/images/ios-core-animation/1.5.jpeg)\n\n一个视图只有一个相关联的图层（自动创建），同时它也可以支持添加无数多个子图层，从清单1.1可以看出，你可以显示创建一个单独的图层，并且把它直接添加到视图关联图层的子图层。尽管可以这样添加图层，但往往我们只是见简单地处理视图，他们关联的图层并不需要额外地手动添加子图层。\n\n在Mac OS平台，10.8版本之前，一个显著的性能缺陷就是由于用了视图层级而不是单独在一个视图内使用CALayer树状层级。但是在iOS平台，使用轻量级的UIView类并没有显著的性能影响（当然在Mac OS 10.8之后，NSView的性能同样也得到很大程度的提高）。\n\n使用图层关联的视图而不是CALayer的好处在于，你能在使用所有CALayer底层特性的同时，也可以使用UIView的高级API（比如自动排版，布局和事件处理）。\n\n然而，当满足以下条件的时候，你可能更需要使用CALayer而不是UIView:\n\n\n* 开发同时可以在Mac OS上运行的跨平台应用\n* 使用多种CALayer的子类（见第六章，“特殊的图层“），并且不想创建额外的UIView去包封装它们所有\n* 做一些对性能特别挑剔的工作，比如对UIView一些可忽略不计的操作都会引起显著的不同（尽管如此，你可能会直接想使用OpenGL绘图）\n\n但是这些例子都很少见，总的来说，处理视图会比单独处理图层更加方便。\n\n# 总结\n\n这一章阐述了图层的树状结构，说明了如何在iOS中由UIView的层级关系形成的一种平行的CALayer层级关系，在后面的实验中，我们创建了自己的CALayer，并把它添加到图层树中。\n\n在第二章，“图层关联的图片”，我们将要研究一下CALayer关联的图片，以及Core Animation提供的操作显示的一些特性。\n\n","tags":["核心动画"],"categories":["iOS"]},{"title":"核心动画-目录","url":"/2017/04/06/ios-core-animation/ios-core-animation/","content":"\n1. [图层树](http://blog.devjackcat.com/2017/04/06/ios-core-animation/ios-core-animation-chapter-1/)\n    * [前言](http://blog.devjackcat.com/2017/04/06/ios-core-animation/ios-core-animation-chapter-1/#前言)\n    * [图层与视图](http://blog.devjackcat.com/2017/04/06/ios-core-animation/ios-core-animation-chapter-1/#图层与视图)\n        * [CALayer](http://blog.devjackcat.com/2017/04/06/ios-core-animation/ios-core-animation-chapter-1/#CALayer)\n        * [平行的层级关系](http://blog.devjackcat.com/2017/04/06/ios-core-animation/ios-core-animation-chapter-1/#平行的层级关系)\n    * [图层的能力](http://blog.devjackcat.com/2017/04/06/ios-core-animation/ios-core-animation-chapter-1/#图层的能力)\n    * [使用图层](http://blog.devjackcat.com/2017/04/06/ios-core-animation/ios-core-animation-chapter-1/#使用图层)\n    * [总结](http://blog.devjackcat.com/2017/04/06/ios-core-animation/ios-core-animation-chapter-1/#总结)\n2. [寄宿图](http://blog.devjackcat.com/2017/04/06/ios-core-animation/ios-core-animation-chapter-2/)\n    * 前言\n       * contents属性\n       * contentGravity\n       * contentsScale\n       * maskToBounds\n       * contentsRect\n       * contentsCenter\n       * Custom Drawing\n    * 总结\n3. [图层几何学](http://blog.devjackcat.com/2017/04/06/ios-core-animation/ios-core-animation-chapter-3/)\n    * 前言\n    * 布局\n    * 锚点\n    * 坐标系\n        * 翻转的几何结构\n            * Z坐标轴\n    * Hit Testing\n    * 自动布局\n    * 总结\n4. [视觉效果](http://blog.devjackcat.com/2017/04/06/ios-core-animation/ios-core-animation-chapter-4/)\n5. [变换](http://blog.devjackcat.com/2017/04/10/ios-core-animation/ios-core-animation-chapter-5/)\n6. [专用图层](http://blog.devjackcat.com/2017/04/10/ios-core-animation/ios-core-animation-chapter-6/)\n7. 隐式动画\n8. 显示动画\n9. 图层时间\n10. 缓冲\n11. 基于定时器的动画\n12. 性能调优\n13. 高效绘图\n14. 图形IO\n15. 图层性能\n\n\n","tags":["核心动画"],"categories":["iOS"]},{"title":"iOS符号表恢复&逆向支付宝","url":"/2017/03/29/symbol-restore/","content":"\n### 关于本文\n\n本文是杨君的著作。\n\n原文地址:  http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/\n\n<!-- more -->\n\n### 前言\n\n符号表历来是逆向工程中的“必争之地”，而iOS应用在上线前都会裁去符号表，以避免被逆向分析。\n\n本文会介绍一个自己写的工具，用于恢复iOS应用的符号表。\n\n直接看效果,支付宝恢复符号表后的样子:\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/after_restore.jpg)\n\n文章有点长，请耐心看到最后，亮点在最后。\n\n### 为什么要恢复符号表\n\n逆向工程中，调试器的动态分析是必不可少的，而 Xcode + lldb 确实是非常好的调试利器, 比如我们在Xcode里可以很方便的查看调用堆栈，如上面那张图可以很清晰的看到支付宝登录的RPC调用过程。\n\n实际上，如果我们不恢复符号表的话，你看到的调试页面应该是下面这个样子：\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/before_restore.jpg)\n\n同一个函数调用过程，Xcode的显示简直天差地别。\n\n原因是，Xcode显示调用堆栈中符号时，只会显示符号表中有的符号。为了我们调试过程的顺利，我们有必要把可执行文件中的符号表恢复回来。\n\n### 符号表是什么\n\n我们要恢复符号表，首先要知道符号表是什么，他是怎么存在于 Mach-O 文件中的。\n\n符号表储存在 Mach-O 文件的 __LINKEDIT 段中，涉及其中的符号表（Symbol Table）和字符串表（String Table）。\n\n这里我们用 MachOView 打开支付宝的可执行文件，找到其中的 Symbol Table 项。\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/symbol_table.jpg)\n\n符号表的结构是一个连续的列表，其中的每一项都是一个 `struct nlist`。\n\n```\n//  位于系统库 <macho-o/nlist.h> 头文件中\nstruct nlist {\n  union {\n  //符号名在字符串表中的偏移量\n    uint32_t n_strx;\t\n  } n_un;\n  uint8_t n_type;\n  uint8_t n_sect;\n  int16_t n_desc;\n  //符号在内存中的地址，类似于函数指针\n  uint32_t n_value;\n};\n```\n这里重点关注第一项和最后一项，第一项是符号名在字符串表中的偏移量，用于表示函数名，最后一项是符号在内存中的地址，类似于函数指针（这里只说明大概的结构，详细的信息请参考官方Mach O文件格式的文档）。\n\n也就是说如果我们知道了符号名和内存地址的对应关系，我们是可以根据这个结构来逆向构造出符号表数据的。\n\n知道了如何构造符号表，下一步就是收集符号名和内存地址的对应关系了。\n\n### 获取OC方法的符号表\n\n因为OC语言的特性，编译器会将类名、函数名等编译进最后的可执行文件中，所以我们可以根据Mach-O文件的结构逆向还原出工程里的所有类，这也就是大名鼎鼎的逆向工具 class-dump 了。class-dump 出来的头文件里是有函数地址的：\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/class_dump_imp.png)\n\n所以我们只要对class-dump的源码稍作修改，即可获取我们要的信息。\n\n### 符号表恢复工具\n\n整理完数据格式，又理清了数据来源，我们就可以写工具了。\n\n实现过程就不详细说明了，工具开源在我的Github上了，链接：\nhttps://github.com/tobefuturer/restore-symbol\n\n我们来看看怎么用这个工具：\n\n**1.下载源码编译**\n\n```\ngit clone --recursive https://github.com/tobefuturer/restore-symbol.git\ncd restore-symbol && make\n./restore-symbol\n```\n\n**2.恢复OC的符号表，非常简单**\n\n```\n./restore-symbol ./origin_AlipayWallet -o ./AlipayWallet_with_symbol\n```\n\norigin_AlipayWallet 为Clutch砸壳后，没有符号表的 Mach-O 文件\n-o 后面跟输出文件位置\n\n**3.把 Mach-O 文件重签名打包，看效果**\n\n文件恢复符号表后，多出了20M的符号表信息\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/restore_size.jpg)\n\nXcode里查看调用栈\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/restore_only_oc.jpg)\n\n可以看到，OC函数这部分的符号已经恢复了，函数调用栈里已经能看出大致的调用过程了，但是支付宝里，采用了block的回调形式，所以还有很大一部分的符号没能正确显示。\n\n下面我们就来看看怎么样恢复这部分block的符号。\n\n### 获取block的符号信息\n\n还是同样的思路，要恢复block的符号信息，我们必须知道block在文件中的储存形式。\n\n### block在内存中的结构\n\n首先，我们先分析下运行时，block在内存中的存在形式。block在内存中是以一个结构体的形式存在的，大致的结构如下：\n\n```\nstruct __block_impl {\n  /**\n  block在内存中也是类NSObject的结构体，\n  结构体开始位置是一个isa指针\n  */\n  Class isa;\n  \n  /** 这两个变量暂时不关心 */\n  int flags;\n  int reserved;\n  \n  /**\n  真正的函数指针！！\n  */\n  void (*invoke)(...);\n  ...\n}\n```\n\n说明下block中的isa指针，根据实际情况会有三种不同的取值，来表示不同类型的block：\n\n* _NSConcreteStackBlock\n\n    栈上的block，一般block创建时是在栈上分配了一个block结构体的空间，然后对其中的isa等变量赋值。\n\n* _NSConcreteMallocBlock\n\n    堆上的block，当block被加入到GCD或者被对象持有时，将栈上的block复制到堆上，此时复制得到的block类型变为了_NSConcreteMallocBlock。\n\n* _NSConcreteGlobalBlock\n\n    全局静态的block，当block不依赖于上下文环境，比如不持有block外的变量、只使用block内部的变量的时候，block的内存分配可以在编译期就完成，分配在全局的静态常量区。\n\n第2种block在运行时才会出现，我们只关注1、3两种，下面就分析这两种isa指针和block符号地址之间的关联。\n\n\n### block isa指针和符号地址之间的关联\n\n分析这部分需要用到IDA这个反汇编软件, 这里结合两个实际的小例子来说明：\n\n**1._NSConcreteStackBlock**\n\n假设我们的源代码是这样很简单的一个block：\n\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    int t = 2;\n    void (^ foo)() = ^(){\n        NSLog(@\"%d\", t); //block 引用了外部的变量t\n    };\n    foo();\n}\n@end\n```\n\n编译完后，实际的汇编长这个样子：\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/example_stack_block.jpg)\n\n实际运行时，block的构造过程是这样：\n\n1. 为block开辟栈空间\n2. 为block的isa指针赋值（一定会引用全局变量：_NSConcreteStackBlock）\n3. 获取函数地址，赋值给函数指针\n\n所以我们可以整理出这样一个特征：\n\n*重点来了!!!*\n\n*凡是代码里用到了栈上的block，一定会获取__NSConcreteStackBlock作为isa指针，同时会紧接着获取一个函数地址，那个函数地址就是block的函数地址。*\n\n结合下面这个图，仔细理解上面这句话\n（这张图和上面那张图是同一个文件，不过裁掉了符号表）\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/example_stack_block_strip.jpg)\n\n利用这个特征，逆向分析时我们可以做如下推断：\n\n在一个OC方法里发现引用了__NSConcreteStackBlock这个变量，那么在这附近，一定会出现一个函数地址，这个函数地址就是这个OC方法里的一个block。\n\n比如上面图中，我们发现 viewDidLoad 里，引用了__NSConcreteStackBlock,同时紧接着加载了 sub_100049D4 的函数地址，那我们就可以认定sub_100049D4是viewDidLoad里的一个block, sub_100049D4函数的符号名应该是 viewDidLoad_block.\n\n**2. _NSConcreteGlobalBlock**\n\n全局的静态block，是那种不引用block外变量的block，他因为不引用外部变量，所以他可以在编译期就进行内存分配操作，也不用担心block的复制等等操作，他存在于可执行文件的常量区里。\n\n不太理解的话，看个例子：\n\n我们把源代码改成这样：\n\n```\n@implementation ViewController\n- (void)viewDidLoad {\n   \n    void (^ foo)() = ^(){\n        //block 不引用外部的变量\n        NSLog(@\"%d\", 123);\n    };\n    foo();\n}\n@end\n```\n\n那么在编译后会变成这样：\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/example_global_block.jpeg)\n\n那么借鉴上面的思路，在逆向分析的时候，我们可以这么推断\n\n1. 在静态常量区发现一个_NSConcreteGlobalBlock的引用\n2. 这个地方必然存在一个block的结构体数据\n3. 在这个结构体第16个字节的地方会出现一个值，这个值是一个block的函数地址\n\n**3. block 的嵌套结构**\n\n实际在使用中，可能会出现block内嵌block的情况：\n\n```\n- (void)viewDidLoad {\n  dispatch_async(background_queue ,^{\n    ...\n    dispatch_async(main_queue, ^{\n      ...     \n    });\n  });\n}\n```\n\n所以这里block就出现了父子关系，如果我们将这些父子关系收集起来，就可以发现，这些关系会构成图论里的森林结构，这里可以简单用递归的深度优先搜索来处理，详细过程不再描述。\n\n### block符号表提取脚本（IDA+python）\n\n整理上面的思路，我们发现搜索过程依赖于IDA提供各种引用信息，而IDA是提供了编程接口的，可以利用这些接口来提取引用信息。\n\nIDA提供的是Python的SDK，最后完成的脚本也放在仓库里search_oc_block/ida_search_block.py。\n\n### 提取block符号表\n\n这里简单介绍下怎么使用上面这个脚本\n\n1.用IDA打开支付宝的 Mach-O 文件\n2.等待分析完成！ 可能要一个小时\n3.Alt + F7 或者 菜单栏 File -> Script file...\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/ida_select_script.jpg)\n\n4.等待脚本运行完成，预计30s至60s，运行过程中会有这样的弹窗\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/ida_script_running.jpg)\n\n5.弹窗消失即block符号表提取完成\n6.在IDA打开文件的目录下,会输出一份名为block_symbol.json的json格式block符号表\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/ida_result_position.png)\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/ida_result_sample.jpg)\n\n### 恢复符号表&实际分析\n\n用之前的符号表恢复工具，将block的符号表导入Mach-O文件\n\n```\n./restore-symbol ./origin_AlipayWallet -o ./AlipayWallet_with_symbol -j block_symbol.json\n```\n\n-j 后面跟上之前得到的json符号表\n\n最后得到一份同时具有OC函数符号表和block符号表的可执行文件\n\n这里简单介绍一个分析案例, 你就能体会到这个工具的强大之处了。\n\n1.在Xcode里对 -[UIAlertView show] 设置断点\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/xcode_breakpoint.jpg)\n\n2.运行程序，并在支付宝的登录页面输入手机号和错误的密码，点击登录\n3.Xcode会在‘密码错误’的警告框弹出时停下，左侧会显示出这样的调用栈\n\n*一张图看完支付宝的登录过程*\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/xcode_backtrace.jpg)\n\n项目开源地址：\nhttps://github.com/tobefuturer/restore-symbol\n\n欢迎大家在上面提各种Issues，或者有问题也可以直接Email（tobefuturer@gmail.com）。\n\n\n\n\n\n","tags":["逆向工程"],"categories":["iOS"]},{"title":"SSH公钥配置","url":"/2017/03/25/ssh-setting/","content":"\n\n当我们从git仓库下载一个项目时，我们习惯用如下命令\n\n```\n//从coding获取源码\ngit clone git@git.coding.net:username/project.git\n//从github获取代码\ngit clone git@github.com:username/project.git\n```\n如果是一次clone,可能会遇到这样的错误信息，因为没有配置SSH公钥而导致的认证失败\n\n<!-- more -->\n\n```\nThe authenticity of host 'git.coding.net (219.146.244.71)' can't be established.\nRSA key fingerprint is SHA256:jok3FH7q5LJ6qvE7iPNehBgXRw51ErE77S0Dn+Vg/Ik.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added 'git.coding.net,219.146.244.71' (RSA) to the list of known hosts.\nPermission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n现在我们来解决这个问题，Mac/Linux打开terminal终端，输入命令\n\n```\nssh-keygen -t rsa -C “username@example.com”(注册时使用的邮箱)\n```\n\n期间会要求输入存储路径和密码，存储路径维持默认，直接回车即可，密码可输可不输，也是直接回车即可。\n\n```\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/Users/abc/.ssh/id_rsa): (要求输入保存路径，直接回车)\nEnter passphrase (empty for no passphrase): (要求输入密码，可不输入，直接回车)\nEnter same passphrase again: \n```\n\n生成成功后会看到这样的结果\n\n```\nYour identification has been saved in /Users/abc/.ssh/id_rsa.\nYour public key has been saved in /Users/abc/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:h4OoqopIITKTyh0IxJQUhuWbSCfJVSvtUhnLK6dYN0Y username@example.com\nThe key's randomart image is:\n+---[RSA 2048]----+\n|=B+..o           |\n|=+o o =          |\n|.=.o E           |\n|oo+o=... .       |\n|Boo=.B. S .      |\n|=o=.O .  o       |\n|.+.o             |\n|+.               |\n|O                |\n+----[SHA256]-----+\n```\n\n公钥文件已经保存在了```/Users/abc/.ssh/id_rsa.pub```打开这个文件，或执行'cat /Users/abc/.ssh/id_rsa.pub'查看内容。\n\n将公钥内容配置到git服务器即可。\n\n![](/images/ssh-setting/14903644615279.jpg)\n\n\n到此为止，SSH公钥配置已经完成，再次执行clone命令就可以成功把源码下载下来。\n\n","tags":["SSH"]},{"title":"Hexo Next博客搭建","url":"/2017/03/20/hexo-setting/","content":"\n本博客使用Hexo搭建的静态博客，Theme使用的是Next\n\n[Theme for Hexo](https://theme-next.org/)","tags":["Hexo"],"categories":["Hexo"]}]
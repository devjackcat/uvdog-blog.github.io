[{"title":"fastlane基础篇","url":"%2F2020%2F03%2F06%2Ffastlane%2Ffastlane-start%2F","content":"\n![](/images/fastlane/fastlane_logo.png)\n\n<!-- more -->\n\n## 介绍\n\n>fastlane is the easiest way to automate beta deployments and releases for your iOS and Android apps. 🚀 It handles all tedious tasks, like generating screenshots, dealing with code signing, and releasing your application.\n\n[fastlane](https://docs.fastlane.tools/)通过最简单的方式为iOS和Android应用实现自动化测试、部署、发布。它可以帮我们处理自动封面截图、签名、发布繁琐易错的事情。\n\n由于本人从事iOS开发，下面都是以iOS为例进行操作。\n\n通过下面简单的脚本配置即可打包发布。\n\n```\nlane :release do\n  capture_screenshots\n  build_app\n  upload_to_app_store       # Upload the screenshots and the binary to iTunes\n  slack                     # Let your team-mates know the new version is live\nend\n```\n\n项目根目录执行脚本即可\n\n```\nfastlane release\n```\n\n## 安装\n\n**1.fastlane需要安装Xcode命令行工具。如果已经安装了Xcode，则跳过这一步**\n\n```\nxcode-select --install\n```\n\n**2.安装fastlane有两种方式RubyGems、Homebrew**\n\n```\n# Using RubyGems\nsudo gem install fastlane -NV\n\n# Alternatively using Homebrew\nbrew install fastlane\n```\n\n\n**3.进入项目根目录，进行fastlane初始化**\n\n```\nfastlane init\n```\n\n## AdHoc打包\n\n在fastFile文件中添加代码\n\n```\n$scheme = \"scheme\"\n$workspace = \"项目名.xcworkspace\"\n$bundleId = \"bundleId\"\n$provisioningProfile_adhoc = \"AdHoc描述文件\"\n\n$pgyer_key = \"pgyer_key\"\n$pgyer_user_key = \"pgyer_user_key\"\n\ndesc \"打 adhoc debug 测试包\"\n   lane :adhoc_debug do\n     build_app(\n         scheme: $scheme,\n         workspace: $workspace,\n         include_bitcode: false,\n         configuration: \"Debug\", # 测试环境数据Debug, 线上环境数据Release\n         silent: false,\n         include_symbols: true,\n         export_options: {\n           method: \"ad-hoc\",\n           signingStyle: \"manual\",\n           stripSwiftSymbols: true,\n           uploadBitcode: false,\n           uploadSymbols: false,\n           provisioningProfiles: {\n             $bundleId => $provisioningProfile_adhoc\n           }\n         }\n     )\n     \n     #打包完成后上传至蒲公英\n     pgyer(api_key: $pgyer_key, user_key: $pgyer_user_key)\n   end\n```\n\n执行脚本\n```\nfastlane adhoc_debug\n```\n\n## Release打包\n\n```\n$scheme = \"scheme\"\n$workspace = \"项目名.xcworkspace\"\n$bundleId = \"bundleId\"\n$provisioningProfile_release = \"Release项目文件\"\n\n$AppleId = \"AppleId\"\n$ApplePwd = \"专用密码\" # 上传AppStore专用密码 https://appleid.apple.com/account/manage\n$SmsPhoneNumber = \"双向验证手机号\" # 上传时接收验证码的手机号，格式\"+86 13011112222\"\n\ndesc \"打生产包并上传至AppStore\" \n   lane :release do\n     build_app(\n         scheme: $scheme,\n         workspace: $workspace,\n         include_bitcode: false,\n         #configuration: \"Release\",\n         silent: false,\n         include_symbols: true,\n         clean: true,  # 执行清理\n         export_options: {\n           method: \"app-store\",\n           signingStyle:\"manual\",\n           stripSwiftSymbols:true,\n           uploadBitcode:false,\n           uploadSymbols:false,\n           provisioningProfiles: {\n             $bundleId => $provisioningProfile_release\n           }\n         }\n     )\n\n     # 设置fastlane环境变量\n     # 接受验证码的手机号，格式\"+86 13011112222\"\n     ENV[\"SPACESHIP_2FA_SMS_DEFAULT_PHONE_NUMBER\"] = $SmsPhoneNumber\n     \n     # 上传包专用密码，非AppleId密码\n     # https://appleid.apple.com/account/manage      ENV[\"FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD\"] = $ApplePwd\n\n     # 上传appstore\n     upload_to_app_store( \n       username: $AppleId,\n       skip_metadata: true, #跳过媒体文件上传\n       skip_screenshots: true, #跳过截图文件\n       precheck_include_in_app_purchases: false, #无需检查内购\n       ignore_language_directory_validation: false,\n       run_precheck_before_submit: false\n     ) \n   end\n```\n\n执行脚本\n\n```\nfastlane release\n```\n\n相关代码[Github地址](https://github.com/devjackcat/fastlane-config.git)\n\n\n\n","tags":["fastlane"],"categories":["自动化集成"]},{"title":"2019, 改变自己","url":"%2F2019%2F02%2F11%2F2019-starting%2F","content":"\n新年上班第一天，拿到开年红包。预祝自己新年新气象，创造新自己。\n\n<!-- more -->\n\n### 回首2018\n\n此处省略2000字(原因你懂得)......\n\n### 2019 Flag\n\n#### 论思维\n\n不善交际、不善表达、不善整理、不善总结的我，越来越意识到问题的严重性，必须找出问题，改变自己。\n\n深思了下，导致上面问题的根本原因是思维混乱。举个简单例子：看完一篇文章，学到了新的知识，但这些知识在脑海中处于碎片状态，又没有及时整理复盘并消化。这样碎片化的内容就成了表达的障碍，表达的障碍就成了交际的绊脚石。\n\n类似的问题在生活、工作的各方面都有存在。遇到了问题，解决了问题，却没有及时的整理复盘，依旧等于没解决。\n\n新年需要加强这方面的能力，多做整理复盘、多做总结、多表达、多交际。\n\n#### 论读书\n\n书是人类进步的阶梯，这句名言从小铭记于心，但并没发挥它的作用，还是基本不看书。\n\n今年励志多读书、多做笔记、多进步，以下列举了今年要看的书籍，覆盖了读书、整理、科技、营销、理财等多方面的内容。\n\n* 1 《如何阅读一本书》\n* 2 《思维导图》\n* 3 《市场营销(MBA轻松读)》\n* 4 《参与感：小米口碑营销内部手册》\n* 5 《运营之光》\n* 6 《AI * 未来》\n* 7 《腾讯传》\n* 8 《一本书读懂投资理财》\n* 9 《百岁人生》\n* 10 《读书是一辈子的事儿》\n* 11 《思考、快与慢》\n* 12 《定位》\n* 13 《疯传》\n* 14 《增长黑客》\n* 15 《怪诞行为学》\n\n#### 论工作\n\n还没想好咋写......\n\n#### 论旅游\n\n今年要陪她来一次长途旅行。在一起4年多，却只有过一次旅行，实在说不过去。\n\n#### 论健康\n\n不运动、身体虚、还肥胖，😂 ......\n\n身体是革命的本钱，身体不好，啥都别谈。今年得运动起来。\n\n励志每周至少两次运动，跑步、打球、健身、爬山都行\n\n### 总结\n\n2019不能再像去年一样荒废，需要改变自己，换一种活法。从思维、读书、工作、健康这三方面入手，希望自己能通过这一年的努力，真的实现改变自己。\n\n\n\n","tags":["新年Flag"],"categories":["生活"]},{"title":"Git项目仓库迁移","url":"%2F2019%2F01%2F10%2Fgit-project-relocate%2F","content":"\n前几天，github开放了免费的私有库，这是无非是github被微软收购之后，给开发者的一个最大的新年贺礼。\n\n在没开放私有库之前，开发者只能使用国内的Coding、chinaos、CSDN、京东，或者国外的Bitbucket。\n\n那么现在可能会面临一个问题，就是如何将其他托管平台的私有库迁移到github上去呢？可以有如下几种方法。\n\n我使用chinaos往github上迁移为例，迁移项目名为RelocateTest。\n\n<!-- more -->\n\n### 方案一\n\n**1. 使用命令从chinaos导出一份裸体仓库代码**\n\n```\ngit clone --bare git@gitee.com:devjackcat/RelocateTest.git\n```\n\n使用--bare参数clone的代码是不是任何版本信息的，导出文件结构也和普通 git clone 不一样，其中包含了，branch信息、commit记录、tag等信息。\n\n![](http://static.devjackcat.com/15471753582310.jpg)\n\n**2. 在github新建一个RelocateTest项目**\n\n以镜像的形式进行push\n\n```\ngit push --mirror git@github.com:devjackcat/RelocateTest.git\n```\n从push结果中可以看到push了哪些内容\n![](http://static.devjackcat.com/15471771278565.jpg)\n可以看到推送了两个branch，两个tag\n\n**3. 登录github查看push结果，看到如下结果，则说明已迁移成功。**\n\n![](http://static.devjackcat.com/15471755629317.jpg)\n\n\n### 方案二\n\n直接在原仓库下更改仓库地址,但**这种方式只会同步当前分支的信息，其他branch，tag都不会同步不**\n\n**1. 更改仓库地址**\n\n```\ngit remote set-url origin git@github.com:devjackcat/RelocateTest.git\n```\n\n**2. push至新仓库**\n\n```\ngit push\n```\n\n### 方案三\n\n直接在github新建项目时，点击 \"import code\" 按钮，填入原项目地址(只能使用http方式进行import)，“Begin Import”即可。\n\n该方案无法导入私有库\n\n","tags":["Git项目迁移"],"categories":["Git"]},{"title":"iOS获取时间的方法","url":"%2F2018%2F03%2F06%2Fget-ios-time%2F","content":"\n# 记录时间的方法\n\n为了记录耗时，这样就需要在 pushCallRecord 和 popCallRecord 里记录下时间。下面列出一些计算一段代码开始到结束的时间的方法\n\n<!-- more -->\n\n第一种： NSDate 微秒\n\n```\nNSDate* tmpStartData = [NSDate date];\n//some code need caculate\ndouble deltaTime = [[NSDate date] timeIntervalSinceDate:tmpStartData];\nNSLog(@\"cost time: %f s\", deltaTime);\n```\n\n第二种：clock_t 微秒clock_t计时所表示的是占用CPU的时钟单元\n\n```\nclock_t start = clock();\n//some code need caculate\nclock_t end = clock();\nNSLog(@\"cost time: %f s\", (double)(end - start)/CLOCKS_PER_SEC);\n```\n\n第三种：CFAbsoluteTime 微秒\n\n```\nCFAbsoluteTime start = CFAbsoluteTimeGetCurrent();\n//some code need caculate\nCFAbsoluteTime end = CFAbsoluteTimeGetCurrent();\nNSLog(@\"cost time = %f s\", end - start); //s\n```\n\n第四种：CFTimeInterval 纳秒\n\n```\nCFTimeInterval start = CACurrentMediaTime();\n//some code need caculate\nCFTimeInterval end = CACurrentMediaTime();\nNSLog(@\"cost time: %f s\", end - start);\n```\n\n第五种：mach_absolute_time 纳秒\n\n```\nuint64_t start = mach_absolute_time ();\n//some code need caculate\nuint64_t end = mach_absolute_time ();\nuint64_t elapsed = 1e-9 *(end - start);\n```\n\n最后两种可用，本质区别\nNSDate 或 CFAbsoluteTimeGetCurrent() 返回的时钟时间将会会网络时间同步，从时钟 偏移量的角度。mach_absolute_time() 和 CACurrentMediaTime() 是基于内建时钟的。选择一种，加到 pushCallRecord 和 popCallRecord 里，相减就能够获得耗时。\n\n# 参考\n\n* [深入剖析 iOS 性能优化](https://xiaozhuanlan.com/topic/2847503196)\n\n\n","tags":["性能优化"],"categories":["性能优化"]},{"title":"字符串解析","url":"%2F2017%2F04%2F17%2Fstring-parsing%2F","content":"\n在几乎每一种计算机程序语言中，解析字符串都是我们不得不面对的问题。有时这些字符串以一种简单的格式出现，有时它们又变得很复杂。我们将利用多种方法把字符串转换成我们需要的东西。下面，我们将讨论正则表达式、扫描器、解析器以及在什么时候使用它们。\n\n<!-- more -->\n\n# 正则法 vs. 上下文无关文法（Context-Free Grammars）\n\n首先，介绍一点点背景知识：解析一个字符串，其实就是用特定的语言来描述它。例如：把 @\"42\" 解析成数字，我们会采用自然数来描述这个字符串。语言都是用语法来描述的，语法其实就是一些规则的集合，这些规则可以用字符串来描述。比如自然数，仅仅有一条规则：字符串的描述就是一个数字序列。这种语言也可以用标准 C 函数或者正则表达式来描述。如果我们用正则表达式来描述一种语言，我们就可以说它有正则语法。\n\n假设我们有一个表达式：\"1 + 2 * 3\"，解析它就不容易。像这种表达式，我们可以用归纳语法来描述。换句话说，就是有一种语法，它的规则就是指的是它们自己，有时候甚至是递归的方式。为了识别这种语法，我们有三个规则：\n\n1. 任何数字都是语言的成员。\n2. 如果 x 是语言的成员，同时 y 也是语言的成员，那么 x+y 也是语言的成员。\n3. 如果 x 是语言的成员，同时 y 也是语言的成员，那么 x*y 也是语言的成员。\n\n使用这种语法描述的语言称之为**上下文无关文法 (context-free grammars)**，或者简称 CFG 1。需要注意的是这种语法不能使用正则表达式来解析（虽然一些正则表达式能实现，如 PCRE，但这远远超越了一般的正则语法）。一个经典的例子就是括号匹配，它可以用 CFG 来解析，却不能用正则表达式 2。\n\n像数字，字符串和时间这些，就可以用正则语言来解析。意思是说你可以使用正则表达式（或者相似的技术）去解析它们。\n\n像邮箱地址，JSON，XML 以及其它大多数的编程语言，都不能够使用正则表达式来解析 3。我们需要一个真正的解析器来解析它们。大多数时候，我们需要的解析器就有现成的。苹果就已经为我们提供了 XML 和 JSON 解析器，如果想要解析 XML 和 JSON，用苹果的就可以了。\n\n# 正则表达式\n\n当你想要去识别一些简单的语言时，正则表达式是一个好工具。但是，它们经常被滥用在一些不适合它们的地方，比如 HTML 的解析。现在假定我们有一个文件, 其中包含一个简单的定义颜色的变量,设计者们可以利用该变量来改变你 iPhone app 中的颜色。格式如下:\n\n```\nbackgroundColor = #ff0000\n```\n\n想要解析这种格式，我们就可以用正则表达式。正则表达式中最重要的是**模式（pattern）**。如果你不知道什么是正则表达式，我们将很快的重新温习一下，但是完全的解释什么是正则表达式已经超出了这篇文章的范围。首先，我们来看一下 \\\\w+, 它的意思是匹配任何一个数字、字母或者是下划线至少一次（\\\\w 代表匹配任意一个数字、字母或者是下划线，+ 代表至少匹配一次）。然后，为了确保我们以后可以使用匹配的结果，需要用括号将它括起来，创建一个**捕获组（capture group）**。接下来是一个空格符，一个等号，又一个空格符和一个 # 号。然后，我们需要匹配 6 个十六进制数字。\\\\p{Hex_Digit} 意思是匹配一个十六进制数字（Hex_Digit 是一个 unicode 属性名）。修饰符 {6} 意味着我们需要匹配 6 个，然后和之前一样，把这些一起用括号括起来，这样就创建了第二个捕获组:\n\n```\nNSError *error = nil;\nNSString *pattern = @\"(\\\\w+) = #(\\\\p{Hex_Digit}{6})\";\nNSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:pattern\n                                                                            options:0\n                                                                              error:&error];\nNSTextCheckingResult *result = [expression firstMatchInString:string \n                                                      options:0\n                                                        range:NSMakeRange(0, string.length)];\nNSString *key = [string substringWithRange:[result rangeAtIndex:1]];\nNSString *value = [string substringWithRange:[result rangeAtIndex:2]];\n```\n\n上面我们创建了一个正则表达式对象，让它匹配一个字符串对象 string，通过 rangeAtIndex 方法可以获取用括号捕获的两组数据。在匹配的结果对象中，索引 0 是正则表达式对象自己，索引 1 是第一个捕获组，索引 2 是第二个捕获组，依此类推。最后，我们获取到的 key 的值是 backgroundColor，value 的值是 ff0000。上面的正则表达式只解析了一行，下一步我们将要解析多行，并添加一些错误检查。比如，输入如下：\n\n```\nbackgroundColor = #ff0000\ntextColor = #0000ff\n```\n\n首先，利用换行符将输入字符串分隔开，然后遍历返回的数组，并将解析的结果添加到我们的字典中，最后我们将生成这样一个字典：@{@\"backgroundColor\": @\"ff0000\", @\"textColor\": @\"0000ff\"}。下面是具体的代码：\n\n```\nNSString *pattern = @\"(\\\\w+) = #([\\\\da-f]{6})\";\nNSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:pattern\n                                                                            options:0 \n                                                                              error:NULL];\nNSArray *lines = [input componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];\nNSMutableDictionary *result = [NSMutableDictionary dictionary];\nfor (NSString *line in lines) {\n    NSTextCheckingResult *textCheckingResult = [expression firstMatchInString:line \n                                                                      options:0 \n                                                                        range:NSMakeRange(0, line.length)];\n    NSString* key = [line substringWithRange:[textCheckingResult rangeAtIndex:1]];\n    NSString* value = [line substringWithRange:[textCheckingResult rangeAtIndex:2]];\n    result[key] = value;\n}\nreturn result;\n```\n\n说句题外话，将字符串分解成数组，你还可以用 componentsSeparatedByString: 这个方法，或者用 enumerateSubstringsInRange:options:usingBlock: 这个方法来枚举子串，其中 option 这个参数应该传 NSStringEnumerationByLines。\n\n假如某一行数据没有匹配上（比如，我们不小心忘记一个十六进制字符），我们可以检查 textCheckingResult 对象是否为 nil，如果为 nil，就抛出一个错误，代码如下：\n\n```\n if (!textCheckingResult) {\n     NSString* message = [NSString stringWithFormat:@\"Couldn't parse line: %@\", line]\n     NSDictionary *errorDetail = @{NSLocalizedDescriptionKey: message};\n     *error = [NSError errorWithDomain:MyErrorDomain code:FormatError userInfo:errorDetail];\n     return nil;\n }\n```\n\n# 扫描器（Scanner）\n\n把一个字符串转化为一个字典，还有一种方式就是使用扫描器。幸运的是，Foundation 框架为我们提供了 NSScanner，一个易于使用的面向对象的API。首先，我们需要创建一个扫描器：\n\n```\nNSScanner *scanner = [NSScanner scannerWithString:string];\n```\n\n默认情况下，扫描器会跳过所有空格符和换行符。但这里我们只希望跳过空格符：\n\n```\nscanner.charactersToBeSkipped = [NSCharacterSet whitespaceCharacterSet];\n```\n\n然后,我们定义一个十六进制字符集。系统定义了很多字符集，但却没有十六进制字符集：\n\n```\nNSCharacterSet *hexadecimalCharacterSet = \n  [NSCharacterSet characterSetWithCharactersInString:@\"0123456789abcdefABCDEF\"];\n```\n\n我们先写一个没有错误检查的版本。扫描器的工作原理是这样的：它接收一个字符串，并将光标设置在字符串的开始处。然后调用扫描方法，像这样：[sanner scanString:@\"=\" intoString:NULL]。如果扫描成功，该方法会返回 YES，光标会自动后移。scanCharactersFromSet:intoString: 方法的工作原理和之前的相似，只不过它扫描的是字符集，并将扫描的结果放入第二个参数的字符串指针所指向的地址中。我们使用 && 对不同的扫描方法进行 “与” 操作。这种方式的好处是只有与 && 操作符左边的扫描成功时，&& 右边的扫描方法才会被调用。\n\n```\nNSMutableDictionary *result = [NSMutableDictionary dictionary];\nwhile (!scanner.isAtEnd) {\n    NSString *key = nil;\n    NSString *value = nil;\n    NSCharacterSet *letters = [NSCharacterSet letterCharacterSet];\n    BOOL didScan = [scanner scanCharactersFromSet:letters intoString:&key] &&\n                   [scanner scanString:@\"=\" intoString:NULL] &&\n                   [scanner scanString:@\"#\" intoString:NULL] &&\n                   [scanner scanCharactersFromSet:hexadecimalCharacterSet intoString:&value] &&\n                   value.length == 6;\n    result[key] = value;\n    [scanner scanCharactersFromSet:[NSCharacterSet newlineCharacterSet] \n                        intoString:NULL]; // 继续扫描下一行\n}\nreturn result;\n```\n\n接下来添加一个有错误处理的版本，我们可以在 didScan 该行后面开始写。如果扫描不成功，我们就返回 nil，并设置相应的 error 参数。在解析文本时，当输入字符串格式不正确时，这个时候应该怎么办呢？是让解析器崩溃，将错误值呈现给用户，还是尝试从错误中恢复，这值得我们仔细地思考清楚：\n\n```\n if (!didScan) {\n        NSString *message = [NSString stringWithFormat:@\"Couldn't parse: %u\", scanner.scanLocation];\n        NSDictionary *errorDetail = @{NSLocalizedDescriptionKey: message};\n        *error = [NSError errorWithDomain:MyErrorDomain code:FormatError userInfo:errorDetail];\n        return nil;\n    }\n```\n\nC 语言也提供了具有扫描器功能的函数,例如 sscanf（可以用 man sscanf 查看怎么使用）。它遵循和 printf 类似的语法，只不过操作是逆序的（它是解析一个字符串, 而不是生成一个）。\n\n# 解析器\n\n如果设计者希望像 (100,0,255) 这样来定义 RGB 颜色，该怎么办呢？我们必须让解析颜色的方法更智能一些。事实上，在完成后面的代码后，我们就已经会写一个基本的解析器了。\n\n首先，我们将添加一些方法到我们类中，并声明一个属性，类型为 NSScanner。第一个方法是 scanColor:，其作用是扫描十六进制的颜色值（例如 ff0000）或者 RGB 元组，例如(255,0,0)：\n\n```\n- (NSDictionary *)parse:(NSString *)string error:(NSError **)error\n{\n    self.scanner = [NSScanner scannerWithString:string];\n    self.scanner.charactersToBeSkipped = [NSCharacterSet whitespaceCharacterSet];\n\n    NSMutableDictionary *result = [NSMutableDictionary dictionary];\n    NSCharacterSet *letters = [NSCharacterSet letterCharacterSet]\n    while (!self.scanner.isAtEnd) {\n        NSString *key = nil;\n        UIColor *value = nil;\n        BOOL didScan = [self.scanner scanCharactersFromSet:letters intoString:&key] &&\n                       [self.scanner scanString:@\"=\" intoString:NULL] &&\n                       [self scanColor:&value];\n        result[key] = value;\n        [self.scanner scanCharactersFromSet:[NSCharacterSet newlineCharacterSet]\n                                 intoString:NULL]; // 继续扫描下一行\n    }\n}\n```\n\nscanColor: 这个方法非常简单。首先，它试图扫描一个十六进制的颜色值，如果失败，它会尝试扫描 RGB 元组：\n\n```\n- (BOOL)scanColor:(UIColor **)out\n{\n    return [self scanHexColorIntoColor:out] || [self scanTupleColorIntoColor:out];\n}\n```\n\n扫描一个十六进制颜色和之前是一样的。唯一的区别是我们将其封装在一个方法中, 并且使用的都是 NSScanner 的方法。它会返回一个 BOOL 值表示扫描成功，并将结果存储到一个指向 UIColor 对象的指针：\n\n```\n- (BOOL)scanHexColorIntoColor:(UIColor **)out\n{\n    NSCharacterSet *hexadecimalCharacterSet = \n       [NSCharacterSet characterSetWithCharactersInString:@\"0123456789abcdefABCDEF\"];\n    NSString *colorString = NULL;\n    if ([self.scanner scanString:@\"#\" intoString:NULL] &&\n        [self.scanner scanCharactersFromSet:hexadecimalCharacterSet \n                                 intoString:&colorString] &&\n        colorString.length == 6) {\n        *out = [UIColor colorWithHexString:colorString];\n        return YES;\n    }\n    return NO;\n}\n```\n\n扫描基于 RGB 元组的颜色值也非常相似。在扫描 @\"(\" 时，我们进行了与操作。在生产环境代码中，我们可能需要更多的错误检查，例如确保整数的范围 0-255：\n\n```\n- (BOOL)scanTupleColorIntoColor:(UIColor **)out\n{\n    NSInteger red, green, blue = 0;\n    BOOL didScan = [self.scanner scanString:@\"(\" intoString:NULL] &&\n                   [self.scanner scanInteger:&red] &&\n                   [self.scanner scanString:@\",\" intoString:NULL] &&\n                   [self.scanner scanInteger:&green] &&\n                   [self.scanner scanString:@\",\" intoString:NULL] &&\n                   [self.scanner scanInteger:&blue] &&\n                   [self.scanner scanString:@\")\" intoString:NULL];\n    if (didScan) {\n        *out = [UIColor colorWithRed:(CGFloat)red/255.\n                               green:(CGFloat)green/255.\n                                blue:(CGFloat)blue/255. \n                               alpha:1];\n        return YES;\n    } else {\n        return NO;\n    }\n}\n```\n\n写一个扫描器，就是在逻辑上将多个可变的扫描值混合起来，并调用其它的一些方法。解析器不仅是一个非常吸引人的主题，还是一个强大的工具。一旦你知道如何编写一个解析器，你就可以发明一些小语言，如定义样式表、解析约束、查询数据模型、描述业务逻辑，等等。关于这个话题 Fowler 写了一本非常有趣的书，名为[《领域特定语言》](https://martinfowler.com/books/dsl.html)。\n\n# 标记化（Tokenization）\n\n我们已经有一个非常简单的解析器，它可以从一个文件中的字符串中提取键值对，我们也可以使用这些字符串生成 UIColor 对象。但是还没有完。要是设计者想要定义更多的事情，怎么办？比如，假设我们有不同的文件，其中包含一些布局的约束，格式如下：\n\n```\nmyView.left = otherView.right * 2 + 10\nviewController.view.centerX + myConstant <= self.view.centerX\n```\n\n我们该如何解析这个呢？实践证明正则表达式并不是最好的方法。\n\n在我们进行解析之前，先把这个字符串进行标记化是一个不错的主意。标记化就是将一个字符串转换成一连串标记 (token)的过程。 例如，myConstant = 100 被标记化的结果可能会是 @[@\"myConstant\", @\"=\", @100]。在大多数程序语言中, 标记化就是删除空白符并将相关的字符解析成标记。在我们的语言中，标记可以是标识符（如 myConstant 或 centerX），操作符（如 .，+ 或 =）或数字（如 100）。在标记化之后，标记会继续被解析。\n\n为了实现标记化（有时也称为词法分析 lexing 或扫描 scanning），我们可以重用 NSScanner 类。首先，我们可以专注于解析只包含操作符的字符串：\n\n\n```\nNSScanner *scanner = [NSScanner scannerWithString:contents];\nNSMutableArray *tokens = [NSMutableArray array];\nwhile (![scanner isAtEnd]) {\n  for (NSString *operator in @[@\"=\", @\"+\", @\"*\", @\">=\", @\"<=\", @\".\"]) {\n      if ([scanner scanString:operator intoString:NULL]) {\n          [tokens addObject:operator];\n      }\n  }\n}\n```\n\n下一步是识别像 myConstant 和 viewController 这样的标识符。为了简单起见，标识符只包含字母（没有数字）。如下：\n\n```\nNSString *result = nil;\nif ([scanner scanCharactersFromSet:[NSCharacterSet letterCharacterSet] \n                        intoString:&result]) {\n    [tokens addObject:result];\n}\n```\n\n如果这些字符被找到，scanCharactersFromSet:intoString: 这个方法会返回 YES，然后我们将这些找到的字符添加到我们的标记数组。我们快要完成了，唯一剩下的事情就是是解析数字了。幸运的是，NSScanner 也提供了一些方法。我们可以使用 scanDouble: 方法来扫描 double 类型数据，并将其封装成 NSNumber 对象然后添加到标记数组：\n\n```\ndouble doubleResult = 0;\nif ([scanner scanDouble:&doubleResult]) {\n    [tokens addObject:@(doubleResult)];\n}\n```\n\n现在我们的解析器完成了，下面我们来进行测试：\n\n```\nNSString* example = @\"myConstant = 100\\n\"\n                    @\"\\nmyView.left = otherView.right * 2 + 10\\n\"\n                    @\"viewController.view.centerX + myConstant <= self.view.centerX\";\nNSArray *result = [self.scanner tokenize:example];\nNSArray *expected = @[@\"myConstant\", @\"=\", @100, @\"myView\", @\".\", @\"left\", \n                      @\"=\", @\"otherView\", @\".\", @\"right\", @\"*\", @2, @\"+\", \n                      @10, @\"viewController\", @\".\", @\"view\", @\".\", \n                      @\"centerX\", @\"+\", @\"myConstant\", @\"<=\", @\"self\", \n                      @\".\", @\"view\", @\".\", @\"centerX\"];\nXCTAssertEqualObjects(result, expected);\n```\n\n我们的扫描器可以对操作符，姓名，以及被封装成 NSNumber 对象的数字创建独立的标记。完成这些之后,我们准备进行第二步：把这个标记数组解析成更有意义的一些东西。\n\n## 语法解析（Parsing）\n\n我们之所以不能用正则表达式或扫描器来解决上述问题，是因为解析有可能失败。假定我们现在有一个标记：@“myConstant”。在我们的解析函数中，我们并不知道这是约束表达式的开始还是一个常数定义。我们需要两个都试一下，看看哪一个成功。我们可以手工来写这个解析代码，难倒是不难，但是写出来的代码就像一坨屎；或者我们可以使用更合适的工具：**语法解析库（parsing library）**。\n\n首先，我们需要语法分析库能理解的方式来描述我们的语言。下面的代码就是专为我们那个布局约束语言写的解析语法，使用的是**扩展的巴科斯范式**（EBNF）写法：\n\n```\nconstraint = expression comparator expression\ncomparator = \"=\" | \">=\" | \"<=\"\nexpression = keyPath \".\" attribute addMultiplier addConstant\nkeyPath = identifier | identifier \".\" keyPath\nattribute = \"left\" | \"right\" | \"top\" | \"bottom\" | \"leading\" | \"trailing\" | \"width\" | \"height\" | \"centerX\" | \"centerY\" | \"baseline\"\naddMultiplier = \"*\" atom\naddConstant = \"+\" atom\natom = number | identifier\n```\n\n有许多的 Objective-C 库用于语法解析（参见 CocoaPods）。像 CoreParse 就提供了很多 Objective-C 的 API。然而，我们并不能直接将我们的语法应用在它上面。CoreParse 一次仅仅只有一个解析器工作。这意味着每当解析器需要在两个规则之间做决定（比如 keyPath 规则）的时候，它会根据下一个标记来做决定。如果事后我们发现它选错了，那麻烦就大了。当然有的解析器允许更模糊的语法，但性能损失很大。\n\n为了确保能够兼容语法分析库，可以对我们的语法做一些重构。 我们也可以将它转换成标准的巴科斯范式（BNF），下面的代码就是 CoreParse 支持的格式：\n\n```\nNSString* grammarString = [@[\n    @\"Atom ::= num@'Number' | ident@'Identifier';\",\n    @\"Constant ::= name@'Identifier' '=' value@<Atom>;\",\n    @\"Relation ::= '=' | '>=' | '<=';\",\n    @\"Attribute ::= 'left' | 'right' | 'top' | 'bottom' | 'leading' | 'trailing' | 'width' | 'height' | 'centerX' | 'centerY' | 'baseline';\",\n    @\"Multiplier ::= '*' num@'Number';\",\n    @\"AddConstant ::= '+' num@'Number';\",\n    @\"KeypathAndAttribute ::= 'Identifier' '.' <AttributeOrRest>;\",\n    @\"AttributeOrRest ::= att@<Attribute> | 'Identifier' '.' <AttributeOrRest>;\",\n    @\"Expression ::= <KeypathAndAttribute> <Multiplier>? <AddConstant>?;\",\n    @\"LayoutConstraint ::= lhs@<Expression> rel@<Relation> rhs@<Expression>;\",\n    @\"Rule ::= <Atom> | <LayoutConstraint>;\",\n] componentsJoinedByString:@\"\\n\"];\n```\n\n如果一个规则被匹配了，那么这个解析器就试图找到具有同样名称的类（如 Expression）。如果这个类实现了 initWithSyntaxTree: 方法，那么该方法就会被调用。另外，解析器还有一个委托，当有一个规则被匹配上或者发生错误时，委托都会被调用。举例来说，我们先来看一下 CPSyntaxTree 类，它的第一个子节点是一个关键字标记（调用 keyword 方法获取），它可能包含 @\"=\"，@\">=\" 或者 @\"<=\" 中的任意一个。属性 layoutAttributes 是一个字典，它的 key 是一个字符串，value 是一个关于布局的 NSNumber 对象：\n\n```\n- (id)parser:(CPParser *)parser didProduceSyntaxTree:(CPSyntaxTree *)syntaxTree\n    NSString *ruleName = syntaxTree.rule.name;\n    if ([ruleName isEqualToString:@\"Attribute\"]) {\n        return self.layoutAttributes[[[syntaxTree childAtIndex:0] keyword]];\n    }\n    ...\n```\n\n解析器的完整代码在 GitHub，其中有一个类，大约 100 行代码，我们可以用它解析复杂的布局约束，如:\n\n```\nviewController.view.centerX + 20 <= self.view.centerX * 0.5\n```\n\n我们会得到下面这样的结果，它可以很容易地转换成一个 NSLayoutConstraint 对象：\n\n```\n(<Expression: self.keyPath=(viewController, view), \n              self.attribute=9,\n              self.multiplier=1, \n              self.constant=20> \n -1 \n <Expression: self.keyPath=(self, view), \n              self.attribute=9,\n              self.multiplier=0.5,\n              self.constant=0>)\n```\n\n# 其他的工具\n\n除了 Objective-C 的库，其他的一些工具比如 Bison，Yacc，Ragel，以及 Lemon，都是用 C 语言实现的。\n\n另一件你可以做的事就是在 Build 时使用这些解析器生成一部分自己的代码。例如，一旦你有了一种语言的解析器，你就可以创建一个简单的命令行转换工具。添加一个 Xcode 的 Build 规则，每一次 Build 时，你自己的语言就会被一起编译。\n\n# 关于语法分析的思考\n\n语法分析看起来有一点奇怪，而且创建基于字符串的语言似乎并不是 Objective-C 的风格。但事实恰恰相反，苹果一直广泛使用着基于字符串的语言。如 NSLog 格式化字符串，NSPredicate 字符串，可视化的布局约束格式语言，甚至是 KVC。所有这些都用了一些小的内部解析器来解析字符串，并将其变成对象和方法。通常你不必自己编写一个解析器，这大大节省了工作时间：常见的语言如 JSON 和 XML 都有通用的解析器。但是如果你想要编写一个计算器，一种图形语言，甚至是一个嵌入式的 Smalltalk，解析器大有帮助。\n\n# 关于原文\n\n原英文地址：https://www.objc.io/issues/9-strings/string-parsing/\n原中文地址：https://objccn.io/issue-9-4/\n\n\n","categories":["iOS"]},{"title":"Mac终端设置","url":"%2F2017%2F04%2F13%2Fcomputer-setting%2Fcommand-line-prefix-setting%2F","content":"\n# 命令行前缀\n\n喜欢用命令行的人估计都遇到过这样的问题，每一个行命令前面都会有很长一个前缀：包含了计算机名和目录名，就像下图的样子。\n\n<!-- more -->\n\n![](/images/computer-setting/command-prefix-1.png)\n\n这一长串前缀看着实在碍眼，能否去掉呢？当然可以，下面就来去掉它。\n\n可以使用命令，编辑/etc/bashrc文件\n\n```\nsudo vim /etc/bashrc\n```\n\n![](/images/computer-setting/command-prefix-2.png)\n\n打开文件后，会看到`PS1='\\h:\\W \\u\\$ '`这一行，我们就在这行上面下手。\n\n1. 注释掉`PS1=’\\h:\\W \\u\\$ ‘`, 做备份\n2. 替换为`PS1=’\\W \\$’`\n\n执行强制退出的命令`wq!`,即可保存退出。\n\n至此已经修改好了，重新打开Terminal，可以看到效果\n\n![](/images/computer-setting/command-prefix-3.png)\n\n","tags":["终端"],"categories":["基础设置"]},{"title":"设计模式-工厂方法模式","url":"%2F2017%2F04%2F10%2Fdesign-pattern%2Fdesign-pattern-factory-method%2F","content":"\n简单工厂模式虽然简单，但存在一个很严重的问题。当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？工厂方法模式应运而生，本文将介绍第二种工厂模式——工厂方法模式。\n\n<!-- more -->\n\n# 日志记录器的设计\n\nSunny 软件公司欲开发一个系统运行日志记录器（Logger），该记录器可以通过多种途径保存系统的运行日志，如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，Sunny 公司的开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。如何封装记录器的初始化过程并保证多种记录器切换的灵活性是 Sunny 公司开发人员面临的一个难题。 \n\nSunny 公司的开发人员通过对该需求进行分析，发现该日志记录器有两个设计要点： \n\n1. 需要封装日志记录器的初始化过程，这些初始化工作较为复杂，例如需要初始化其他相关的类，还有可能需要读取配置文件（例如连接数据库或创建文件），导致代码较长，如果将它们都写在构造函数中，会导致构造函数庞大，不利于代码的修改和维护；\n\n2. 用户可能需要更换日志记录方式，在客户端代码中需要提供一种灵活的方式来选择日志记录器，尽量在不修改源代码的基础上更换或者增加日志记录方式。 \n\nSunny 公司开发人员最初使用简单工厂模式对日志记录器进行了设计，初始结构如图所示： \n\n![](/images/design-pattern/factory-method-1.jpeg)\n\n在图中，LoggerFactory 充当创建日志记录器的工厂，提供了工厂方法 createLogger() 用于创建日志记录器，Logger 是抽象日志记录器接口，其子类为具体日志记录器。其中，工厂类 LoggerFactory 代码片段如下所示：\n\n```\n//日志记录器工厂\nclass LoggerFactory {\n    //静态工厂方法\n    public static Logger createLogger(String args) {\n        if(args.equalsIgnoreCase(\"db\")) {\n            //连接数据库，代码省略\n            //创建数据库日志记录器对象\n            Logger logger = new DatabaseLogger(); \n            //初始化数据库日志记录器，代码省略\n            return logger;\n        }\n        else if(args.equalsIgnoreCase(\"file\")) {\n            //创建日志文件\n            //创建文件日志记录器对象\n            Logger logger = new FileLogger(); \n            //初始化文件日志记录器，代码省略\n            return logger;          \n        }\n        else {\n            return null;\n        }\n    }\n}\n```\n\n为了突出设计重点，我们对上述代码进行了简化，省略了具体日志记录器类的初始化代码。在 LoggerFactory 类中提供了静态工厂方法 createLogger()，用于根据所传入的参数创建各种不同类型的日志记录器。通过使用简单工厂模式，我们将日志记录器对象的创建和使用分离，客户端只需使用由工厂类创建的日志记录器对象即可，无须关心对象的创建过程，但是我们发现，虽然简单工厂模式实现了对象的创建和使用分离，但是仍然存在如下两个问题： \n\n1. 工厂类过于庞大，包含了大量的 if…else… 代码，导致维护和测试难度增大；\n\n2. 系统扩展不灵活，如果增加新类型的日志记录器，必须修改静态工厂方法的业务逻辑，违反了“开闭原则”。\n\n如何解决这两个问题，提供一种简单工厂模式的改进方案？这就是本文所介绍的工厂方法模式的动机之一。\n\n# 工厂方法模式概述\n\n在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则”。此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。 \n\n在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。工厂方法模式定义如下： \n\n工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。 \n\n工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。工厂方法模式结构如图所示： \n\n![](/images/design-pattern/factory-method-2.jpeg)\n\n在工厂方法模式结构图中包含如下几个角色： \n\n* Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。\n* ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。 \n* Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。 \n* ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 \n\n与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：\n\n```\ninterface Factory {  \n    public Product factoryMethod();  \n}  \n```\n\n在抽象工厂中声明了工厂方法但并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时再指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品，其典型代码如下所示： \n\n```\nclass ConcreteFactory implements Factory {  \n    public Product factoryMethod() {  \n        return new ConcreteProduct();  \n    }  \n}  \n```\n\n在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。\n\n在客户端代码中，只需关心工厂类即可，不同的具体工厂可以创建不同的产品，典型的客户端类代码片段如下所示： \n\n```\nFactory factory;  \nfactory = new ConcreteFactory(); //可通过配置文件实现  \nProduct product;  \nproduct = factory.factoryMethod();  \n```\n\n可以通过配置文件来存储具体工厂类 ConcreteFactory 的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。 \n\n>思考：工厂方法模式中的工厂方法能否为静态方法？为什么？\n\n# 完整解决方案\n\nSunny 公司开发人员决定使用工厂方法模式来设计日志记录器，其基本结构如图所示：\n\n![](/images/design-pattern/factory-method-3.jpeg)\n\n在图中，Logger 接口充当抽象产品，其子类 FileLogger 和 DatabaseLogger 充当具体产品，LoggerFactory 接口充当抽象工厂，其子类 FileLoggerFactory 和 DatabaseLoggerFactory 充当具体工厂。完整代码如下所示：\n\n```\n//日志记录器接口：抽象产品\ninterface Logger {\n    public void writeLog();\n}\n\n//数据库日志记录器：具体产品\nclass DatabaseLogger implements Logger {\n    public void writeLog() {\n        System.out.println(\"数据库日志记录。\");\n    }\n}\n\n//文件日志记录器：具体产品\nclass FileLogger implements Logger {\n    public void writeLog() {\n        System.out.println(\"文件日志记录。\");\n    }\n}\n\n//日志记录器工厂接口：抽象工厂\ninterface LoggerFactory {\n    public Logger createLogger();\n}\n\n//数据库日志记录器工厂类：具体工厂\nclass DatabaseLoggerFactory implements LoggerFactory {\n    public Logger createLogger() {\n            //连接数据库，代码省略\n            //创建数据库日志记录器对象\n            Logger logger = new DatabaseLogger(); \n            //初始化数据库日志记录器，代码省略\n            return logger;\n    }   \n}\n\n//文件日志记录器工厂类：具体工厂\nclass FileLoggerFactory implements LoggerFactory {\n    public Logger createLogger() {\n            //创建文件日志记录器对象\n            Logger logger = new FileLogger(); \n            //创建文件，代码省略\n            return logger;\n    }   \n}\n```\n\n编写如下客户端测试代码：\n\n```\nclass Client {\n    public static void main(String args[]) {\n        LoggerFactory factory;\n        Logger logger;\n        factory = new FileLoggerFactory(); //可引入配置文件实现\n        logger = factory.createLogger();\n        logger.writeLog();\n    }\n}\n```\n\n编译并运行程序，输出结果如下： \n\n```\n文件日志记录。\n```\n\n## 反射与配置文件\n\n为了让系统具有更好的灵活性和可扩展性，Sunny 公司开发人员决定对日志记录器客户端代码进行重构，使得可以在不修改任何客户端代码的基础上更换或增加新的日志记录方式。 \n\n在客户端代码中将不再使用 new 关键字来创建工厂对象，而是将具体工厂类的类名存储在配置文件（如 XML 文件）中，通过读取配置文件获取类名字符串，再使用Java的反射机制，根据类名字符串生成对象。在整个实现过程中需要用到两个技术：Java 反射机制与配置文件读取。软件系统的配置文件通常为XML文件，我们可以使用 DOM (Document Object Model)、SAX (Simple API for XML)、StAX (Streaming API for XML)等技术来处理 XML文件。关于 DOM、SAX、StAX 等技术的详细学习大家可以参考其他相关资料，在此不予扩展。 \n\n## 扩展\n\n关于 Java 与 XML 的相关资料，大家可以阅读 Tom Myers 和 Alexander Nakhimovsky所著的《Java XML编程指南》一书或访问 developer Works 中国中的“Java XML 技术专题”。\n\nJava 反射（Java Reflection）是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。在反射中使用最多的类是 Class，Class 类的实例表示正在运行的 Java 应用程序中的类和接口，其 forName(String className)方法可以返回与带有给定字符串名的类或接口相关联的 Class对象，再通过 Class 对象的 newInstance() 方法创建此对象所表示的类的一个新实例，即通过一个类名字符串得到类的实例。如创建一个字符串类型的对象，其代码如下： \n\n```\n  //通过类名生成实例对象并将其返回\n   Class c=Class.forName(\"String\");\n   Object obj=c.newInstance();\n   return obj;\n```\n\n此外，在 JDK 中还提供了 java.lang.reflect 包，封装了其他与反射相关的类，此处只用到上述简单的反射代码，在此不予扩展。\n\nSunny 公司开发人员创建了如下XML格式的配置文件 config.xml 用于存储具体日志记录器工厂类类名： \n\n```\n<!— config.xml -->\n<?xml version=\"1.0\"?>\n<config>\n    <className>FileLoggerFactory</className>\n</config>\n```\n\n为了读取该配置文件并通过存储在其中的类名字符串反射生成对象，Sunny 公司开发人员开发了一个名为 XMLUtil 的工具类，其详细代码如下所示： \n\n```\n//工具类XMLUtil.java\nimport javax.xml.parsers.*;\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\nimport java.io.*;\n\npublic class XMLUtil {\n//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象\n    public static Object getBean() {\n        try {\n            //创建DOM文档对象\n            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = dFactory.newDocumentBuilder();\n            Document doc;                           \n            doc = builder.parse(new File(\"config.xml\")); \n\n            //获取包含类名的文本节点\n            NodeList nl = doc.getElementsByTagName(\"className\");\n            Node classNode=nl.item(0).getFirstChild();\n            String cName=classNode.getNodeValue();\n\n            //通过类名生成实例对象并将其返回\n            Class c=Class.forName(cName);\n            Object obj=c.newInstance();\n            return obj;\n        }   \n        catch(Exception e) {\n            e.printStackTrace();\n            return null;\n         }\n    }\n}\n```\n\n有了 XMLUtil 类后，可以对日志记录器的客户端代码进行修改，不再直接使用 new 关键字来创建具体的工厂类，而是将具体工厂类的类名存储在 XML 文件中，再通过 XMLUtil 类的静态工厂方法 getBean() 方法进行对象的实例化，代码修改如下： \n\n```\nclass Client {\n    public static void main(String args[]) {\n        LoggerFactory factory;\n        Logger logger;\n        factory = (LoggerFactory)XMLUtil.getBean(); //getBean()的返回类型为Object，需要进行强制类型转换\n        logger = factory.createLogger();\n        logger.writeLog();\n    }\n}\n```\n\n引入 XMLUtil 类和 XML 配置文件后，如果要增加新的日志记录方式，只需要执行如下几个步骤：\n\n1. 新的日志记录器需要继承抽象日志记录器 Logger；\n\n2. 对应增加一个新的具体日志记录器工厂，继承抽象日志记录器工厂 LoggerFactory，并实现其中的工厂方法 createLogger()，设置好初始化参数和环境变量，返回具体日志记录器对象；\n\n3. 修改配置文件 config.xml，将新增的具体日志记录器工厂类的类名字符串替换原有工厂类类名字符串；\n\n4. 编译新增的具体日志记录器类和具体日志记录器工厂类，运行客户端测试类即可使用新的日志记录方式，而原有类库代码无须做任何修改，完全符合“开闭原则”。\n\n通过上述重构可以使得系统更加灵活，由于很多设计模式都关注系统的可扩展性和灵活性，因此都定义了抽象层，在抽象层中声明业务方法，而将业务方法的实现放在实现层中。 \n\n## 思考\n\n有人说：可以在客户端代码中直接通过反射机制来生成产品对象，在定义产品对象时使用抽象类型，同样可以确保系统的灵活性和可扩展性，增加新的具体产品类无须修改源代码，只需要将其作为抽象产品类的子类再修改配置文件即可，根本不需要抽象工厂类和具体工厂类。\n\n试思考这种做法的可行性？如果可行，这种做法是否存在问题？为什么？\n\n# 重载的工厂方法\n\nSunny 公司开发人员通过进一步分析，发现可以通过多种方式来初始化日志记录器，例如可以为各种日志记录器提供默认实现；还可以为数据库日志记录器提供数据库连接字符串，为文件日志记录器提供文件路径；也可以将参数封装在一个 Object 类型的对象中，通过 Object 对象将配置参数传入工厂类。此时，可以提供一组重载的工厂方法，以不同的方式对产品对象进行创建。当然，对于同一个具体工厂而言，无论使用哪个工厂方法，创建的产品类型均要相同。如图4所示： \n\n![](/images/design-pattern/factory-method-4.jpeg)\n\n引入重载方法后，抽象工厂 LoggerFactory 的代码修改如下： \n\n```\ninterface LoggerFactory {  \n    public Logger createLogger();  \n    public Logger createLogger(String args);  \n    public Logger createLogger(Object obj);  \n}  \n```\n\n具体工厂类 DatabaseLoggerFactory 代码修改如下： \n\n```\nclass DatabaseLoggerFactory implements LoggerFactory {\n    public Logger createLogger() {\n            //使用默认方式连接数据库，代码省略\n            Logger logger = new DatabaseLogger(); \n            //初始化数据库日志记录器，代码省略\n            return logger;\n    }\n\n    public Logger createLogger(String args) {\n            //使用参数args作为连接字符串来连接数据库，代码省略\n            Logger logger = new DatabaseLogger(); \n            //初始化数据库日志记录器，代码省略\n            return logger;\n    }   \n\n    public Logger createLogger(Object obj) {\n            //使用封装在参数obj中的连接字符串来连接数据库，代码省略\n            Logger logger = new DatabaseLogger(); \n            //使用封装在参数obj中的数据来初始化数据库日志记录器，代码省略\n            return logger;\n    }   \n}\n\n//其他具体工厂类代码省略\n```\n\n在抽象工厂中定义多个重载的工厂方法，在具体工厂中实现了这些工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同产品对象的需求。 \n\n# 工厂方法的隐藏\n\n有时候，为了进一步简化客户端的使用，还可以对客户端隐藏工厂方法，此时，在工厂类中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法。\n\n如果对客户端隐藏工厂方法，日志记录器的结构图将修改为图 5 所示：\n\n![](/images/design-pattern/factory-method-5.jpeg)\n\n在图中，抽象工厂类 LoggerFactory 的代码修改如下： \n\n```\n//改为抽象类\nabstract class LoggerFactory {\n    //在工厂类中直接调用日志记录器类的业务方法writeLog()\n    public void writeLog() {\n        Logger logger = this.createLogger();\n        logger.writeLog();\n    }\n\n    public abstract Logger createLogger();  \n}\n```\n\n通过将业务方法的调用移入工厂类，可以直接使用工厂对象来调用产品对象的业务方法，客户端无须直接使用工厂方法，在某些情况下我们也可以使用这种设计方案。 \n\n# 总结\n\n工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和 API 类库的核心模式。 \n\n## 主要优点\n\n1. 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。\n\n2. 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。\n\n3. 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 \n\n## 主要缺点\n\n1. 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。\n\n2. 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到 DOM、反射等技术，增加了系统的实现难度。 \n\n## 适用场景\n\n1. 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。\n\n2. 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 \n\n>练习:使用工厂方法模式设计一个程序来读取各种不同类型的图片格式，针对每一种图片格式都设计一个图片读取器，如 GIF 图片读取器用于读取 GIF 格式的图片、JPG 图片读取器用于读取 JPG 格式的图片。需充分考虑系统的灵活性和可扩展性。\n\n","categories":["设计模式"]},{"title":"设计模式-简单工厂模式","url":"%2F2017%2F04%2F10%2Fdesign-pattern%2Fdesign-pattern-simple-factory%2F","content":"\n工厂模式是最常用的一类创建型设计模式，通常我们所说的工厂模式是指工厂方法模式，它也是使用频率最高的工厂模式。本章将要学习的简单工厂模式是工厂方法模式的“小弟”，它不属于 GoF 23 种设计模式，但在软件开发中应用也较为频繁，通常将它作为学习其他工厂模式的入门。此外，工厂方法模式还有一位“大哥”——抽象工厂模式。这三种工厂模式各具特色，难度也逐个加大，在软件开发中它们都得到了广泛的应用，成为面向对象软件中常用的创建对象的工具。 \n\n<!-- more -->\n\n# 图表库的设计\n\nSunny 软件公司欲基于 Java 语言开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等。Sunny 软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。 \n\nSunny 软件公司图表库设计人员提出了一个初始设计方案，将所有图表的实现代码封装在一个 Chart 类中，其框架代码如下所示： \n\n```\nclass Chart {\n    private String type; //图表类型\n\n    public Chart(Object[][] data, String type) {\n        this.type = type;\n        if (type.equalsIgnoreCase(\"histogram\")) {\n            //初始化柱状图\n        }\n        else if (type.equalsIgnoreCase(\"pie\")) {\n            //初始化饼状图\n        }\n        else if (type.equalsIgnoreCase(\"line\")) {\n            //初始化折线图\n        }\n    }\n\n    public void display() {\n        if (this.type.equalsIgnoreCase(\"histogram\")) {\n            //显示柱状图\n        }\n        else if (this.type.equalsIgnoreCase(\"pie\")) {\n            //显示饼状图\n        }\n        else if (this.type.equalsIgnoreCase(\"line\")) {\n            //显示折线图\n        }   \n    }\n}\n```\n\n客户端代码通过调用 Chart 类的构造函数来创建图表对象，根据参数 type 的不同可以得到不同类型的图表，然后再调用 display() 方法来显示相应的图表。\n\n不难看出，Chart 类是一个“巨大的”类，在该类的设计中存在如下几个问题：\n\n1. 在 Chart 类中包含很多 if…else… 代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。\n\n2. Chart 类的职责过重，它负责初始化和显示所有的图表对象，将各种图表对象的初始化代码和显示代码集中在一个类中实现，违反了“单一职责原则”，不利于类的重用和维护；而且将大量的对象初始化代码都写在构造函数中将导致构造函数非常庞大，对象在创建时需要进行条件判断，降低了对象创建的效率。\n\n3. 当需要增加新类型的图表时，必须修改 Chart 类的源代码，违反了“开闭原则”。\n\n4. 客户端只能通过 new 关键字来直接创建 Chart 对象，Chart 类与客户端类耦合度较高，对象的创建和使用无法分离。\n\n5. 客户端在创建 Chart 对象之前可能还需要进行大量初始化设置，例如设置柱状图的颜色、高度等，如果在 Chart 类的构造函数中没有提供一个默认设置，那就只能由客户端来完成初始设置，这些代码在每次创建 Chart 对象时都会出现，导致代码的重复。\n\n面对一个如此巨大、职责如此重，且与客户端代码耦合度非常高的类，我们应该怎么办？本章将要介绍的简单工厂模式将在一定程度上解决上述问题。\n\n# 简单工厂概述\n\n简单工厂模式并不属于 GoF 23 个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下： \n\n首先将需要创建的各种不同对象（例如各种不同的 Chart 对象）的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。 \n\n简单工厂模式定义如下： \n\n>简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态（static）方法，因此简单工厂模式又被称为静态工厂方法（Static Factory Method）模式，它属于类创建型模式。 \n\n简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计，其结构如图所示：\n\n![](/images/design-pattern/simple-factory-1.jpeg)\n\n在简单工厂模式结构图中包含如下几个角色： \n\n* Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法 factoryMethod()，它的返回类型为抽象产品类型 Product。\n\n* Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。\n    \n* ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。\n\n在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用 new 关键字来创建对象，它是工厂模式家族中最简单的一员。 \n\n在使用简单工厂模式时，首先需要对产品类进行重构，**不能设计一个包罗万象的产品类，而需根据实际情况设计一个产品层次结构**，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：\n\n```\nabstract class Product {\n    //所有产品类的公共业务方法\n    public void methodSame() {\n        //公共方法的实现\n    }\n\n    //声明抽象业务方法\n    public abstract void methodDiff();\n}\n```\n\n在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示：\n\n```\nclass ConcreteProduct extends Product {\n    //实现业务方法\n    public void methodDiff() {\n        //业务方法的实现\n    }\n}\n```\n\n简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用 new 关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，典型的工厂类代码如下所示： \n\n```\nclass Factory {\n    //静态工厂方法\n    public static Product getProduct(String arg) {\n        Product product = null;\n        if (arg.equalsIgnoreCase(\"A\")) {\n            product = new ConcreteProductA();\n            //初始化设置product\n        }\n        else if (arg.equalsIgnoreCase(\"B\")) {\n            product = new ConcreteProductB();\n            //初始化设置product\n        }\n        return product;\n    }\n}\n```\n\n在客户端代码中，我们通过调用工厂类的工厂方法即可得到产品对象，典型代码如下所示： \n\n```\nclass Client {\n    public static void main(String args[]) {\n        Product product; \n        product = Factory.getProduct(\"A\"); //通过工厂类创建产品对象\n        product.methodSame();\n        product.methodDiff();\n    }\n}\n```\n\n# 完整解决方案\n\n为了将 Chart 类的职责分离，同时将 Chart 对象的创建和使用分离，Sunny 软件公司开发人员决定使用简单工厂模式对图表库进行重构，重构后的结构如图所示：\n\n![](/images/design-pattern/simple-factory-2.jpeg)\n\n在图中，Chart 接口充当抽象产品类，其子类HistogramChart、PieChart 和 LineChart 充当具体产品类，ChartFactory 充当工厂类。完整代码如下所示： \n\n```\n//抽象图表接口：抽象产品类\ninterface Chart {\n    public void display();\n}\n\n//柱状图类：具体产品类\nclass HistogramChart implements Chart {\n    public HistogramChart() {\n        System.out.println(\"创建柱状图！\");\n    }\n\n    public void display() {\n        System.out.println(\"显示柱状图！\");\n    }\n}\n\n//饼状图类：具体产品类\nclass PieChart implements Chart {\n    public PieChart() {\n        System.out.println(\"创建饼状图！\");\n    }\n\n    public void display() {\n        System.out.println(\"显示饼状图！\");\n    }\n}\n\n//折线图类：具体产品类\nclass LineChart implements Chart {\n    public LineChart() {\n        System.out.println(\"创建折线图！\");\n    }\n\n    public void display() {\n        System.out.println(\"显示折线图！\");\n    }\n}\n\n//图表工厂类：工厂类\nclass ChartFactory {\n    //静态工厂方法\n    public static Chart getChart(String type) {\n        Chart chart = null;\n        if (type.equalsIgnoreCase(\"histogram\")) {\n            chart = new HistogramChart();\n            System.out.println(\"初始化设置柱状图！\");\n        }\n        else if (type.equalsIgnoreCase(\"pie\")) {\n            chart = new PieChart();\n            System.out.println(\"初始化设置饼状图！\");\n        }\n        else if (type.equalsIgnoreCase(\"line\")) {\n            chart = new LineChart();\n            System.out.println(\"初始化设置折线图！\");            \n        }\n        return chart;\n    }\n}\n```\n\n编写如下客户端测试代码：\n\n```\nclass Client {\n    public static void main(String args[]) {\n        Chart chart;\n        chart = ChartFactory.getChart(\"histogram\"); //通过静态工厂方法创建产品\n        chart.display();\n    }\n}\n```\n\n编译并运行程序，输出结果如下：\n\n```\n创建柱状图！\n初始化设置柱状图！\n显示柱状图！\n```\n\n在客户端测试类中，我们使用工厂类的静态工厂方法创建产品对象，如果需要更换产品，只需修改静态工厂方法中的参数即可，例如将柱状图改为饼状图，只需将代码： \n\n```\nchart = ChartFactory.getChart(\"histogram\");\n```\n\n改为： \n\n```\nchart = ChartFactory.getChart(\"pie\");\n```\n\n编译并运行程序，输出结果如下： \n\n```\n创建饼状图！\n初始化设置饼状图！\n显示饼状图！\n```\n\n# 方案的改进\n\nSunny 软件公司开发人员发现在创建具体 Chart 对象时，每更换一个 Chart 对象都需要修改客户端代码中静态工厂方法的参数，客户端代码将要重新编译，这对于客户端而言，违反了“开闭原则”，有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？答案是肯定的，下面将介绍一种常用的实现方式。 \n\n我们可以将静态工厂方法的参数存储在 XML 或 properties 格式的配置文件中，如下 config.xml 所示： \n\n```\n<?xml version=\"1.0\"?>\n<config>\n    <chartType>histogram</chartType>\n</config>\n```\n\n再通过一个工具类 XMLUtil 来读取配置文件中的字符串参数，XMLUtil 类的代码如下所示：\n\n```\nimport javax.xml.parsers.*;\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\nimport java.io.*;\n\npublic class XMLUtil {\n    //该方法用于从XML配置文件中提取图表类型，并返回类型名\n    public static String getChartType() {\n        try {\n            //创建文档对象\n            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = dFactory.newDocumentBuilder();\n            Document doc;                           \n            doc = builder.parse(new File(\"config.xml\")); \n\n            //获取包含图表类型的文本节点\n            NodeList nl = doc.getElementsByTagName(\"chartType\");\n            Node classNode = nl.item(0).getFirstChild();\n            String chartType = classNode.getNodeValue().trim();\n            return chartType;\n        }   \n        catch(Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n```\n\n在引入了配置文件和工具类 XMLUtil 之后，客户端代码修改如下： \n\n```\nclass Client {\n    public static void main(String args[]) {\n        Chart chart;\n        String type = XMLUtil.getChartType(); //读取配置文件中的参数\n        chart = ChartFactory.getChart(type); //创建产品对象\n        chart.display();\n    }\n}\n```\n\n不难发现，在上述客户端代码中不包含任何与具体图表对象相关的信息，如果需要更换具体图表对象，只需修改配置文件 config.xml，无须修改任何源代码，符合“开闭原则”。 \n\n>思考：在简单工厂模式中增加新的具体产品时是否符合“开闭原则”？如果不符合，原有系统需作出哪些修改？ \n\n# 简单工厂模式的简化\n\n有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中，如图所示：\n\n![](/images/design-pattern/simple-factory-3.jpeg)\n\n在图中，客户端可以通过产品父类的静态工厂方法，根据参数的不同创建不同类型的产品子类对象，这种做法在 JDK 等类库和框架中也广泛存在。 \n\n# 总结\n\n简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。 \n\n## 主要优点\n\n* 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。\n\n* 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。\n\n* 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 \n\n## 主要缺点\n\n* 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。\n\n* 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。\n\n* 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。\n\n* 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 \n\n## 适用场景\n\n* 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。\n\n* 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。 \n\n>练习\n>使用简单工厂模式设计一个可以创建不同几何形状（如圆形、方形和三角形等）的绘图工具，每个几何图形都具有绘制 draw() 和擦除 erase() 两个方法，要求在绘制不支持的几何图形时，提示一个 UnSupportedShapeException。\n\n","categories":["设计模式"]},{"title":"设计模式原则-迪米特法则","url":"%2F2017%2F04%2F09%2Fdesign-pattern%2Fdesign-pattern-principle-5%2F","content":"\n# 定义\n\n一个对象应该对其他对象保持最少的了解。\n\n<!-- more -->\n\n# 问题由来\n\n类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。\n\n# 解决方案\n\n尽量降低类与类之间的耦合。\n\n自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。\n\n迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：**只与直接的朋友通信**。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为**直接的朋友**，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。\n\n举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。\n\n```\n //总公司员工\n    class Employee{\n        private String id;\n        public void setId(String id){\n            this.id = id;\n        }\n        public String getId(){\n            return id;\n        }\n    }\n\n    //分公司员工\n    class SubEmployee{\n        private String id;\n        public void setId(String id){\n            this.id = id;\n        }\n        public String getId(){\n            return id;\n        }\n    }\n\n    class SubCompanyManager{\n        public List getAllEmployee(){\n            List list = new ArrayList();\n            for(int i=0; i<100; i++){\n                SubEmployee emp = new SubEmployee();\n                //为分公司人员按顺序分配一个ID\n                emp.setId(\"分公司\"+i);\n                list.add(emp);\n            }\n            return list;\n        }\n    }\n\n    class CompanyManager{\n\n        public List getAllEmployee(){\n            List list = new ArrayList();\n            for(int i=0; i<30; i++){\n                Employee emp = new Employee();\n                //为总公司人员按顺序分配一个ID\n                emp.setId(\"总公司\"+i);\n                list.add(emp);\n            }\n            return list;\n        }\n\n        public void printAllEmployee(SubCompanyManager sub){\n            List list1 = sub.getAllEmployee();\n            for(SubEmployee e:list1){\n                System.out.println(e.getId());\n            }\n\n            List list2 = this.getAllEmployee();\n            for(Employee e:list2){\n                System.out.println(e.getId());\n            }\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            CompanyManager e = new CompanyManager();\n            e.printAllEmployee(new SubCompanyManager());\n        }\n    }\n```\n\n现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:\n\n```\nclass SubCompanyManager{\n        public List getAllEmployee(){\n            List list = new ArrayList();\n            for(int i=0; i<100; i++){\n                SubEmployee emp = new SubEmployee();\n                //为分公司人员按顺序分配一个ID\n                emp.setId(\"分公司\"+i);\n                list.add(emp);\n            }\n            return list;\n        }\n        public void printEmployee(){\n            List list = this.getAllEmployee();\n            for(SubEmployee e:list){\n                System.out.println(e.getId());\n            }\n        }\n    }\n\n    class CompanyManager{\n        public List getAllEmployee(){\n            List list = new ArrayList();\n            for(int i=0; i<30; i++){\n                Employee emp = new Employee();\n                //为总公司人员按顺序分配一个ID\n                emp.setId(\"总公司\"+i);\n                list.add(emp);\n            }\n            return list;\n        }\n\n        public void printAllEmployee(SubCompanyManager sub){\n            sub.printEmployee();\n            List list2 = this.getAllEmployee();\n            for(Employee e:list2){\n                System.out.println(e.getId());\n            }\n        }\n    }\n```\n\n修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。\n\n迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个\"中介\"来发生联系，例如本例中，总公司就是通过分公司这个\"中介\"来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。 \n\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/principle-5.html]\n\n","categories":["设计模式"]},{"title":"设计模式原则-开闭原则","url":"%2F2017%2F04%2F09%2Fdesign-pattern%2Fdesign-pattern-principle-6%2F","content":"\n# 定义\n\n一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n<!-- more -->\n\n# 问题由来\n\n在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。\n\n# 解决方案\n\n当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。\n\n开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我\"你进行设计的时候一定要遵守开闭原则\"，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。\n\n在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的\"平均得分\"，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。\n\n其实笔者认为，开闭原则无非就是想表达这样一层意思：**用抽象构建框架，用实现扩展细节**。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。\n\n说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用**抽象构建框架，用实现扩展细节**的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。\n\n最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。\n\n![](/images/design-pattern/principle-6-1.gif)\n\n图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。\n\n![](/images/design-pattern/principle-6-2.gif)\n\n在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。\n\n到这里，设计模式的六大原则就写完了。主要参考书籍有《设计模式》《设计模式之禅》《大话设计模式》以及网上一些零散的文章，但主要内容主要还是我本人对这六个原则的感悟。写出来的目的一方面是对这六项原则系统地整理一下，一方面也与广大的网友分享，因为设计模式对编程人员来说，的确非常重要。正如有句话叫做一千个读者眼中有一千个哈姆雷特，如果大家对这六项原则的理解跟我有所不同，欢迎留言，大家共同探讨。\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/principle-6.html]\n\n","categories":["设计模式"]},{"title":"设计模式原则-单一职责","url":"%2F2017%2F04%2F08%2Fdesign-pattern%2Fdesign-pattern-principle-1%2F","content":"\n# 定义\n\n不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。\n\n<!-- more -->\n\n# 问题由来\n\n类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。\n\n# 解决方案\n\n遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。\n\n说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。**所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2**。\n\n比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）\n\n举例说明，用一个类描述动物呼吸这个场景：\n\n```\nclass Animal{\n        public void breathe(String animal){\n            System.out.println(animal+\"呼吸空气\");\n        }\n    }\n    public class Client{\n        public static void main(String[] args){\n            Animal animal = new Animal();\n            animal.breathe(\"牛\");\n            animal.breathe(\"羊\");\n            animal.breathe(\"猪\");\n        }\n    }\n```\n\n运行结果：\n\n```\n牛呼吸空气  \n羊呼吸空气  \n猪呼吸空气\n```\n\n程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：\n\n```\nclass Terrestrial{\n        public void breathe(String animal){\n            System.out.println(animal+\"呼吸空气\");\n        }\n    }\n    class Aquatic{\n        public void breathe(String animal){\n            System.out.println(animal+\"呼吸水\");\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            Terrestrial terrestrial = new Terrestrial();\n            terrestrial.breathe(\"牛\");\n            terrestrial.breathe(\"羊\");\n            terrestrial.breathe(\"猪\");\n\n            Aquatic aquatic = new Aquatic();\n            aquatic.breathe(\"鱼\");\n        }\n    }\n```\n\n运行结果：\n\n```\n牛呼吸空气  \n羊呼吸空气  \n猪呼吸空气  \n鱼呼吸水\n```\n\n我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：\n\n```\nclass Animal{\n        public void breathe(String animal){\n            if(\"鱼\".equals(animal)){\n                System.out.println(animal+\"呼吸水\");\n            }else{\n                System.out.println(animal+\"呼吸空气\");\n            }\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            Animal animal = new Animal();\n            animal.breathe(\"牛\");\n            animal.breathe(\"羊\");\n            animal.breathe(\"猪\");\n            animal.breathe(\"鱼\");\n        }\n    }\n```\n\n可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用\"猪\"\"牛\"\"羊\"等相关功能带来风险，也许某一天你会发现程序运行的结果变为\"牛呼吸水\"了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：\n\n```\nclass Animal{\n        public void breathe(String animal){\n            System.out.println(animal+\"呼吸空气\");\n        }\n\n        public void breathe2(String animal){\n            System.out.println(animal+\"呼吸水\");\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            Animal animal = new Animal();\n            animal.breathe(\"牛\");\n            animal.breathe(\"羊\");\n            animal.breathe(\"猪\");\n            animal.breathe2(\"鱼\");\n        }\n    }\n```\n\n可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；\n\n例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。\n\n遵循单一职责原的优点有：\n\n* 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；\n* 提高类的可读性，提高系统的可维护性；\n* 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。\n\n需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。 \n\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/principle-1.html]\n\n","categories":["设计模式"]},{"title":"设计模式原则-接口隔离原则","url":"%2F2017%2F04%2F08%2Fdesign-pattern%2Fdesign-pattern-principle-4%2F","content":"\n# 定义\n\n客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。\n\n<!-- more -->\n\n# 问题由来\n\n类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。\n\n# 解决方案\n\n将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。\n\n举例来说明接口隔离原则：\n\n![图 1 - 未遵循接口隔离原则的设计](/images/design-pattern/principle-4-1.jpeg)\n\n这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下：\n\n```\ninterface I {\n        public void method1();\n        public void method2();\n        public void method3();\n        public void method4();\n        public void method5();\n    }\n\n    class A{\n        public void depend1(I i){\n            i.method1();\n        }\n        public void depend2(I i){\n            i.method2();\n        }\n        public void depend3(I i){\n            i.method3();\n        }\n    }\n\n    class B implements I{\n        public void method1() {\n            System.out.println(\"类B实现接口I的方法1\");\n        }\n        public void method2() {\n            System.out.println(\"类B实现接口I的方法2\");\n        }\n        public void method3() {\n            System.out.println(\"类B实现接口I的方法3\");\n        }\n        //对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，\n        //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。\n        public void method4() {}\n        public void method5() {}\n    }\n\n    class C{\n        public void depend1(I i){\n            i.method1();\n        }\n        public void depend2(I i){\n            i.method4();\n        }\n        public void depend3(I i){\n            i.method5();\n        }\n    }\n\n    class D implements I{\n        public void method1() {\n            System.out.println(\"类D实现接口I的方法1\");\n        }\n        //对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，\n        //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。\n        public void method2() {}\n        public void method3() {}\n\n        public void method4() {\n            System.out.println(\"类D实现接口I的方法4\");\n        }\n        public void method5() {\n            System.out.println(\"类D实现接口I的方法5\");\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            A a = new A();\n            a.depend1(new B());\n            a.depend2(new B());\n            a.depend3(new B());\n\n            C c = new C();\n            c.depend1(new D());\n            c.depend2(new D());\n            c.depend3(new D());\n        }\n    }\n```\n\n可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：\n\n![图 2 - 遵循接口隔离原则的设计](/images/design-pattern/principle-4-2.jpeg)\n\n照例贴出程序的代码，供不熟悉类图的朋友参考：\n\n```\ninterface I1 {\n        public void method1();\n    }\n\n    interface I2 {\n        public void method2();\n        public void method3();\n    }\n\n    interface I3 {\n        public void method4();\n        public void method5();\n    }\n\n    class A{\n        public void depend1(I1 i){\n            i.method1();\n        }\n        public void depend2(I2 i){\n            i.method2();\n        }\n        public void depend3(I2 i){\n            i.method3();\n        }\n    }\n\n    class B implements I1, I2{\n        public void method1() {\n            System.out.println(\"类B实现接口I1的方法1\");\n        }\n        public void method2() {\n            System.out.println(\"类B实现接口I2的方法2\");\n        }\n        public void method3() {\n            System.out.println(\"类B实现接口I2的方法3\");\n        }\n    }\n\n    class C{\n        public void depend1(I1 i){\n            i.method1();\n        }\n        public void depend2(I3 i){\n            i.method4();\n        }\n        public void depend3(I3 i){\n            i.method5();\n        }\n    }\n\n    class D implements I1, I3{\n        public void method1() {\n            System.out.println(\"类D实现接口I1的方法1\");\n        }\n        public void method4() {\n            System.out.println(\"类D实现接口I3的方法4\");\n        }\n        public void method5() {\n            System.out.println(\"类D实现接口I3的方法5\");\n        }\n    }\n```\n\n接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的\"契约\"，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。\n\n说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。\n\n采用接口隔离原则对接口进行约束时，要注意以下几点：\n\n* 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。\n* 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。\n* 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。\n\n运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。\n\n\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/principle-4.html]\n\n","categories":["设计模式"]},{"title":"设计模式原则-依赖倒置原则","url":"%2F2017%2F04%2F08%2Fdesign-pattern%2Fdesign-pattern-principle-3%2F","content":"\n# 定义\n\n高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。\n\n<!-- more -->\n\n# 问题由来\n\n类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。\n\n# 解决方案\n\n将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。\n\n依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。\n\n依赖倒置原则的核心思想是**面向接口编程**，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：\n\n```\nclass Book{\n        public String getContent(){\n            return \"很久很久以前有一个阿拉伯的故事……\";\n        }\n    }\n\n    class Mother{\n        public void narrate(Book book){\n            System.out.println(\"妈妈开始讲故事\");\n            System.out.println(book.getContent());\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            Mother mother = new Mother();\n            mother.narrate(new Book());\n        }\n    }\n```\n\n运行结果:\n\n```\n妈妈开始讲故事  \n很久很久以前有一个阿拉伯的故事……\n```\n\n运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：\n\n```\nclass Newspaper{\n        public String getContent(){\n            return \"林书豪38+7领导尼克斯击败湖人……\";\n        }\n    }\n```\n\n这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。\n\n我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：\n\n```\ninterface IReader{\n        public String getContent();\n    }\n```\n\nMother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：\n\n```\nclass Newspaper implements IReader {\n        public String getContent(){\n            return \"林书豪17+9助尼克斯击败老鹰……\";\n        }\n    }\n    class Book implements IReader{\n        public String getContent(){\n            return \"很久很久以前有一个阿拉伯的故事……\";\n        }\n    }\n\n    class Mother{\n        public void narrate(IReader reader){\n            System.out.println(\"妈妈开始讲故事\");\n            System.out.println(reader.getContent());\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            Mother mother = new Mother();\n            mother.narrate(new Book());\n            mother.narrate(new Newspaper());\n        }\n    }\n```\n\n运行结果：\n\n```\n妈妈开始讲故事  \n很久很久以前有一个阿拉伯的故事……  \n妈妈开始讲故事  \n林书豪17+9助尼克斯击败老鹰……\n```\n\n这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。\n\n采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。\n\n传递依赖关系有三种方式，以上的例子中使用的方法是**接口传递*，另外还有两种传递方式：*构造方法传递和setter方法传递*，相信用过Spring框架的，对依赖的传递方式一定不会陌生。\n在实际编程中，我们一般需要做到如下3点：\n\n* 低层模块尽量都要有抽象类或接口，或者两者都有。\n* 变量的声明类型尽量是抽象类或接口。\n* 使用继承时遵循里氏替换原则。\n\n依赖倒置原则的核心就是要我们**面向接口编程**，理解了面向接口编程，也就理解了依赖倒置。 \n\n\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/principle-3.html]\n\n","categories":["设计模式"]},{"title":"设计模式原则-里氏替换原则","url":"%2F2017%2F04%2F08%2Fdesign-pattern%2Fdesign-pattern-principle-2%2F","content":"\n肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。\n\n<!-- more -->\n\n# 定义 1\n\n如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。\n\n# 定义 2\n\n所有引用基类的地方必须能透明地使用其子类的对象。\n\n# 问题由来\n\n有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。\n\n# 解决方案\n\n当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。\n\n继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。\n\n继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。\n\n举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。\n\n```\n class A{\n        public int func1(int a, int b){\n            return a-b;\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            A a = new A();\n            System.out.println(\"100-50=\"+a.func1(100, 50));\n            System.out.println(\"100-80=\"+a.func1(100, 80));\n        }\n    }\n```\n\n运行结果：\n\n```\n100-50=50  \n100-80=20\n```\n\n后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：\n\n* 两数相减。\n* 两数相加，然后再加100。\n\n由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：\n\n```\nclass B extends A{\n        public int func1(int a, int b){\n            return a+b;\n        }\n\n        public int func2(int a, int b){\n            return func1(a,b)+100;\n        }\n    }\n\n    public class Client{\n        public static void main(String[] args){\n            B b = new B();\n            System.out.println(\"100-50=\"+b.func1(100, 50));\n            System.out.println(\"100-80=\"+b.func1(100, 80));\n            System.out.println(\"100+20+100=\"+b.func2(100, 20));\n        }\n    }\n```\n\n类B完成后，运行结果：\n\n```\n100-50=150  \n100-80=180  \n100+20+100=220\n```\n\n我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。\n\n里氏替换原则通俗的来讲就是：**子类可以扩展父类的功能，但不能改变父类原有的功能**。它包含以下4层含义：\n\n* 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。\n* 子类中可以增加自己特有的方法。\n* 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。\n* 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。\n\n看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？\n\n后果就是：**你写的代码出问题的几率将会大大增加**。 \n\n\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/principle-2.html]\n\n","categories":["设计模式"]},{"title":"设计模式原则-目录","url":"%2F2017%2F04%2F08%2Fdesign-pattern%2Fdesign-pattern-principle-catalogue%2F","content":"\n设计模式的学习，可以增强自己的代码复用意识。同时，也可以清晰地表达自己的编程思路。本文将介绍设计模式的六大原则：\n\n<!-- more -->\n\n* [单一职责原则](http://blog.devjackcat.com/2017/04/08/design-pattern-principle-1/)\n* [里氏替换原则](http://blog.devjackcat.com/2017/04/08/design-pattern-principle-2/)\n* [依赖倒置原则](http://blog.devjackcat.com/2017/04/08/design-pattern-principle-3/)\n* [接口隔离原则](http://blog.devjackcat.com/2017/04/08/design-pattern-principle-4/)\n* [迪米特法则](http://blog.devjackcat.com/2017/04/09/design-pattern-principle-5/)\n* [开闭原则](http://blog.devjackcat.com/2017/04/09/design-pattern-principle-6/)\n\n\n\n[原文: http://wiki.jikexueyuan.com/project/java-design-pattern-principle/]\n\n","categories":["设计模式"]},{"title":"设计模式-命令模式","url":"%2F2017%2F04%2F08%2Fdesign-pattern%2Fdesign-pattern-command%2F","content":"\n装修新房的最后几道工序之一是安装插座和开关，通过开关可以控制一些电器的打开和关闭，例如电灯或者排气扇。在购买开关时，我们并不知道它将来到底用于控制什么电器，也就是说，开关与电灯、排气扇并无直接关系，一个开关在安装之后可能用来控制电灯，也可能用来控制排气扇或者其他电器设备。开关与电器之间通过电线建立连接，如果开关打开，则电线通电，电器工作；反之，开关关闭，电线断电，电器停止工作。相同的开关可以通过不同的电线来控制不同的电器，如图1所示：\n\n<!-- more -->\n\n![图1 开关与电灯、排气扇示意图](/images/design-pattern/command-1.jpeg)\n\n在图1中，我们可以将开关理解成一个请求的发送者，用户通过它来发送一个“开灯”请求，而电灯是“开灯”请求的最终接收者和处理者，在图中，开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者，只需更换一根电线，相同的发送者（开关）即可对应不同的接收者（电器）。\n\n在软件开发中也存在很多与开关和电器类似的请求发送者和接收者对象，例如一个按钮，它可能是一个“关闭窗口”请求的发送者，而按钮点击事件处理类则是该请求的接收者。为了降低系统的耦合度，将请求的发送者和接收者解耦，我们可以使用一种被称之为命令模式的设计模式来设计系统，在命令模式中，发送者与接收者之间引入了新的命令对象（类似图1中的电线），将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法。本章我们将学习用于将请求发送者和接收者解耦的命令模式。\n\n# 自定义功能键\n\nSunny软件公司开发人员为公司内部OA系统开发了一个桌面版应用程序，该应用程序为用户提供了一系列自定义功能键，用户可以通过这些功能键来实现一些快捷操作。Sunny软件公司开发人员通过分析，发现不同的用户可能会有不同的使用习惯，在设置功能键的时候每个人都有自己的喜好，例如有的人喜欢将第一个功能键设置为“打开帮助文档”，有的人则喜欢将该功能键设置为“最小化至托盘”，为了让用户能够灵活地进行功能键的设置，开发人员提供了一个“功能键设置”窗口，该窗口界面如图2所示：\n\n![图2  “功能键设置”界面效果图](/images/design-pattern/command-2.jpeg)\n\n通过如图2所示界面，用户可以将功能键和相应功能绑定在一起，还可以根据需要来修改功能键的设置，而且系统在未来可能还会增加一些新的功能或功能键。\n\nSunny软件公司某开发人员欲使用如下代码来实现功能键与功能处理类之间的调用关系：\n\n```\n//FunctionButton：功能键类，请求发送者\nclass FunctionButton {\n\tprivate HelpHandler help; //HelpHandler：帮助文档处理类，请求接收者\n\t\n    //在FunctionButton的onClick()方法中调用HelpHandler的display()方法\npublic void onClick() {\n\t\thelp = new HelpHandler();\n\t\thelp.display(); //显示帮助文档\n\t}\n}\n```\n\n在上述代码中，功能键类FunctionButton充当请求的发送者，帮助文档处理类HelpHandler充当请求的接收者，在发送者FunctionButton的onClick()方法中将调用接收者HelpHandler的display()方法。显然，如果使用上述代码，将给系统带来如下几个问题：\n\n1. 由于请求发送者和请求接收者之间存在方法的直接调用，耦合度很高，**更换请求接收者必须修改发送者的源代码**，如果需要将请求接收者HelpHandler改为WindowHanlder（窗口处理类），则需要修改FunctionButton的源代码，违背了“开闭原则”。\n\n2. FunctionButton类在设计和实现时功能已被固定，如果增加一个新的请求接收者，如果不修改原有的FunctionButton类，则必须增加一个新的与FunctionButton功能类似的类，**这将导致系统中类的个数急剧增加**。由于请求接收者HelpHandler、WindowHanlder等类之间可能不存在任何关系，它们没有共同的抽象层，因此也很难依据“依赖倒转原则”来设计FunctionButton。\n\n3. **用户无法按照自己的需要来设置某个功能键的功能**，一个功能键类的功能一旦固定，在不修改源代码的情况下无法更换其功能，系统缺乏灵活性。\n\n不难得知，所有这些问题的产生都是因为请求发送者FunctionButton类和请求接收者HelpHandler、WindowHanlder等类之间存在直接耦合关系，如何降低请求发送者和接收者之间的耦合度，让相同的发送者可以对应不同的接收者？这是Sunny软件公司开发人员在设计“功能键设置”模块时不得不考虑的问题。命令模式正为解决这类问题而诞生，此时，如果我们使用命令模式，可以在一定程度上解决上述问题（*注：命令模式无法解决类的个数增加的问题*），下面就让我们正式进入命令模式的学习，看看命令模式到底如何实现请求发送者和接收者解耦。\n\n\n# 命令模式概述\n\n在软件开发中，我们经常需要向某些对象发送请求（调用其中的某个或某些方法），但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，此时，我们特别希望能够以一种松耦合的方式来设计软件，使得请求发送者与请求接收者能够消除彼此之间的耦合，让对象之间的调用关系更加灵活，可以灵活地指定请求接收者以及被请求的操作。命令模式为此类问题提供了一个较为完美的解决方案。\n\n**命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。**\n\n命令模式定义如下：\n\n>命令模式(Command Pattern)：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。\n\n命令模式的定义比较复杂，提到了很多术语，例如“用不同的请求对客户进行参数化”、“对请求排队”，“记录请求日志”、“支持可撤销操作”等，在后面我们将对这些术语进行一一讲解。\n\n命令模式的核心在于引入了命令类，通过命令类来降低发送者和接收者的耦合度，请求发送者只需指定一个命令对象，再通过命令对象来调用请求接收者的处理方法，其结构如图3所示：\n\n![图3 命令模式结构图](/images/design-pattern/command-3.jpeg)\n\n在命令模式结构图中包含如下几个角色：\n\n* **Command（抽象命令类）**：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。\n\n* **ConcreteCommand（具体命令类）**：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。\n\n* **Invoker（调用者）**：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。\n\n* **Receiver（接收者）**：接收者执行与请求相关的操作，它具体实现对请求的业务处理。\n\n**命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开**。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作。**命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。**\n\n**命令模式的关键在于引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联**。在最简单的抽象命令类中只包含了一个抽象的execute()方法，每个具体命令类将一个Receiver类型的对象作为一个实例变量进行存储，从而具体指定一个请求的接收者，不同的具体命令类提供了execute()方法的不同实现，并调用不同接收者的请求处理方法。\n\n典型的抽象命令类代码如下所示：\n\n```\nabstract class Command {\n\tpublic abstract void execute();\n}\n```\n\n对于请求发送者即调用者而言，将针对抽象命令类进行编程，**可以通过构造注入或者设值注入的方式在运行时传入具体命令类对象，并在业务方法中调用命令对象的execute()方法**，其典型代码如下所示：\n\n```\nclass Invoker {\n\tprivate Command command;\n\t\n    //构造注入\n\tpublic Invoker(Command command) {\n\t\tthis.command = command;\n\t}\n\t\n    //设值注入\n\tpublic void setCommand(Command command) {\n\t\tthis.command = command;\n\t}\n\t\n\t//业务方法，用于调用命令类的execute()方法\n\tpublic void call() {\n\t\tcommand.execute();\n\t}\n}\n```\n\n具体命令类继承了抽象命令类，它与请求接收者相关联，实现了在抽象命令类中声明的execute()方法，并在实现时调用接收者的请求响应方法action()，其典型代码如下所示：\n\n```\nclass ConcreteCommand extends Command {\n\tprivate Receiver receiver; //维持一个对请求接收者对象的引用\n\n\tpublic void execute() {\n\t\treceiver.action(); //调用请求接收者的业务处理方法action()\n\t}\n}\n```\n\n请求接收者Receiver类具体实现对请求的业务处理，它提供了action()方法，用于执行与请求相关的操作，其典型代码如下所示：\n\n```\nclass Receiver {\n\tpublic void action() {\n\t\t//具体操作\n\t}\n}\n```\n\n\n>思考：一个请求发送者能否对应多个请求接收者？如何实现？\n\n\n# 完整解决方案\n\n为了降低功能键与功能处理类之间的耦合度，让用户可以自定义每一个功能键的功能，Sunny软件公司开发人员使用命令模式来设计“自定义功能键”模块，其核心结构如图4所示：\n\n![图4 自定义功能键核心结构图](/images/design-pattern/command-4.jpeg)\n\n在图4中，FBSettingWindow是“功能键设置”界面类，FunctionButton充当请求调用者，Command充当抽象命令类，MinimizeCommand和HelpCommand充当具体命令类，WindowHanlder和HelpHandler充当请求接收者。完整代码如下所示：\n\n```\nimport java.util.*;\n\n//功能键设置窗口类\nclass FBSettingWindow {\n\tprivate String title; //窗口标题\n    //定义一个ArrayList来存储所有功能键\n\tprivate ArrayList<FunctionButton> functionButtons = new ArrayList<FunctionButton>();\n\t\n\tpublic FBSettingWindow(String title) {\n\t\tthis.title = title;\n\t}\n\t\n\tpublic void setTitle(String title) {\n\t\tthis.title = title;\n\t}\n\t\n\tpublic String getTitle() {\n\t\treturn this.title;\n\t}\n\t\n\tpublic void addFunctionButton(FunctionButton fb) {\n\t\tfunctionButtons.add(fb);\n\t}\n\t\n\tpublic void removeFunctionButton(FunctionButton fb) {\n\t\tfunctionButtons.remove(fb);\n\t}\n\t\n    //显示窗口及功能键\n\tpublic void display() {\n\t\tSystem.out.println(\"显示窗口：\" + this.title);\n\t\tSystem.out.println(\"显示功能键：\");\n\t\tfor (Object obj : functionButtons) {\n\t\t\tSystem.out.println(((FunctionButton)obj).getName());\n\t\t}\n\t\tSystem.out.println(\"------------------------------\");\n\t}\t\n}\n\n//功能键类：请求发送者\nclass FunctionButton {\n\tprivate String name; //功能键名称\n\tprivate Command command; //维持一个抽象命令对象的引用\n\t\n\tpublic FunctionButton(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\t\n    //为功能键注入命令\n\tpublic void setCommand(Command command) {\n\t\tthis.command = command;\n\t}\n\t\n    //发送请求的方法\n\tpublic void onClick() {\n\t\tSystem.out.print(\"点击功能键：\");\n\t\tcommand.execute();\n\t}\n}\n\n//抽象命令类\nabstract class Command {\n\tpublic abstract void execute();\n}\n\n//帮助命令类：具体命令类\nclass HelpCommand extends Command {\n\tprivate HelpHandler hhObj; //维持对请求接收者的引用\n\t\n\tpublic HelpCommand() {\n\t\thhObj = new HelpHandler();\n\t}\n\t\n    //命令执行方法，将调用请求接收者的业务方法\n\tpublic void execute() {\n\t\thhObj.display();\n\t}\n}\n\n//最小化命令类：具体命令类\nclass MinimizeCommand extends Command {\n\tprivate WindowHanlder whObj; //维持对请求接收者的引用\n\t\n\tpublic MinimizeCommand() {\n\t\twhObj = new WindowHanlder();\n\t}\n\t\n//命令执行方法，将调用请求接收者的业务方法\n\tpublic void execute() {\n\t\twhObj.minimize();\n\t}\n}\n\n//窗口处理类：请求接收者\nclass WindowHanlder {\n\tpublic void minimize() {\n\t\tSystem.out.println(\"将窗口最小化至托盘！\");\n\t}\n}\n\n//帮助文档处理类：请求接收者\nclass HelpHandler {\n\tpublic void display() {\n\t\tSystem.out.println(\"显示帮助文档！\");\n\t}\n}\n```\n\n为了提高系统的灵活性和可扩展性，我们将具体命令类的类名存储在配置文件中，并通过工具类XMLUtil来读取配置文件并反射生成对象，XMLUtil类的代码如下所示：\n\n```\nimport javax.xml.parsers.*;\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\nimport java.io.*;\n\npublic class XMLUtil {\n//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象，可以通过参数的不同返回不同类名节点所对应的实例\n\tpublic static Object getBean(int i) {\n\t\ttry {\n\t\t\t//创建文档对象\n\t\t\tDocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder builder = dFactory.newDocumentBuilder();\n\t\t\tDocument doc;\t\t\t\t\t\t\t\n\t\t\tdoc = builder.parse(new File(\"config.xml\")); \n\t\t\n\t\t\t//获取包含类名的文本节点\n\t\t\tNodeList nl = doc.getElementsByTagName(\"className\");\n            Node classNode = null;\n            if (0 == i) {\n            \tclassNode = nl.item(0).getFirstChild();\n            }\n            else {\n            \tclassNode = nl.item(1).getFirstChild();\n            } \n\n            String cName = classNode.getNodeValue();\n            \n            //通过类名生成实例对象并将其返回\n            Class c = Class.forName(cName);\n\t  \t    Object obj = c.newInstance();\n            return obj;\n        }   \n        catch(Exception e){\n            e.printStackTrace();\n           \treturn null;\n        }\n\t}\n}\n\n```\n\n配置文件config.xml中存储了具体建造者类的类名，代码如下所示：\n\n```\n<?xml version=\"1.0\"?>\n<config>\n\t<className>HelpCommand</className>\n    <className>MinimizeCommand</className>\n</config>\n```\n\n编写如下客户端测试代码：\n\n```\nclass Client {\n\tpublic static void main(String args[]) {\n\t\tFBSettingWindow fbsw = new FBSettingWindow(\"功能键设置\");\n\t\t\t\n\t\tFunctionButton fb1,fb2;\n\t\tfb1 = new FunctionButton(\"功能键1\");\n\t\tfb2 = new FunctionButton(\"功能键1\");\n\t\t\n\t\tCommand command1,command2;\n        //通过读取配置文件和反射生成具体命令对象\n\t\tcommand1 = (Command)XMLUtil.getBean(0);\n\t\tcommand2 = (Command)XMLUtil.getBean(1);\n\t    \n        //将命令对象注入功能键\n\t\tfb1.setCommand(command1);\n\t\tfb2.setCommand(command2);\n\t\t\n\t\tfbsw.addFunctionButton(fb1);\n\t\tfbsw.addFunctionButton(fb2);\n\t\tfbsw.display();\n\t\t\n        //调用功能键的业务方法\n\t\tfb1.onClick();\n\t\tfb2.onClick();\n\t}\n}\n```\n\n编译并运行程序，输出结果如下：\n\n```\n显示窗口：功能键设置\n\n显示功能键：\n\n功能键1\n\n功能键1\n\n------------------------------\n\n点击功能键：显示帮助文档！\n\n点击功能键：将窗口最小化至托盘！\n```\n\n如果需要修改功能键的功能，例如某个功能键可以实现“自动截屏”，只需要对应增加一个新的具体命令类，在该命令类与屏幕处理者(ScreenHandler)之间创建一个关联关系，然后将该具体命令类的对象通过配置文件注入到某个功能键即可，原有代码无须修改，符合“开闭原则”。在此过程中，**每一个具体命令类对应一个请求的处理者（接收者），通过向请求发送者注入不同的具体命令对象可以使得相同的发送者对应不同的接收者，从而实现“将一个请求封装为一个对象，用不同的请求对客户进行参数化”**，客户端只需要将具体命令对象作为参数注入请求发送者，无须直接操作请求的接收者。\n\n# 命令队列的实现\n\n有时候我们需要**将多个请求排队，当一个请求发送者发送一个请求时，将不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理**。此时，我们可以通过**命令队列**来实现。\n\n命令队列的实现方法有多种形式，其中最常用、灵活性最好的一种方式是增加一个CommandQueue类，由该类来负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者，CommandQueue类的典型代码如下所示：\n\n```\nimport java.util.*;\n\nclass CommandQueue {\n    //定义一个ArrayList来存储命令队列\n\tprivate ArrayList<Command> commands = new ArrayList<Command>();\n\t\n\tpublic void addCommand(Command command) {\n\t\tcommands.add(command);\n\t}\n\t\n\tpublic void removeCommand(Command command) {\n\t\tcommands.remove(command);\n\t}\n\t\n    //循环调用每一个命令对象的execute()方法\n\tpublic void execute() {\n\t\tfor (Object command : commands) {\n\t\t\t((Command)command).execute();\n\t\t}\n\t}\n}\n```\n\n在增加了命令队列类CommandQueue以后，请求发送者类Invoker将针对CommandQueue编程，代码修改如下：\n\n```\nclass Invoker {\n\tprivate CommandQueue commandQueue; //维持一个CommandQueue对象的引用\n\t\n    //构造注入\n\tpublic Invoker(CommandQueue commandQueue) {\n\t\tthis. commandQueue = commandQueue;\n\t}\n\t\n    //设值注入\n\tpublic void setCommandQueue(CommandQueue commandQueue) {\n\t\tthis.commandQueue = commandQueue;\n\t}\n\t\n\t//调用CommandQueue类的execute()方法\n\tpublic void call() {\n\t\tcommandQueue.execute();\n\t}\n}\n```\n\n命令队列与我们常说的“批处理”有点类似。批处理，顾名思义，可以对一组对象（命令）进行批量处理，当一个发送者发送请求后，将有一系列接收者对请求作出响应，命令队列可以用于设计批处理应用程序，如果请求接收者的接收次序没有严格的先后次序，我们还可以使用多线程技术来并发调用命令对象的execute()方法，从而提高程序的执行效率。\n\n# 撤销操作的实现\n\n在命令模式中，我们可以通过调用一个命令对象的execute()方法来实现对请求的处理，如果需要撤销(Undo)请求，可通过在命令类中增加一个逆向操作来实现。\n\n除了通过一个**逆向操作**来实现撤销(Undo)外，还可以通过**保存对象的历史状态**来实现撤销，后者可使用备忘录模式(Memento Pattern)来实现。\n\n下面通过一个简单的实例来学习如何使用命令模式实现撤销操作：\n\nSunny软件公司欲开发一个简易计算器，该计算器可以实现简单的数学运算，还可以对运算实施撤销操作。\n\nSunny软件公司开发人员使用命令模式设计了如图5所示结构图，其中计算器界面类CalculatorForm充当请求发送者，实现了数据求和功能的加法类Adder充当请求接收者，界面类可间接调用加法类中的add()方法实现加法运算，并且提供了可撤销加法运算的undo()方法。\n\n本实例完整代码如下所示：\n\n```\n//加法类：请求接收者\nclass Adder {\n\tprivate int num=0; //定义初始值为0\n\t\n    //加法操作，每次将传入的值与num作加法运算，再将结果返回\n\tpublic int add(int value) {\n\t\tnum += value;\n\t\treturn num;\n\t}\n}\n\n//抽象命令类\nabstract class AbstractCommand {\n\tpublic abstract int execute(int value); //声明命令执行方法execute()\n\tpublic abstract int undo(); //声明撤销方法undo()\n}\n\n//具体命令类\nclass ConcreteCommand extends AbstractCommand {\n\tprivate Adder adder = new Adder();\n\tprivate int value;\n\t\t\n\t//实现抽象命令类中声明的execute()方法，调用加法类的加法操作\npublic int execute(int value) {\n\t\tthis.value=value;\n\t\treturn adder.add(value);\n\t}\n\t\n    //实现抽象命令类中声明的undo()方法，通过加一个相反数来实现加法的逆向操作\n\tpublic int undo() {\n\t\treturn adder.add(-value);\n\t}\n}\n\n//计算器界面类：请求发送者\nclass CalculatorForm {\n\tprivate AbstractCommand command;\n\t\n\tpublic void setCommand(AbstractCommand command) {\n\t\tthis.command = command;\n\t}\n\t\n    //调用命令对象的execute()方法执行运算\n\tpublic void compute(int value) {\n\t\tint i = command.execute(value);\n\t\tSystem.out.println(\"执行运算，运算结果为：\" + i);\n\t}\n\t\n    //调用命令对象的undo()方法执行撤销\n\tpublic void undo() {\n\t\tint i = command.undo();\n\t\tSystem.out.println(\"执行撤销，运算结果为：\" + i);\n\t}\n}\n```\n\n编写如下客户端测试代码：\n\n```\nclass Client {\n\tpublic static void main(String args[]) {\n\t\tCalculatorForm form = new CalculatorForm();\n\t\tAbstractCommand command;\n\t\tcommand = new ConcreteCommand();\n\t\tform.setCommand(command); //向发送者注入命令对象\n\t\t\n\t\tform.compute(10);\n\t\tform.compute(5);\n\t\tform.compute(10);\n\t\tform.undo();\n\t}\n}\n```\n\n编译并运行程序，输出结果如下：\n\n```\n执行运算，运算结果为：10\n\n执行运算，运算结果为：15\n\n执行运算，运算结果为：25\n\n执行撤销，运算结果为：15\n```\n\n>思考：如果连续调用“form.undo()”两次，预测客户端代码的输出结果。\n\n需要注意的是在本实例中只能实现一步撤销操作，因为没有保存命令对象的历史状态，可以通过引入一个命令集合或其他方式来存储每一次操作时命令的状态，从而实现多次撤销操作。除了Undo操作外，还可以采用类似的方式实现恢复(Redo)操作，即恢复所撤销的操作（或称为二次撤销）。\n\n>练习：修改简易计算器源代码，使之能够实现多次撤销(Undo)和恢复(Redo)。\n\n# 请求日志\n\n请求日志就是将请求的历史记录保存下来，通常以日志文件(Log File)的形式永久存储在计算机中。很多系统都提供了日志文件，例如Windows日志文件、Oracle日志文件等，日志文件可以记录用户对系统的一些操作（例如对数据的更改）。请求日志文件可以实现很多功能，常用功能如下：\n\n1. “天有不测风云”，一旦系统发生故障，日志文件可以为系统提供一种恢复机制，在请求日志文件中可以记录用户对系统的每一步操作，从而让系统能够顺利恢复到某一个特定的状态；\n\n2. 请求日志也可以用于实现批处理，在一个请求日志文件中可以存储一系列命令对象，例如一个命令队列；\n\n3. 可以将命令队列中的所有命令对象都存储在一个日志文件中，每执行一个命令则从日志文件中删除一个对应的命令对象，防止因为断电或者系统重启等原因造成请求丢失，而且可以避免重新发送全部请求时造成某些命令的重复执行，只需读取请求日志文件，再继续执行文件中剩余的命令即可。\n\n在实现请求日志时，我们可以**将命令对象通过序列化写到日志文件中**，此时命令类必须实现Java.io.Serializable接口。下面我们通过一个简单实例来说明日志文件的用途以及如何实现请求日志。\n\nSunny软件公司开发了一个网站配置文件管理工具，可以通过一个可视化界面对网站配置文件进行增删改等操作，该工具使用命令模式进行设计，结构如图6所示：\n\n![图6  网站配置文件管理工具结构图](/images/design-pattern/command-6.jpeg)\n\n现在Sunny软件公司开发人员希望将对配置文件的操作请求记录在日志文件中，如果网站重新部署，只需要执行保存在日志文件中的命令对象即可修改配置文件。\n\n本实例完整代码如下所示：\n\n```\nimport java.io.*;\nimport java.util.*;\n\n//抽象命令类，由于需要将命令对象写入文件，因此它实现了Serializable接口\nabstract class Command implements Serializable {\n\tprotected String name; //命令名称\n\tprotected String args; //命令参数\n\tprotected ConfigOperator configOperator; //维持对接收者对象的引用\n\t\n\tpublic Command(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic void setConfigOperator(ConfigOperator configOperator) {\n\t\tthis.configOperator = configOperator;\n\t}\n\t\n    //声明两个抽象的执行方法execute()\n\tpublic abstract void execute(String args);\n\tpublic abstract void execute();\n}\n\n//增加命令类：具体命令\nclass InsertCommand extends Command {\n\tpublic InsertCommand(String name) {\n\t\tsuper(name);\n\t}\n\t\n\tpublic void execute(String args) {\n\t\tthis.args = args;\n\t\tconfigOperator.insert(args);\n\t}\n\t\n\tpublic void execute() {\n\t\tconfigOperator.insert(this.args);\n\t}\n}\n\n//修改命令类：具体命令\nclass ModifyCommand extends Command {\n\tpublic ModifyCommand(String name) {\n\t\tsuper(name);\n\t}\n\t\n\tpublic void execute(String args) {\n\t\tthis.args = args;\n\t\tconfigOperator.modify(args);\n\t}\n\t\n\tpublic void execute() {\n\t\tconfigOperator.modify(this.args);\n\t}\n}\n\n//省略了删除命令类DeleteCommand\n\n//配置文件操作类：请求接收者。由于ConfigOperator类的对象是Command的成员对象，它也将随Command对象一起写入文件，因此ConfigOperator也需要实现Serializable接口\nclass ConfigOperator implements Serializable {\n\tpublic void insert(String args) {\n\t\tSystem.out.println(\"增加新节点：\" + args);\n\t}\n\t\n\tpublic void modify(String args) {\n\t\tSystem.out.println(\"修改节点：\" + args);\n\t}\n\t\n\tpublic void delete(String args) {\n\t\tSystem.out.println(\"删除节点：\" + args);\n\t}\n}\n\n//配置文件设置窗口类：请求发送者\nclass ConfigSettingWindow {\n    //定义一个集合来存储每一次操作时的命令对象\n\tprivate ArrayList<Command> commands = new ArrayList<Command>();\n\tprivate Command command; \n\n    //注入具体命令对象\n\tpublic void setCommand(Command command) {\n\t\tthis.command = command;\n\t}\n\t\n    //执行配置文件修改命令，同时将命令对象添加到命令集合中\n\tpublic void call(String args) {\n\t\tcommand.execute(args);\n\t\tcommands.add(command);\n\t}\n\t\n    //记录请求日志，生成日志文件，将命令集合写入日志文件\n\tpublic void save() {\n\t\tFileUtil.writeCommands(commands);\n\t}\n\t\n    //从日志文件中提取命令集合，并循环调用每一个命令对象的execute()方法来实现配置文件的重新设置\n\tpublic void recover() {\n\t\tArrayList list;\n\t\tlist = FileUtil.readCommands();\n\t\t\n\t\tfor (Object obj : list) {\n\t\t\t((Command)obj).execute();\n\t\t}\n\t}\n}\n\n//工具类：文件操作类\nclass FileUtil {\n    //将命令集合写入日志文件\n\tpublic static void writeCommands(ArrayList commands) {\n\t\ttry {\n\t\t\tFileOutputStream file = new FileOutputStream(\"config.log\");\n\t\t\t//创建对象输出流用于将对象写入到文件中\n    \t\tObjectOutputStream objout = new ObjectOutputStream(new BufferedOutputStream(file));\n\t\t\t//将对象写入文件\n    \t\tobjout.writeObject(commands);\n    \t\tobjout.close();\n    \t\t}\n    \tcatch(Exception e) {\n    \t\t\tSystem.out.println(\"命令保存失败！\");\t\n    \t\t\te.printStackTrace();\n    \t    }\n\t}\n\t\n    //从日志文件中提取命令集合\n\tpublic static ArrayList readCommands() {\n\t\ttry {\n\t\t\tFileInputStream file = new FileInputStream(\"config.log\");\n\t\t\t//创建对象输入流用于从文件中读取对象\n    \t\tObjectInputStream objin = new ObjectInputStream(new BufferedInputStream(file));\n\t\t\t\n\t\t\t//将文件中的对象读出并转换为ArrayList类型\n    \t\tArrayList commands = (ArrayList)objin.readObject();\n    \t\tobjin.close();\n    \t\treturn commands;\n    \t\t}\n    \tcatch(Exception e) {\n    \t\t\tSystem.out.println(\"命令读取失败！\");\n    \t\t\te.printStackTrace();\n    \t\t\treturn null;\t\n    \t    }\t\t\n\t}\n}\n```\n\n编写如下客户端测试代码：\n\n```\nclass Client {\n\tpublic static void main(String args[]) {\n\t\tConfigSettingWindow csw = new ConfigSettingWindow(); //定义请求发送者\n\t\tCommand command; //定义命令对象\n\t\tConfigOperator co = new ConfigOperator(); //定义请求接收者\n\t\t\n        //四次对配置文件的更改\n\t\tcommand = new InsertCommand(\"增加\");\n\t\tcommand.setConfigOperator(co);\n\t\tcsw.setCommand(command);\n\t\tcsw.call(\"网站首页\");\n\t\t\n\t\tcommand = new InsertCommand(\"增加\");\n\t\tcommand.setConfigOperator(co);\n\t\tcsw.setCommand(command);\n\t\tcsw.call(\"端口号\");\n\t\t\n\t\tcommand = new ModifyCommand(\"修改\");\n\t\tcommand.setConfigOperator(co);\n\t\tcsw.setCommand(command);\n\t\tcsw.call(\"网站首页\");\n\t\t\n\t\tcommand = new ModifyCommand(\"修改\");\n\t\tcommand.setConfigOperator(co);\n\t\tcsw.setCommand(command);\t\t\n\t\tcsw.call(\"端口号\");\n\t\t\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println(\"保存配置\");\n\t\tcsw.save();\n\t\t\t\n\t\tSystem.out.println(\"----------------------------\");\t\n\t\tSystem.out.println(\"恢复配置\");\n\t\tSystem.out.println(\"----------------------------\");\t\n\t\tcsw.recover();\t\n\t}\n}\n```\n\n编译并运行程序，输出结果如下：\n\n```\n增加新节点：网站首页\n\n增加新节点：端口号\n\n修改节点：网站首页\n\n修改节点：端口号\n\n----------------------------\n\n保存配置\n\n----------------------------\n\n恢复配置\n\n----------------------------\n\n增加新节点：网站首页\n\n增加新节点：端口号\n\n修改节点：网站首页\n\n修改节点：端口号\n```\n\n# 宏命令\n\n**宏命令(Macro Command)又称为组合命令，它是组合模式和命令模式联用的产物**。宏命令是一个具体命令类，它拥有一个集合属性，在该集合中包含了对其他命令对象的引用。**通常宏命令不直接与请求接收者交互，而是通过它的成员来调用接收者的方法**。当调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法，一个宏命令的成员可以是简单命令，还可以继续是宏命令。**执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理**，其结构如图7所示：\n\n\n![图7  宏命令结构图](/images/design-pattern/command-7.jpeg)\n\n# 总结\n\n命令模式是一种使用频率非常高的设计模式，它可以将请求发送者与接收者解耦，请求发送者通过命令对象来间接引用请求接收者，使得系统具有更好的灵活性和可扩展性。在基于GUI的软件开发，无论是在电脑桌面应用还是在移动应用中，命令模式都得到了广泛的应用。\n\n* **主要优点**\n\n    1. **降低系统的耦合度**。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。\n\n    2. **新的命令可以很容易地加入到系统中**。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。\n\n    3. **可以比较容易地设计一个命令队列或宏命令（组合命令）**。\n\n    4. **为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案**。\n\n* **主要缺点**\n\n    1. **使用命令模式可能会导致某些系统有过多的具体命令类**。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。\n\n* **适用场景**\n\n    1. 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。\n\n    2. 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。\n\n    3. 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。\n\n    4. 系统需要将一组操作组合在一起形成宏命令。\n\n>练习: Sunny软件公司欲开发一个基于Windows平台的公告板系统。该系统提供了一个主菜单(Menu)，在主菜单中包含了一些菜单项(MenuItem)，可以通过Menu类的addMenuItem()方法增加菜单项。菜单项的主要方法是click()，每一个菜单项包含一个抽象命令类，具体命令类包括OpenCommand(打开命令)，CreateCommand(新建命令)，EditCommand(编辑命令)等，命令类具有一个execute()方法，用于调用公告板系统界面类(BoardScreen)的open()、create()、edit()等方法。试使用命令模式设计该系统，以便降低MenuItem类与BoardScreen类之间的耦合度。\n\n\n[原文: http://wiki.jikexueyuan.com/project/design-pattern-behavior/command-one.html]\n\n","categories":["设计模式"]},{"title":"设计模式-职责链模式","url":"%2F2017%2F04%2F08%2Fdesign-pattern%2Fdesign-pattern-chain%2F","content":"\n“一对二”，“过”，“过”……这声音熟悉吗？你会想到什么？对！纸牌。在类似“斗地主”这样的纸牌游戏中，某人出牌给他的下家，下家看看手中的牌，如果要不起上家的牌则将出牌请求再转发给他的下家，其下家再进行判断。一个循环下来，如果其他人都要不起该牌，则最初的出牌者可以打出新的牌。在这个过程中，牌作为一个请求沿着一条链在传递，每一位纸牌的玩家都可以处理该请求。在设计模式中，我们也有一种专门用于处理这种请求链式传递的模式，它就是本章将要介绍的职责链模式。\n\n<!-- more -->\n\n# 采购单的分级审批\n\nSunny软件公司承接了某企业SCM(Supply Chain Management，供应链管理)系统的开发任务，其中包含一个采购审批子系统。该企业的采购审批是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批，主任可以审批5万元以下（不包括5万元）的采购单，副董事长可以审批5万元至10万元（不包括10万元）的采购单，董事长可以审批10万元至50万元（不包括50万元）的采购单，50万元及以上的采购单就需要开董事会讨论决定。如图16-1所示：\n\n![](/images/design-pattern/chain-1.gif)\n\n\n如何在软件中实现采购单的分级审批？Sunny软件公司开发人员提出了一个初始解决方案，在系统中提供一个采购单处理类PurchaseRequestHandler用于统一处理采购单，其框架代码如下所示：\n\n```\n//采购单处理类\nclass PurchaseRequestHandler {\n\t//递交采购单给主任\n\tpublic void sendRequestToDirector(PurchaseRequest request) {\n\t\tif (request.getAmount() < 50000) {\n\t\t\t//主任可审批该采购单\n\t\t\tthis.handleByDirector(request);\n\t\t}\n\t\telse if (request.getAmount() < 100000) {\n\t\t\t//副董事长可审批该采购单\n\t\t\tthis.handleByVicePresident(request);\n\t\t}\n\t\telse if (request.getAmount() < 500000) {\n\t\t\t//董事长可审批该采购单\n\t\t\tthis.handleByPresident(request);\n\t\t}\n\t\telse {\n\t\t\t//董事会可审批该采购单\n\t\t\tthis.handleByCongress(request);\n\t\t}\n\t}\n\t\n\t//主任审批采购单\n\tpublic void handleByDirector(PurchaseRequest request) {\n\t\t//代码省略\n\t}\n\t\n\t//副董事长审批采购单\n\tpublic void handleByVicePresident(PurchaseRequest request) {\n\t\t//代码省略\n\t}\n\t\n\t//董事长审批采购单\n\tpublic void handleByPresident(PurchaseRequest request) {\n\t\t//代码省略\n\t}\n\t\n\t//董事会审批采购单\n\tpublic void handleByCongress(PurchaseRequest request) {\n\t\t//代码省略\n\t}\n}\n```\n\n问题貌似很简单，但仔细分析，发现上述方案存在如下几个问题：\n\n1. PurchaseRequestHandler类较为庞大，各个级别的审批方法都集中在一个类中，违反了“单一职责原则”，测试和维护难度大。\n2. 如果需要增加一个新的审批级别或调整任何一级的审批金额和审批细节（例如将董事长的审批额度改为60万元）时都必须修改源代码并进行严格测试，此外，如果需要移除某一级别（例如金额为10万元及以上的采购单直接由董事长审批，不再设副董事长一职）时也必须对源代码进行修改，违反了“开闭原则”。\n3. 审批流程的设置缺乏灵活性，现在的审批流程是“主任-->副董事长-->董事长-->董事会”，如果需要改为“主任-->董事长-->董事会”，在此方案中只能通过修改源代码来实现，客户端无法定制审批流程。\n\n如何针对上述问题对系统进行改进？Sunny公司开发人员迫切需要一种新的设计方案，还好有职责链模式，通过使用职责链模式我们可以最大程度地解决这些问题，下面让我们正式进入职责链模式的学习。\n\n# 职责链模式概述\n\n很多情况下，在一个软件系统中可以处理某个请求的对象不止一个，例如SCM系统中的采购单审批，主任、副董事长、董事长和董事会都可以处理采购单，他们可以构成一条处理采购单的链式结构，采购单沿着这条链进行传递，这条链就称为职责链。职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现请求发送者和请求处理者解耦。\n\n职责链模式定义如下：\n\n>职责链模式(Chain of Responsibility  Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。\n\n职责链模式结构的核心在于引入了一个抽象处理者。职责链模式结构如图16-2所示：\n\n![](/images/design-pattern/chain-2.gif)\n\n在职责链模式结构图中包含如下几个角色：\n\n* **Handler（抽象处理者）**：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor），作为其对下家的引用。通过该引用，处理者可以连成一条链。\n\n* **ConcreteHandler（具体处理者）**：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。\n\n在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在**不影响客户端的情况下动态地重新组织链和分配责任**。\n\n职责链模式的核心在于抽象处理者类的设计，抽象处理者的典型代码如下所示：\n\n```\nabstract class Handler {\n//维持对下家的引用\nprotected Handler successor;\n\t\n\tpublic void setSuccessor(Handler successor) {\n\t\tthis.successor=successor;\n\t}\n\t\n\tpublic abstract void handleRequest(String request);\n}\n```\n\n上述代码中，抽象处理者类定义了对下家的引用对象，以便将请求转发给下家，该对象的访问符可设为protected，在其子类中可以使用。在抽象处理者类中声明了抽象的请求处理方法，具体实现交由子类完成。\n\n具体处理者是抽象处理者的子类，它具有两大作用：**第一是处理请求**，不同的具体处理者以不同的形式实现抽象请求处理方法handleRequest()；**第二是转发请求**，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。具体处理者类的典型代码如下\n\n```\nclass ConcreteHandler extends Handler {\n\tpublic void handleRequest(String request) {\n\t\tif (请求满足条件) {\n\t\t\t//处理请求\n\t\t}\n\t\telse {\n\t\t\tthis.successor.handleRequest(request);  //转发请求\n\t\t}\n\t}\n}\n```\n\n在具体处理类中通过对请求进行判断可以做出相应的处理。\n\n需要注意的是，**职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链**。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。\n\n>思考：如何在客户端创建一条职责链？\n\n# 完整解决方案\n\n为了让采购单的审批流程更加灵活，并实现采购单的链式传递和处理，Sunny公司开发人员使用职责链模式来实现采购单的分级审批，其基本结构如图16-3所示：\n\n![](/images/design-pattern/chain-3.gif)\n\n在图16-3中，抽象类Approver充当抽象处理者（抽象传递者），Director、VicePresident、President和Congress充当具体处理者（具体传递者），PurchaseRequest充当请求类。完整代码如下所示：\n\n```\n//采购单：请求类\nclass PurchaseRequest {\n\tprivate double amount;  //采购金额\n\tprivate int number;  //采购单编号\n\tprivate String purpose;  //采购目的\n\t\n\tpublic PurchaseRequest(double amount, int number, String purpose) {\n\t\tthis.amount = amount;\n\t\tthis.number = number;\n\t\tthis.purpose = purpose;\n\t}\n\t\n\tpublic void setAmount(double amount) {\n\t\tthis.amount = amount;\n\t}\n\t\n\tpublic double getAmount() {\n\t\treturn this.amount;\n\t}\n\t\n\tpublic void setNumber(int number) {\n\t\tthis.number = number;\n\t}\n\t\n\tpublic int getNumber() {\n\t\treturn this.number;\n\t}\n\t\n\tpublic void setPurpose(String purpose) {\n\t\tthis.purpose = purpose;\n\t}\n\t\n\tpublic String getPurpose() {\n\t\treturn this.purpose;\n\t}\n}\n\n//审批者类：抽象处理者\nabstract class Approver {\n\tprotected Approver successor; //定义后继对象\n\tprotected String name; //审批者姓名\n\t\n\tpublic Approver(String name) {\n\t\tthis.name = name;\n\t}\n\n\t//设置后继者\n\tpublic void setSuccessor(Approver successor) { \n\t\tthis.successor = successor;\n\t}\n\n    //抽象请求处理方法\n    public abstract void processRequest(PurchaseRequest request);\n}\n\n//主任类：具体处理者\nclass Director extends Approver {\n\tpublic Director(String name) {\n\t\tsuper(name);\n\t}\n\t\n    //具体请求处理方法\n \tpublic void processRequest(PurchaseRequest request) {\n \t\tif (request.getAmount() < 50000) {\n \t\t\tSystem.out.println(\"主任\" + this.name + \"审批采购单：\" + request.getNumber() + \"，金额：\" + request.getAmount() + \"元，采购目的：\" + request.getPurpose() + \"。\");  //处理请求\n \t\t}\n \t\telse {\n \t\t\tthis.successor.processRequest(request);  //转发请求\n \t\t}\t\n \t}\n}\n\n//副董事长类：具体处理者\nclass VicePresident extends Approver {\n\tpublic VicePresident(String name) {\n\t\tsuper(name);\n\t}\n\t\n    //具体请求处理方法\n \tpublic void processRequest(PurchaseRequest request) {\n \t\tif (request.getAmount() < 100000) {\n \t\t\tSystem.out.println(\"副董事长\" + this.name + \"审批采购单：\" + request.getNumber() + \"，金额：\" + request.getAmount() + \"元，采购目的：\" + request.getPurpose() + \"。\");  //处理请求\n \t\t}\n \t\telse {\n \t\t\tthis.successor.processRequest(request);  //转发请求\n \t\t}\t\n \t}\n}\n\n//董事长类：具体处理者\nclass President extends Approver {\n\tpublic President(String name) {\n\t\tsuper(name);\n\t}\n\t\n    //具体请求处理方法\n \tpublic void processRequest(PurchaseRequest request) {\n \t\tif (request.getAmount() < 500000) {\n \t\t\tSystem.out.println(\"董事长\" + this.name + \"审批采购单：\" + request.getNumber() + \"，金额：\" + request.getAmount() + \"元，采购目的：\" + request.getPurpose() + \"。\");  //处理请求\n \t\t}\n \t\telse {\n \t\t\tthis.successor.processRequest(request);  //转发请求\n \t\t}\n \t}\n}\n\n//董事会类：具体处理者\nclass Congress extends Approver {\n\tpublic Congress(String name) {\n\t\tsuper(name);\n\t}\n\t\n    //具体请求处理方法\n \tpublic void processRequest(PurchaseRequest request) {\n \t\tSystem.out.println(\"召开董事会审批采购单：\" + request.getNumber() + \"，金额：\" + request.getAmount() + \"元，采购目的：\" + request.getPurpose() + \"。\");\t    //处理请求\n \t}    \n}\n```\n\n编写如下客户端测试代码： \n\n```\nclass Client {\n\tpublic static void main(String[] args) {\n\t\tApprover wjzhang,gyang,jguo,meeting;\n\t\twjzhang = new Director(\"张无忌\");\n\t\tgyang = new VicePresident(\"杨过\");\n\t\tjguo = new President(\"郭靖\");\n\t\tmeeting = new Congress(\"董事会\");\n\t\n\t\t//创建职责链\n\t\twjzhang.setSuccessor(gyang);\n\t\tgyang.setSuccessor(jguo);\n\t\tjguo.setSuccessor(meeting);\n\t\t\n\t\t//创建采购单\n\t\tPurchaseRequest pr1 = new PurchaseRequest(45000,10001,\"购买倚天剑\");\n\t\twjzhang.processRequest(pr1);\n\t\t\n\t\tPurchaseRequest pr2 = new PurchaseRequest(60000,10002,\"购买《葵花宝典》\");\n\t\twjzhang.processRequest(pr2);\n\t\n\t\tPurchaseRequest pr3 = new PurchaseRequest(160000,10003,\"购买《金刚经》\");\n\t\twjzhang.processRequest(pr3);\n\n\t\tPurchaseRequest pr4 = new PurchaseRequest(800000,10004,\"购买桃花岛\");\n\t\twjzhang.processRequest(pr4);\n\t}\n} \n```\n\n编译并运行程序，输出结果如下：\n\n```\n主任张无忌审批采购单：10001，金额：45000.0元，采购目的：购买倚天剑。\n\n副董事长杨过审批采购单：10002，金额：60000.0元，采购目的：购买《葵花宝典》。\n\n董事长郭靖审批采购单：10003，金额：160000.0元，采购目的：购买《金刚经》。\n\n召开董事会审批采购单：10004，金额：800000.0元，采购目的：购买桃花岛。\n```\n\n如果需要在系统增加一个新的具体处理者，如增加一个经理(Manager)角色可以审批5万元至8万元（不包括8万元）的采购单，需要编写一个新的具体处理者类Manager，作为抽象处理者类Approver的子类，实现在Approver类中定义的抽象处理方法，如果采购金额大于等于8万元，则将请求转发给下家，代码如下所示：\n\n```\n//经理类：具体处理者\nclass Manager extends Approver {\n\tpublic Manager(String name) {\n\t\tsuper(name);\n\t}\n\t\n    //具体请求处理方法\n \tpublic void processRequest(PurchaseRequest request) {\n \t\tif (request.getAmount() < 80000) {\n \t\t\tSystem.out.println(\"经理\" + this.name + \"审批采购单：\" + request.getNumber() + \"，金额：\" + request.getAmount() + \"元，采购目的：\" + request.getPurpose() + \"。\");  //处理请求\n \t\t}\n \t\telse {\n \t\t\tthis.successor.processRequest(request);  //转发请求\n \t\t}\t\n \t}\n}\n```\n\n由于链的创建过程由客户端负责，因此增加新的具体处理者类对原有类库无任何影响，无须修改已有类的源代码，符合“开闭原则”。\n\n在客户端代码中，如果要将新的具体请求处理者应用在系统中，需要创建新的具体处理者对象，然后将该对象加入职责链中。如在客户端测试代码中增加如下代码：\n\n```\nApprover rhuang;\nrhuang = new Manager(\"黄蓉\");\n```\n\n将建链代码改为：\n\n```\n//创建职责链\nwjzhang.setSuccessor(rhuang); //将“黄蓉”作为“张无忌”的下家\nrhuang.setSuccessor(gyang); //将“杨过”作为“黄蓉”的下家\ngyang.setSuccessor(jguo);\njguo.setSuccessor(meeting);\n```\n\n重新编译并运行程序，输出结果如下：\n\n```\n主任张无忌审批采购单：10001，金额：45000.0元，采购目的：购买倚天剑。\n\n经理黄蓉审批采购单：10002，金额：60000.0元，采购目的：购买《葵花宝典》。\n\n董事长郭靖审批采购单：10003，金额：160000.0元，采购目的：购买《金刚经》。\n\n召开董事会审批采购单：10004，金额：800000.0元，采购目的：购买桃花岛。\n```\n\n>思考：如果将审批流程由“主任-->副董事长-->董事长-->董事会”调整为“主任-->董事长-->董事会”，系统将做出哪些改动？预测修改之后客户端代码的输出结果。\n\n# 纯与不纯的职责链模式\n\n职责链模式可分为纯的职责链模式和不纯的职责链模式两种：\n\n* 纯的职责链模式\n\n一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：**要么承担全部责任，要么将责任推给下家**，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，**要求一个请求必须被某一个处理者对象所接收**，不能出现某个请求未被任何一个处理者对象处理的情况。在前面的采购单审批实例中应用的是纯的职责链模式。\n\n* 不纯的职责链模式\n\n在一个不纯的职责链模式中**允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收**。Java AWT 1.0中的事件处理模型应用的是不纯的职责链模式，其基本原理如下：由于窗口组件（如按钮、文本框等）一般都位于容器组件中，因此当事件发生在某一个组件上时，先通过组件对象的handleEvent()方法将事件传递给相应的事件处理方法，该事件处理方法将处理此事件，然后决定是否将该事件向上一级容器组件传播；上级容器组件在接到事件之后可以继续处理此事件并决定是否继续向上级容器组件传播，如此反复，直到事件到达顶层容器组件为止；如果一直传到最顶层容器仍没有处理方法，则该事件不予处理。**每一级组件在接收到事件时，都可以处理此事件，而不论此事件是否在上一级已得到处理，还存在事件未被处理的情况**。显然，这就是不纯的职责链模式，早期的Java AWT事件模型(JDK 1.0及更早)中的这种事件处理机制又叫**事件浮升(Event Bubbling)机制**。从Java.1.1以后，JDK使用观察者模式代替职责链模式来处理事件。目前，在JavaScript中仍然可以使用这种事件浮升机制来进行事件处理。\n\n# 总结\n\n职责链模式通过建立一条链来组织请求的处理者，请求将沿着链进行传递，请求发送者无须知道请求在何时、何处以及如何被处理，实现了请求发送者与处理者的解耦。在软件开发中，如果遇到有多个对象可以处理同一请求时可以应用职责链模式，例如在Web应用开发中创建一个**过滤器(Filter)链**来对请求数据进行过滤，在工作流系统中实现公文的分级审批等等，使用职责链模式可以较好地解决此类问题。\n\n\n* **主要优点**\n\n    1. 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。\n\n    2. 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。\n\n    3. 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。\n\n    4. 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。\n\n* **主要缺点**\n\n    1. 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。\n\n    2. 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。\n\n    3. 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。\n\n\n* **适用场景**\n\n    1. 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。\n\n    2. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。\n\n    3. 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 \n\n>练习：Sunny软件公司的OA系统需要提供一个假条审批模块：如果员工请假天数小于3天，主任可以审批该假条；如果员工请假天数大于等于3天，小于10天，经理可以审批；如果员工请假天数大于等于10天，小于30天，总经理可以审批；如果超过30天，总经理也不能审批，提示相应的拒绝信息。试用职责链模式设计该假条审批模块。\n\n\n[原文: http://wiki.jikexueyuan.com/project/design-pattern-behavior/chain-one.html]\n\n","categories":["设计模式"]},{"title":"设计模式-目录","url":"%2F2017%2F04%2F08%2Fdesign-pattern%2Fdesign-pattern-catalogue%2F","content":"\n### 创建型模式\n\n* [简单工厂模式 (Simple Factory Pattern)](http://blog.devjackcat.com/2017/04/10/design-pattern/design-pattern-simple-factory/)\n* [工厂方法模式 (Factory Method Pattern)](http://blog.devjackcat.com/2017/04/10/design-pattern/design-pattern-factory-method/)\n* 抽象工厂模式 (Abstract  Factory Pattern)\n* 单例模式 (Singleton Pattern)\n* 原型模式 (Prototype Pattern)\n* 建造者模式 (Builder Pattern)\n\n<!-- more -->\n\n### 结构型模式\n\n* 适配器模式 (Adapter Pattern)\n* 桥接模式 (Bridge Pattern)\n* 组合模式 (Composite Pattern)\n* 装饰模式 (Decorator Pattern)\n* 外观模式 (Facade Pattern)\n* 享元模式 (Flyweight Pattern)\n* 代理模式 (Proxy Pattern)\n\n### 行为型模式\n\n* [职责链模式 (Chain of Responsibility Pattern)](http://blog.devjackcat.com/2017/04/08/design-pattern-chain/)\n* [命令模式 (Command Pattern)](http://blog.devjackcat.com/2017/04/08/design-pattern-command/)\n* 解释器模式 (Interpreter Pattern)\n* 迭代器模式 (Iterator Pattern)\n* 中介者模式 (Mediator Pattern)\n* 备忘录模式 (Memento Pattern)\n* 观察者模式 (Observer Pattern)\n* 状态模式 (State Pattern)\n* 策略模式 (Strategy Pattern)\n* 模板方法 (Template Method Pattern)\n* 访问模式 (Visitor Pattern)\n\n### 设计模式趣味学习 (复习)\n\n* 设计模式与足球(一):创建型模式\n* 设计模式与足球(二):结构型模式\n* 设计模式与足球(三):行为型模式(上)\n* 设计模式与足球(四):行为型模式(下)\n\n### 设计模式综合应用实例\n\n#### 多人联机设计游戏\n\n* 多人联机射击游戏中的设计模式应用（一）：抽象工厂模式，建造者模式，工厂方法模式，迭代器模式，命令模式\n* 多人联机射击游戏中的设计模式应用（二）：观察者模式，单例模式，状态模式，适配器模式\n\n#### 数据库同步系统\n\n* 设计模式综合实例分析之数据库同步系统（一）：数据库同步系统概述，建造者模式，简单工厂模式\n* 设计模式综合实例分析之数据库同步系统（二）：享元模式，单例模式，观察者模式，模板方法模式\n* 设计模式综合实例分析之数据库同步系统（三）：策略模式，组合模式，命令模式，职责链模式\n\n\n[ 作者：刘伟  http://blog.csdn.net/lovelion/article/details/17517213 ]\n\n","categories":["设计模式"]},{"title":"iOS符号表恢复&逆向支付宝","url":"%2F2017%2F03%2F29%2Fsymbol-restore%2F","content":"\n### 关于本文\n\n本文是杨君的著作。\n\n原文地址:  http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/\n\n<!-- more -->\n\n### 前言\n\n符号表历来是逆向工程中的“必争之地”，而iOS应用在上线前都会裁去符号表，以避免被逆向分析。\n\n本文会介绍一个自己写的工具，用于恢复iOS应用的符号表。\n\n直接看效果,支付宝恢复符号表后的样子:\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/after_restore.jpg)\n\n文章有点长，请耐心看到最后，亮点在最后。\n\n### 为什么要恢复符号表\n\n逆向工程中，调试器的动态分析是必不可少的，而 Xcode + lldb 确实是非常好的调试利器, 比如我们在Xcode里可以很方便的查看调用堆栈，如上面那张图可以很清晰的看到支付宝登录的RPC调用过程。\n\n实际上，如果我们不恢复符号表的话，你看到的调试页面应该是下面这个样子：\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/before_restore.jpg)\n\n同一个函数调用过程，Xcode的显示简直天差地别。\n\n原因是，Xcode显示调用堆栈中符号时，只会显示符号表中有的符号。为了我们调试过程的顺利，我们有必要把可执行文件中的符号表恢复回来。\n\n### 符号表是什么\n\n我们要恢复符号表，首先要知道符号表是什么，他是怎么存在于 Mach-O 文件中的。\n\n符号表储存在 Mach-O 文件的 __LINKEDIT 段中，涉及其中的符号表（Symbol Table）和字符串表（String Table）。\n\n这里我们用 MachOView 打开支付宝的可执行文件，找到其中的 Symbol Table 项。\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/symbol_table.jpg)\n\n符号表的结构是一个连续的列表，其中的每一项都是一个 `struct nlist`。\n\n```\n//  位于系统库 <macho-o/nlist.h> 头文件中\nstruct nlist {\n  union {\n  //符号名在字符串表中的偏移量\n    uint32_t n_strx;\t\n  } n_un;\n  uint8_t n_type;\n  uint8_t n_sect;\n  int16_t n_desc;\n  //符号在内存中的地址，类似于函数指针\n  uint32_t n_value;\n};\n```\n这里重点关注第一项和最后一项，第一项是符号名在字符串表中的偏移量，用于表示函数名，最后一项是符号在内存中的地址，类似于函数指针（这里只说明大概的结构，详细的信息请参考官方Mach O文件格式的文档）。\n\n也就是说如果我们知道了符号名和内存地址的对应关系，我们是可以根据这个结构来逆向构造出符号表数据的。\n\n知道了如何构造符号表，下一步就是收集符号名和内存地址的对应关系了。\n\n### 获取OC方法的符号表\n\n因为OC语言的特性，编译器会将类名、函数名等编译进最后的可执行文件中，所以我们可以根据Mach-O文件的结构逆向还原出工程里的所有类，这也就是大名鼎鼎的逆向工具 class-dump 了。class-dump 出来的头文件里是有函数地址的：\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/class_dump_imp.png)\n\n所以我们只要对class-dump的源码稍作修改，即可获取我们要的信息。\n\n### 符号表恢复工具\n\n整理完数据格式，又理清了数据来源，我们就可以写工具了。\n\n实现过程就不详细说明了，工具开源在我的Github上了，链接：\nhttps://github.com/tobefuturer/restore-symbol\n\n我们来看看怎么用这个工具：\n\n**1.下载源码编译**\n\n```\ngit clone --recursive https://github.com/tobefuturer/restore-symbol.git\ncd restore-symbol && make\n./restore-symbol\n```\n\n**2.恢复OC的符号表，非常简单**\n\n```\n./restore-symbol ./origin_AlipayWallet -o ./AlipayWallet_with_symbol\n```\n\norigin_AlipayWallet 为Clutch砸壳后，没有符号表的 Mach-O 文件\n-o 后面跟输出文件位置\n\n**3.把 Mach-O 文件重签名打包，看效果**\n\n文件恢复符号表后，多出了20M的符号表信息\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/restore_size.jpg)\n\nXcode里查看调用栈\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/restore_only_oc.jpg)\n\n可以看到，OC函数这部分的符号已经恢复了，函数调用栈里已经能看出大致的调用过程了，但是支付宝里，采用了block的回调形式，所以还有很大一部分的符号没能正确显示。\n\n下面我们就来看看怎么样恢复这部分block的符号。\n\n### 获取block的符号信息\n\n还是同样的思路，要恢复block的符号信息，我们必须知道block在文件中的储存形式。\n\n### block在内存中的结构\n\n首先，我们先分析下运行时，block在内存中的存在形式。block在内存中是以一个结构体的形式存在的，大致的结构如下：\n\n```\nstruct __block_impl {\n  /**\n  block在内存中也是类NSObject的结构体，\n  结构体开始位置是一个isa指针\n  */\n  Class isa;\n  \n  /** 这两个变量暂时不关心 */\n  int flags;\n  int reserved;\n  \n  /**\n  真正的函数指针！！\n  */\n  void (*invoke)(...);\n  ...\n}\n```\n\n说明下block中的isa指针，根据实际情况会有三种不同的取值，来表示不同类型的block：\n\n* _NSConcreteStackBlock\n\n    栈上的block，一般block创建时是在栈上分配了一个block结构体的空间，然后对其中的isa等变量赋值。\n\n* _NSConcreteMallocBlock\n\n    堆上的block，当block被加入到GCD或者被对象持有时，将栈上的block复制到堆上，此时复制得到的block类型变为了_NSConcreteMallocBlock。\n\n* _NSConcreteGlobalBlock\n\n    全局静态的block，当block不依赖于上下文环境，比如不持有block外的变量、只使用block内部的变量的时候，block的内存分配可以在编译期就完成，分配在全局的静态常量区。\n\n第2种block在运行时才会出现，我们只关注1、3两种，下面就分析这两种isa指针和block符号地址之间的关联。\n\n\n### block isa指针和符号地址之间的关联\n\n分析这部分需要用到IDA这个反汇编软件, 这里结合两个实际的小例子来说明：\n\n**1._NSConcreteStackBlock**\n\n假设我们的源代码是这样很简单的一个block：\n\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    int t = 2;\n    void (^ foo)() = ^(){\n        NSLog(@\"%d\", t); //block 引用了外部的变量t\n    };\n    foo();\n}\n@end\n```\n\n编译完后，实际的汇编长这个样子：\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/example_stack_block.jpg)\n\n实际运行时，block的构造过程是这样：\n\n1. 为block开辟栈空间\n2. 为block的isa指针赋值（一定会引用全局变量：_NSConcreteStackBlock）\n3. 获取函数地址，赋值给函数指针\n\n所以我们可以整理出这样一个特征：\n\n*重点来了!!!*\n\n*凡是代码里用到了栈上的block，一定会获取__NSConcreteStackBlock作为isa指针，同时会紧接着获取一个函数地址，那个函数地址就是block的函数地址。*\n\n结合下面这个图，仔细理解上面这句话\n（这张图和上面那张图是同一个文件，不过裁掉了符号表）\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/example_stack_block_strip.jpg)\n\n利用这个特征，逆向分析时我们可以做如下推断：\n\n在一个OC方法里发现引用了__NSConcreteStackBlock这个变量，那么在这附近，一定会出现一个函数地址，这个函数地址就是这个OC方法里的一个block。\n\n比如上面图中，我们发现 viewDidLoad 里，引用了__NSConcreteStackBlock,同时紧接着加载了 sub_100049D4 的函数地址，那我们就可以认定sub_100049D4是viewDidLoad里的一个block, sub_100049D4函数的符号名应该是 viewDidLoad_block.\n\n**2. _NSConcreteGlobalBlock**\n\n全局的静态block，是那种不引用block外变量的block，他因为不引用外部变量，所以他可以在编译期就进行内存分配操作，也不用担心block的复制等等操作，他存在于可执行文件的常量区里。\n\n不太理解的话，看个例子：\n\n我们把源代码改成这样：\n\n```\n@implementation ViewController\n- (void)viewDidLoad {\n   \n    void (^ foo)() = ^(){\n        //block 不引用外部的变量\n        NSLog(@\"%d\", 123);\n    };\n    foo();\n}\n@end\n```\n\n那么在编译后会变成这样：\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/example_global_block.jpeg)\n\n那么借鉴上面的思路，在逆向分析的时候，我们可以这么推断\n\n1. 在静态常量区发现一个_NSConcreteGlobalBlock的引用\n2. 这个地方必然存在一个block的结构体数据\n3. 在这个结构体第16个字节的地方会出现一个值，这个值是一个block的函数地址\n\n**3. block 的嵌套结构**\n\n实际在使用中，可能会出现block内嵌block的情况：\n\n```\n- (void)viewDidLoad {\n  dispatch_async(background_queue ,^{\n    ...\n    dispatch_async(main_queue, ^{\n      ...     \n    });\n  });\n}\n```\n\n所以这里block就出现了父子关系，如果我们将这些父子关系收集起来，就可以发现，这些关系会构成图论里的森林结构，这里可以简单用递归的深度优先搜索来处理，详细过程不再描述。\n\n### block符号表提取脚本（IDA+python）\n\n整理上面的思路，我们发现搜索过程依赖于IDA提供各种引用信息，而IDA是提供了编程接口的，可以利用这些接口来提取引用信息。\n\nIDA提供的是Python的SDK，最后完成的脚本也放在仓库里search_oc_block/ida_search_block.py。\n\n### 提取block符号表\n\n这里简单介绍下怎么使用上面这个脚本\n\n1.用IDA打开支付宝的 Mach-O 文件\n2.等待分析完成！ 可能要一个小时\n3.Alt + F7 或者 菜单栏 File -> Script file...\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/ida_select_script.jpg)\n\n4.等待脚本运行完成，预计30s至60s，运行过程中会有这样的弹窗\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/ida_script_running.jpg)\n\n5.弹窗消失即block符号表提取完成\n6.在IDA打开文件的目录下,会输出一份名为block_symbol.json的json格式block符号表\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/ida_result_position.png)\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/ida_result_sample.jpg)\n\n### 恢复符号表&实际分析\n\n用之前的符号表恢复工具，将block的符号表导入Mach-O文件\n\n```\n./restore-symbol ./origin_AlipayWallet -o ./AlipayWallet_with_symbol -j block_symbol.json\n```\n\n-j 后面跟上之前得到的json符号表\n\n最后得到一份同时具有OC函数符号表和block符号表的可执行文件\n\n这里简单介绍一个分析案例, 你就能体会到这个工具的强大之处了。\n\n1.在Xcode里对 -[UIAlertView show] 设置断点\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/xcode_breakpoint.jpg)\n\n2.运行程序，并在支付宝的登录页面输入手机号和错误的密码，点击登录\n3.Xcode会在‘密码错误’的警告框弹出时停下，左侧会显示出这样的调用栈\n\n*一张图看完支付宝的登录过程*\n\n![](http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/xcode_backtrace.jpg)\n\n项目开源地址：\nhttps://github.com/tobefuturer/restore-symbol\n\n欢迎大家在上面提各种Issues，或者有问题也可以直接Email（tobefuturer@gmail.com）。\n\n\n\n\n\n","tags":["逆向工程"],"categories":["iOS"]},{"title":"SSH公钥配置","url":"%2F2017%2F03%2F25%2Fssh-setting%2F","content":"\n\n当我们从git仓库下载一个项目时，我们习惯用如下命令\n\n```\n//从coding获取源码\ngit clone git@git.coding.net:username/project.git\n//从github获取代码\ngit clone git@github.com:username/project.git\n```\n如果是一次clone,可能会遇到这样的错误信息，因为没有配置SSH公钥而导致的认证失败\n\n<!-- more -->\n\n```\nThe authenticity of host 'git.coding.net (219.146.244.71)' can't be established.\nRSA key fingerprint is SHA256:jok3FH7q5LJ6qvE7iPNehBgXRw51ErE77S0Dn+Vg/Ik.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added 'git.coding.net,219.146.244.71' (RSA) to the list of known hosts.\nPermission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n现在我们来解决这个问题，Mac/Linux打开terminal终端，输入命令\n\n```\nssh-keygen -t rsa -C “username@example.com”(注册时使用的邮箱)\n```\n\n期间会要求输入存储路径和密码，存储路径维持默认，直接回车即可，密码可输可不输，也是直接回车即可。\n\n```\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/Users/abc/.ssh/id_rsa): (要求输入保存路径，直接回车)\nEnter passphrase (empty for no passphrase): (要求输入密码，可不输入，直接回车)\nEnter same passphrase again: \n```\n\n生成成功后会看到这样的结果\n\n```\nYour identification has been saved in /Users/abc/.ssh/id_rsa.\nYour public key has been saved in /Users/abc/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:h4OoqopIITKTyh0IxJQUhuWbSCfJVSvtUhnLK6dYN0Y username@example.com\nThe key's randomart image is:\n+---[RSA 2048]----+\n|=B+..o           |\n|=+o o =          |\n|.=.o E           |\n|oo+o=... .       |\n|Boo=.B. S .      |\n|=o=.O .  o       |\n|.+.o             |\n|+.               |\n|O                |\n+----[SHA256]-----+\n```\n\n公钥文件已经保存在了```/Users/abc/.ssh/id_rsa.pub```打开这个文件，或执行'cat /Users/abc/.ssh/id_rsa.pub'查看内容。\n\n将公钥内容配置到git服务器即可。\n\n![](/images/ssh-setting/14903644615279.jpg)\n\n\n到此为止，SSH公钥配置已经完成，再次执行clone命令就可以成功把源码下载下来。\n\n","tags":["SSH"]},{"title":"Hexo Next博客搭建","url":"%2F2017%2F03%2F20%2Fhexo-setting%2F","content":"\n本博客使用Hexo搭建的静态博客，Theme使用的是Next\n\n[Theme for Hexo](https://theme-next.org/)","tags":["Hexo"],"categories":["Hexo"]}]